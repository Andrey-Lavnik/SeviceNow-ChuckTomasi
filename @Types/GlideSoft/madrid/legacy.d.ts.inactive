//SCOPED GlideSoft Definition File. In combination with JSConfig.json I provide you intellisense for ServiceNow APIs.


/**
 * Provides common methods for classes based on records in the database. Use this script include as a base class to create your own database object class.
 * 
 * 
 */
declare class AbstractDBObject {



    /**
     * Determines if the current database record is valid.
     * 
     * @returns True if the database record is valid, false otherwise.
     */
    isValid(): Boolean;

}

/**
 * Use this script include as a base class to create your own Discovery reconciler. This is an abstract base class for reconciling newly discovered data in an XMLMemoryTable to a related list in the database. AbstractReconciler implements the common logic and helper methods for reconciling related lists for a particular CMDB item against discovered information present in a MemoryTable instance. * * Most of this logic is very straightforward, but one bit may not be: the resolution of references to previously reconciled records. This feature works by collecting information while reconciling one related list, then passing that information on to the reconciler for another related list. For example, while switch partitions are being reconciled, information is gathered (in a map instance) that maps an interface number for a partition to the sys_id of the partition's record in the partition table. Then later when the switchports are being reconciled, a reference to the switch partition that contains the switchport can be resolved by using this map.
 * 
 * 
 */
declare class AbstractReconciler {



    /**
     * Determines if the newly discovered data is different than the data already in the database for the current item.This method is only invoked for items that have been rediscovered.Mandatory method, must be overridden in all concrete subclasses.
     * 
     * @returns True if the data has changed.
     */
    getReconciliationField(): Boolean;

    /**
     * Gets the string value of the field to be used as a key to look up a record in the newly discovered data.This value will be used to attempt to find a record in the discovered data, using the column returned by the getReconciliationKey() method.Mandatory method, must be overridden in all concrete subclasses.
     * 
     * @returns Value to use as a key into the discovered data.
     */
    getReconciliationKey(): String;

    /**
     * Returns true if the newly discovered data is different than the data already in the database for this item.This method is only invoked for items that have been rediscovered.Mandatory method, must be overridden in all concrete subclasses.
     * 
     * @returns True if the discovered data is different than the data already in the database.
     */
    hasChanged(): Boolean;

    /**
     * Marks CIs as absent by setting the install status to "Absent"; other tables are marked by setting the (presumed present) field "absent" to true.
     * 
     */
    markAbsent();

    /**
     * Marks CIs as present by setting the install status to "Installed"; other tables are marked by setting the (presumed present) field "absent" to false.
     * 
     */
    markPresent();

    /**
     * Reconciles the newly discovered data with the data already present in the database and resolves references to previously reconciled data.
     * 
     */
    process();

    /**
     * Reads the current memory table record of newly discovered data and checks its validity.Mandatory method, must be overridden in all concrete subclasses.
     * 
     * @returns True if the data is valid.
     */
    readDatabaseFields(): Boolean;

    /**
     * Reads the current memory table record of newly discovered data and checks its validity.Mandatory method, must be overridden in all concrete subclasses.
     * 
     * @returns True if the data is valid.
     */
    readDiscovered(): Boolean;

    /**
     * Reads the fields in the current database record into instance member fields.Mandatory method, must be overridden in all concrete subclasses.
     * 
     */
    resolveReferenceFields();

    /**
     * Sets the database fields for the current record to the values in the newly discovered information.This method is invoked both for new database records and for existing database records when the discovered data has changed.Mandatory method, must be overridden in all concrete subclasses.
     * 
     */
    setDatabaseFields();

    /**
     * Optional override for concrete subclasses that require special setup.
     * 
     */
    setup();

    /**
     * Optional method to override in concrete subclasses that need to resolve reference fields.This method is invoked after valid discovered data is read. Generally implementations will use some of this discovered data as a key into a map (passed into the concrete reconciler class when it was instantiated) that will return the sys_id of the database record holding the referenced information. However, implementations are not required to use this approach.
     * 
     * @sys_id The sys_id of the current database record.
     */
    track(sys_id: String);

}

/**
 * Base JavaScript processor class that other JavaScript processors extend. Extend this class to create your own JavaScript processors.
 * 
 * 
 */
declare class AbstractScriptProcessor {



    /**
     * Called by the Prototype JavaScript Framework during object construction.
     * 
     * @request The request
     * @response The response
     * @process The process
     */
    initialize(request: String, response: String, process: String);

    /**
     * Called by the Prototype JavaScript Framework during object processing. Do not call this method directly.
     * 
     */
    process();

}

/**
 * A helper class to facilitate working with the data displayed on timelines. Processing the data displayed within a timeline starts by executing the corresponding function of the specified script include. Like other script includes, the language syntax is JavaScript and follows the default security constraints of this type of resource. However, because the different types of display options are complex, a helper class was created. To display a timeline, extend the AbstractTimelineSchedulePage class and pair it with it's corresponding schedule page. At a minimum, extending classes should override the getItems() method, as this is the primary event handler for returning items to be displayed on the client. * * The client processes the data that AbstractTimelineSchedulePage returns in two phases. The first phase makes the actual updates to the timeline. Immediately after (if configured), the second phase displays a success message box, error message box, or dialog message prompt. In phase one, the available options for manipulating data include: * * Do Not Update Any Items - This is the default behavior. Do not perform any of the remaining steps in phase one. Update With Specific Items - This is done using: add(). Render The Timeline Using the getItems() Function - This is done using: setDoReRenderTimeline(true). * * Note: If both TimelineItems are returned and setDoReRenderTimeline is set to true, the system will ignore the setDoReRenderTimeline property and explicitly show only the TimelineItems that were added via the add() function. * * The available options in phase two include: * * Do Not Display Any Message Boxes - This is the default behavior. Display a Success Dialog Box - This is done using: setStatusSuccess(). Display an Error Dialog Box - This is done using: setStatusError(). Display a Dialog Confirm Box - This is done using: setStatusPrompt(). * * Note: A script include class that extends AbstractTimelineSchedulePage automatically receives all Uri parameters from the original Url whose prefix begins with sysparm_timeline_. To access the values of these, use: this.getParameter("sysparm_timeline_VARIABLE"); inside your extended class. This is useful if you need to display a schedule page from a dynamic element, such as from a context menu from a list. By passing in dynamic data via the Url the schedule page will auto-include these parameters inside the Ajax calls and therefore will be accessible inside the AbstractTimelineSchedulePage script includes.
 * 
 * 
 */
declare class AbstractTimeLineSchedulePage {



    /**
     * Adds a TimelineItem object that will be returned to the client and appropriately displayed on the timeline.
     * 
     * @ObjTimeline The TimelineItem object to add to the timeline.
     */
    add(ObjTimeline: Object);

    /**
     * Adds a horizontal frame separator into the list of timeline items. All future items added via add() will be added into the subsequent timeline frame.All future items added via add() will be added into the subsequent timeline frame.
     * 
     * @example
     * // Inside of a script include that extends AbstractTimelineSchedulePage
     *       this.addSeparator();
     *     
     */
    addSeparator();

    /**
     * Event handler for when a timeline span moves horizontally.
     * 
     * @spanSysId The sys ID of the current span being adjusted.
     * @newStartDateTimeMs The new start time of the span in milliseconds. Make sure to parse the string using parseInt() before performing any numerical comparisons.
     */
    elementMoveX(spanSysId: String, newStartDateTimeMs: String);

    /**
     * Event handler for when a timeline span moves both horizontally and vertically.
     * 
     * @spanSysId The sys ID of the current span being adjusted.
     * @itemSysId The sys ID of the timeline item associated with the current span.
     * @newItemSysId The sys ID of the timeline item (a row) that the current span was dragged into.
     * @newStartDateTimeMs The new start time of the span in milliseconds. Make sure to parse the string using parseInt() before performing any numerical comparisons.
     */
    elementMoveXY(spanSysId: String, itemSysId: String, newItemSysId: String, newStartDateTimeMs: String);

    /**
     * Event handler for when a timeline span moves vertically.
     * 
     * @spanSysId The sys ID of the current span being adjusted.
     * @itemSysId The sys ID of the timeline item associated with the current span.
     * @newItemSysId The sys ID of the timeline item (a row) that the current span was dragged into.
     */
    elementMoveY(spanSysId: String, itemSysId: String, newItemSysId: String);

    /**
     * Event handler for when a timeline relationship has been created between two spans.
     * 
     * @spanSysId The sys ID of the current span which will be a predecessor for the newly created relationship.
     * @newSuccSpanId The sys ID of the successor span from the relationship created.
     */
    elementSuccessor(spanSysId: String, newSuccSpanId: String);

    /**
     * Event handler for when a timeline span's end date was modified.
     * 
     * @spanSysId The sys ID of the current span that is being adjusted.
     * @newEndDateTimeMs The new end time of the span in milliseconds. Make sure to parse the string using parseInt() prior to performing any numerical comparisons.
     */
    elementTimeAdjustEnd(spanSysId: String, newEndDateTimeMs: String);

    /**
     * Event handler for when a timeline span's start date was modified.
     * 
     * @spanSysId The sys ID of the current span that is being adjusted.
     * @newStartDateTimeMs The new start time of the span in milliseconds. Make sure to parse the string using parseInt() prior to performing any numerical comparisons.
     */
    elementTimeAdjustStart(spanSysId: String, newStartDateTimeMs: String);

    /**
     * Event handler for returning schedule items to display on the timeline.
     * 
     */
    getItems();

    /**
     * Event handler for when a string was typed into the left pane input box.
     * 
     * @strInputText The text that was entered in the input box in the left pane.
     */
    inputBox(strInputText: String);

    /**
     * Event handler for when a timeline row item was moved and dragged into another row item.
     * 
     * @itemSysId The sys ID of the timeline item associated with the current span.
     * @newItemSysId The sys ID of the timeline item (a row) that the current span was dragged into.
     */
    itemMove(itemSysId: String, newItemSysId: String);

    /**
     * Specifies whether or not to re-render all of the timeline items using the getItems() function.
     * 
     * @b If true, re-render the timeline by making a new event call to the server's getItems() handler.
     */
    setDoReRenderTimeline(b: Boolean);

    /**
     * Specifies the text to display as the title of the timeline.The page title can be set (and updated) from any interactive event; however, is recommended to be set during the getItems() event.
     * 
     * @strTitle The text to be displayed on the timeline title.
     */
    setPageTitle(strTitle: String);

    /**
     * Sets the current event request to an error status with a specified title and message to display in phase two of the GlideTimeline event processing.
     * 
     * @strTitle The text to be displayed in the dialog box title.
     * @strMessage The text to be displayed within the dialog box. The text can contain HTML formatting.
     */
    setStatusError(strTitle: String, strMessage: String);

    /**
     * Sets the current event request to a prompt error status with a specified title and message to display in a confirmation dialog box during phase two of the GlideTimeline event processing. The confirmation box displays an OK and Cancel button that each generate new events that will call the functions specified the parameter arguments. The custom defined functions for OK, Cancel, and Close receive the same parameter arguments as those for the current event.The confirmation box displays an OK and Cancel button that each generate new events that will call the functions specified the parameter arguments. Note: The custom defined functions for OK, Cancel, and Close receive the same parameter arguments as those for the current event.
     * 
     * @strTitle The text to display in the dialog box. The text can contain HTML formatting.
     * @strOkFunction The function to call in the current script include class if the users clicks the OK button.
     * @strCancelFunction The function to call in the current script include class if the user clicks the Cancel button.
     * @strCloseFunction The function to call in the current script include class if the user clicks the Close button.
     * @example
     * var MyTimelineScriptIncludeClass = Class.create();
     *       MyTimelineScriptIncludeClass.prototype = Object.extendsObject(AbstractTimelineSchedulePage, {
     *       
     *       getItems: function() {
     *       //...
     *       },
     *       
     *       elementTimeAdjustEnd: function(spanSysId, newEndDateTimeMs) {
     *       // Display a status prompt dialog box
     *       this.setStatusPrompt('Confirm Action', 'Are you sure you want to do that?',
     *       'this._myOkHandlerFunction',  
     *       'this._myCancelHandlerFunction',
     *       'this._myCloseHandlerFunction');
     *       },
     *       
     *       _myOkHandlerFunction: function(spanSysId, newEndDateTimeMs) { // ... },
     *       
     *       _myCancelHandlerFunction: function(spanSysId, newEndDateTimeMs) { // ... },
     *       
     *       _myCloseHandlerFunction: function(spanSysId, newEndDateTimeMs) { // ... }
     *       };
     *     
     */
    setStatusPrompt(strTitle: String, strOkFunction: String, strCancelFunction: String, strCloseFunction: String);

    /**
     * Sets the current event request to a success status with a specified title and message to display in phase two of the GlideTimeline event processing.
     * 
     * @strTitle The text to be displayed in the dialog box title.
     * @strMessage The text to be displayed within the dialog box. The text can contain HTML formatting.
     */
    setStatusSuccess(strTitle: String, strMessage: String);

}

/**
 * A data object that is a member of the WorkflowModelManager class; ActivityHistoryRecord methods facilitate interacting with the WorkflowModelManager object. The ActivityHistoryRecord is basically a copy of the data from a GlideRecord on table wf_history. There are some helper methods defined for this class as well. There are no accessors or mutator to the simple data elements of this class.
 * 
 * 
 */
declare class ActivityHistoryRecord {



    /**
     * Changes the arrivedState of already known ids to true.As soon as this method changes the arrivedState of known ids to true, it tests to see if the join is satisfied. if it is, the model walk can continue; if not, it should continue to next appropriate transition. This is called during playback, as expected wf_activities flow to the join.
     * 
     * @activityIds Array of wf_activity.sys_ids that are headed towards join.
     */
    addArrivedActivityToJoin(activityIds: StringArray);

    /**
     * Seeds all the expected wf_activity sys_ids that are expected to pass through this join and sets their arriveState = false.This state is flipped to true as each expected activity transitions to this instance of the Join. This method is called as part of building the cached model in memory, and is not called during playback.
     * 
     * @activityIds Array of wf_activity.sys_ids that are headed towards join.
     */
    addJoinFromActivityIds(activityIds: StringArray);

    /**
     * As model is cached by _getExecutedTransitions(), this method adds transitions that have gone FROM this activity towards the .to activity.
     * 
     * @InTransition ExecutedTransition Javascript object to add to this activity.
     */
    addTransition(InTransition: Object);

    /**
     * Prints debug information.
     * 
     */
    debugDump();

    /**
     * Tests the incoming wf_activity sys_id, presumed to be seeded in this history record. If it is, it is tested to see if it is an activity that would come through this join.
     * 
     * @returns True, if it is an activity that would come through this join.
     */
    doesJoinContainActivity(): Boolean;

    /**
     * Returns the log string from the history record.
     * 
     * @returns The log string.
     */
    getLogString(): String;

    /**
     * Returns the sys_ids of the history records that transition to this Join activity that have already come through.
     * 
     * @returns Array of sys_ids of the history records that transition to this Join activity.
     */
    getSatisfiedJoinActivities(): StringArray;

    /**
     * Returns the transition count for this activity.
     * 
     * @returns Number of transitions from this activity.
     */
    getTransitionCount(): Number;

    /**
     * Returns the sys_ids of the history records that transition to this Join activity that the join is still waiting for.
     * 
     * @returns Array of sys_ids of the history records that transition to this Join activity.
     */
    getUnSatisfiedJoinActivities(): StringArray;

    /**
     * Determines if this activity is one of the Rollback activities.
     * 
     * @returns True, if activity is one of the Rollback activities.
     */
    isARollback(): Boolean;

    /**
     * Determines if the sys_id passed in is a destination of any of the transitions associated with this instance of an ActivityHistoryRecord.
     * 
     * @ahrSys_id Activity history sys_id from table wf_history.
     * @returns True, if the sys_id passed in is a destination of any of the transitions.
     */
    isIdADestination(ahrSys_id: String): Boolean;

    /**
     * Determines if this activity is a join.
     * 
     * @returns True, if the activity is "Join".
     */
    isJoin(): Boolean;

    /**
     * Examines the value of the arriveState.Called during playback when the transition to sys_id of a transition points to an activity that is a join.
     * 
     * @returns True, if the join is satisfied.
     */
    isJoinSatisfied(): Boolean;

    /**
     * Tests the incoming wf_activity sys_id, presumed to be seeded in this history record.If it is, it is tested to see if it has already been through; if it has, then this join is not waiting on this activity and it should look further downstream for the one that is waiting. This test is called in sequence as the model is walked, so it does presume in the instances of rollbacks and loops. If the sys_id is in here and the flag is true, this waiting Join is further up the sequence. This sort of check is required as the history records of Joins are removed from the history table, and so it is possible for a record to be in the transition table with no match in the corresponding history table, but is still an appropriate match for an earlier executed instance of the same Join.
     * 
     * @activityIds Array of wf_activity.sys_ids that are headed towards join.
     * @returns True, if the activity has already been through.
     */
    isJoinWaitingForActivity(activityIds: StringArray): Boolean;

    /**
     * Determines if this workflow was rolled back.
     * 
     * @returns True, if this workflow was rolled back.
     */
    isRolledBack(): Boolean;

    /**
     * Determines if this activity is a turnstile.
     * 
     * @returns True, if this activity is a turnstile.
     */
    isTurnstile(): Boolean;

}

/**
 * Provides methods for getting or setting agent presence and channel availability. The Agent API is provided within the sn_awa namespace. * * Requires the following: Advanced Work Assignment plugin (com.glide.awa) Role: awa_integration_user or admin 
 * 
 * 
 */
declare class Agent {



    /**
     * Gets an agent by sys_id.
     * 
     * @user_sys_id The sys_id of the user listed in sys_user table.
     * @example
     * var agent = sn_awa.Agent.get("&lt;user_sys_id&gt;");
     * var presence  = agent.getPresence();
     * @returns True if the user exists, false otherwise.
     */
    get(user_sys_id: String): Boolean;

    /**
     * Gets the current presence state and channel availability of a provided agent.
     * 
     * @example
     * var agent = sn_awa.Agent.get("&lt;user_sys_id&gt;");
     *         var presence  = agent.getPresence();
     * @returns Presence state sys_id, presence state name, and channel information. Error message otherwise.
     */
    getPresence(): Object;

    /**
     * Sets the state of a provided agent’s presence and sets the agent’s channel availability for that state.
     * 
     * @setRequest Contains setRequest.sys_id and setRequest.channels.
     * @setRequestsys_id Represents presence_sys_id from awa_presence_state table
     * @setRequestchannels Optional sys_id – channel_sys_id from the awa_service_channel table available – Agent availability to receive work for this channel (true or false) 
     * @example
     * var agent = sn_awa.Agent.get("&lt;user_sys_id&gt;");
     *         var presence = agent.setPresence({
     *         sys_id: &lt;presence_sys_id&gt;,
     *         channels: [{
     *         sys_id: "&lt;channel_sys_id&gt;",
     *         available: true // or false
     *     }]
     * });
     * @returns True if successful, false otherwise.
     */
    setPresence(setRequest: Object, setRequestsys_id: String, setRequestchannels: name/valuepair): Boolean;

}

/**
 * Processes inbound MID server metrics. Updates these tables. ECC Agent Counter Metric ECC Agent Memory Metric ECC Agent RGR Metric ECC Agent Scalar Metric * * Use these methods in server scripts.
 * 
 * 
 */
declare class AgentMetrics {



    /**
     * Creates an instance of AgentMetrics.
     * 
     */
    constructor();

    /**
     * Handles counter metrics from the agent by putting them into an array that can be used to update the ECC Agent Counter Metric table (ecc_agent_counter_metric).
     * 
     * @metric The counter object from the agent
     * @name The device name
     * @midId The MID server sys_id
     * @example
     * var amtc = new AgentMetrics();
     * amtc.handleCounter('count', 'server_name', '1098888bbb9483abcd89981ffaeff');
     */
    handleCounter(metric: String, name: String, midId: String);

    /**
     * Updates the memory metrics for the given agent.
     * 
     * @metric The memory object from the agent
     * @name The device name
     * @midId The MID server sys_id
     * @example
     * var amtc = new AgentMetrics();
     * amtc.handleMemory('mem_obj', 'server_name', '1098888bbb9483abcd89981ffaeff');
     */
    handleMemory(metric: String, name: String, midId: String);

    /**
     * Handles metric information from a remote glide record by putting it into an array.
     * 
     * @metric The remote object from the agent
     * @name The device name
     * @midId The MID server sys_id
     * @example
     * var amtc = new AgentMetrics();
     * amtc.handleRGR('remote_obj', 'server_name', '1098888bbb9483abcd89981ffaeff');
     */
    handleRGR(metric: String, name: String, midId: String);

    /**
     * Handles scalar values from the agent by putting them into an array.
     * 
     * @metric The counter object from the agent
     * @name The device name
     * @midId The MID server sys_id
     * @example
     * var amtc = new AgentMetrics();
     * amtc.handleScalar('scalar', 'server_name', '1098888bbb9483abcd89981ffaeff');
     */
    handleScalar(metric: String, name: String, midId: String);

    /**
     * Updates the specified metrics table with the new metric information.
     * 
     * @tableName The metrics table to update
     * @values The object containing the values to add to the table
     * @metric The metric type to add to the table
     * @midID The MID server sys_id
     * @example
     * var amtc = new AgentMetrics();
     * amtc.handleMemory('memory', 'server_name', '1098888bbb9483abcd89981ffaeff');
     * amtc.updateMetric('ecc_agent_memory_metric', 'm_values', 'memory', '1098888bbb9483abcd89981ffaeff');
     */
    updateMetric(tableName: String, values: String, metric: String, midID: String);

}

/**
 * Handles SNMP classification and identification for UPSs, environmental monitors, and PDUs made by APC. Use this API for SNMP classification and identification.
 * 
 * 
 */
declare class APCHandler {



    /**
     * Classifies and identifies APC devices.
     * 
     */
    classifyAndIdentify();

}

/**
 * Reconciles outlets for power distribution units. Use this API for SNMP-related discovery.
 * 
 * 
 */
declare class ApcPduOutletReconciler {



    /**
     * Returns the reconciliation field.
     * 
     * @returns The reconciliation field
     */
    getReconcilationField(): String;

    /**
     * Returns the reconciliation key.
     * 
     * @returns The reconciliation key
     */
    getReconcilationKey(): String;

    /**
     * Determines if the outlet state has changed.
     * 
     * @returns True if the outlet state has changed; otherwise, false.
     */
    hasChanged(): Boolean;

    /**
     * Reads the outlet database fields.
     * 
     */
    readDatabaseFields();

    /**
     * Reads the discovered outlet database fields.
     * 
     */
    readDiscovered();

    /**
     * Sets the outlet database fields.
     * 
     */
    setDatabaseFields();

}

/**
 * ArrayUtil API is a script include with useful functions for working with JavaScript arrays. These methods are available to any server-side script.
 * 
 * 
 */
declare class ArrayUtil {



    /**
     * Merge two arrays.
     * 
     * @parent An array to merge
     * @child An array to merge
     * @example
     * var arrayUtil = new ArrayUtil();
     * var a1 = new Array("a", "b", "c");
     * var a2 = new Array("c", "d", "e");
     *  
     * gs.print("concat a1, a2: " + arrayUtil.concat(a1, a2));
     * @returns An array of elements from both input arrays. Duplicates are not removed.
     */
    concat(parent: Array<any>, child: Array<any>): Array<any>;

    /**
     * Searches the array for the element. Returns true if the element exists in the array, otherwise returns false.
     * 
     * @array The array to search
     * @element The element to search for
     * @example
     * var arrayUtil = new ArrayUtil();
     * var a1 = new Array("a", "b", "c");
     *  
     * gs.print("Contains b: " + arrayUtil.contains(a1, "b"));
     * gs.print("Contains x: " + arrayUtil.contains(a1, "x"));
     * @returns True if the element is in the array, false otherwise.
     */
    contains(array: Array<any>, element: Object): Boolean;

    /**
     * Convert an object to an array.
     * 
     * @a The object to be converted.
     * @returns An array created from the object.
     */
    convertArray(a: Object): Array<any>;

    /**
     * Finds the differences between two or more arrays.Any number of arrays can be provided as parameters.
     * 
     * @a An array
     * @b An array
     * @example
     * var arrayUtil = new ArrayUtil();
     * var a1 = new Array("a", "b", "c");
     * var a2 = new Array("c", "d", "e");
     * gs.print(arrayUtil.diff(a1, a2));
     * @returns Returns an array of items from array a that were not found in either array b or c, or other input arrays. Duplicates are removed from the result.
     */
    diff(a: Array<any>, b: Array<any>): Array<any>;

    /**
     * Returns an array from the object.
     * 
     * @object The object from which to create an array.
     * @returns An array created from the object.
     */
    ensureArray(object: Object): Array<any>;

    /**
     * Searches the array for the element. Returns the element index if found, -1 otherwise.
     * 
     * @array The array to search
     * @element The element to search for
     * @example
     * var arrayUtil = new ArrayUtil();
     * var a1 = new Array("a", "b", "c");
     *  
     * gs.print("indexOf b: " + arrayUtil.indexOf(a1, "b"));
     * gs.print("indexOf x: " + arrayUtil.indexOf(a1, "x"));
     * @returns The index where the element was found, -1 otherwise.
     */
    indexOf(array: Array<any>, element: Object): Number;

    /**
     * Searches the array for the element starting with the startIndex element. Returns the element index.
     * 
     * @array The array to search
     * @element The element to search for
     * @startIndex The index to begin the search
     * @returns The position of the element in the array, or -1 if the element is not in the array.
     */
    indexOf(array: Array<any>, element: Object, startIndex: Number): Number;

    /**
     * Finds the elements present in all arrays.Any number of arrays can be provided as parameters.
     * 
     * @a An array
     * @b An array
     * @example
     * var arrayUtil = new ArrayUtil();
     * var a1 = new Array("a", "b", "c");
     * var a2 = new Array("c", "d", "e");
     * gs.print(arrayUtil.intersect(a1, a2));
     * @returns An array of elements from array a that were found in all of the other input arrays. Duplicates are removed.
     */
    intersect(a: Array<any>, b: Array<any>): Array<any>;

    /**
     * Merge two or more arrays.Any number of arrays can be provided as parameters.
     * 
     * @a An array
     * @b An array
     * @example
     * var arrayUtil = new ArrayUtil();
     * var a1 = new Array("a", "b", "c");
     * var a2 = new Array("c", "d", "e");
     * gs.print(arrayUtil.union(a1, a2));
     * @returns An array of items from all the input arrays. Duplicates are removed.
     */
    union(a: Array<any>, b: Array<any>): Array<any>;

    /**
     * Removes duplicate items from an array.
     * 
     * @a The array to check for duplicate elements.
     * @example
     * var arrayUtil = new ArrayUtil();
     * var a1 = new Array("a", "b", "c", "c", "b");
     * gs.print(arrayUtil.unique(a1));
     * @returns An array of unique items from the input array.
     */
    unique(a: Array<any>): Array<any>;

}

/**
 * The AssessmentCreation class provides methods that administrators can use to generate assessments and surveys. There are multiple ways to call the createAssessmentsmethod. You must set the typeID parameter in all cases to identify a metric type or survey definition. Some of the factors that influence how the method behaves include: Whether the target is an assessment or survey Whether the assessment schedule type is on-demand or scheduled Survey schedule periods Parameters provided For example, when the method is called with only the typeID parameter set, the method searches for stakeholders or survey users to send invitations to. In contrast, when the method is called with the typeID and userID parameters set, it attempts to send invitations to the specified users.
 * 
 * 
 */
declare class AssessmentCreation {



    /**
     * Creates one or more assessments or surveys for the specified metric type or survey definition.
     * 
     * @typeID The sys_id of the metric type or survey definition for which to generate assessments or surveys.
     * @sourceRecordID One or more comma-separated sys_ids of records to include in the assessments generated. There must be an assessable record associated with the specified metric type for each source record. If this parameter is left blank, the assessments generated include all assessable records for the specified type. This parameter is for use with assessments only.
     * @userID One or more comma-separated sys_ids of users to which to send assessment or survey instances. If this parameter is left blank, the assessment stakeholders or survey users receive instances. This parameter is required for on-demand assessments.
     * @returns If the method is successful, it returns a comma-separated string such as 7a2ad2253784200044e0bfc8bcbe5de1, 10, b7e8b5d4c0a80169008b49e468920048 (Instance ID, number of instances, Group ID) with the following values: instanceID: Sys_id of the assessment or survey instance created, if there is only one. Sys_id of one of the instances, if there are multiple. If there are multiple instances, use the group ID to retrieve data. #instances: Number of assessment or survey instances created. groupID: Sys_id of the assessment group that contains the assessment or survey instances created. If the method is unable to generate assessments or surveys, it returns one of the error codes.
     * Error Codes isscheduled - Indicates that the userID or sourceRecordID parameter should not have been used. When the typeID value represents a metric type with the Schedule type field set to Scheduled, the typeID parameter is the only parameter that may be used. draft_state - Indicates that the typeID value is a metric type or survey definition that is not published. Publish the metric type or survey definition. invalidtype - Indicates that there is no existing metric type that matches the typeID value. inactive - Indicates that the typeID value is a metric type or survey definition that is not active. Navigate to the metric type or survey definition and select the Active check box. not_available - Indicates that the typeID value is a metric type or survey definition that has no metrics or survey questions. Add at least one metric or survey question. notyet - Indicates that at least one of the users in the userID value is assigned a survey instance for the specified survey definition, that has yet to expire. The error code returns the expiration date. wip - Indicates that at least one of the users in the userID value is already assigned a survey instance for the survey. not_authorized - Indicates that at least one of the users in the userID value is not authorized to take the survey. Verify that one of the following is true: There are no survey users for the specified survey definition. All the users in the userID value are saved as survey users for the specified survey definition. completed - Indicates that the typeID value is a survey definition with the Schedule period field set to Only Once and that at least one of the users in the userID value has already completed a survey instance for that survey definition. nousers - Indicates that the userID parameter was not used and that one of the following is true: There are no stakeholders associated with the specified metric type. Set the userID parameter or create at least one stakeholder. There are no survey users associated with the specified survey definition. Set the userID parameter or create at least one survey user. nosources - Indicates that the typeID value is a metric type with the Schedule type field set to On demand and that neither the userID nor sourceRecordID parameter was used. Set at least one of these parameters. 
     */
    CreateAssessments (typeID: String, sourceRecordID: String, userID: String): String;

}

/**
 * Provides generic exception wrapping for automation. Include this in automation code to implement error handling.
 * 
 * 
 */
declare class AutomationException {



    /**
     * Retrieves the error message.
     * 
     * @example
     * var ae = new AutomationException("This is an error message");
     * gs.print(ae.getMessage());
     * @returns The error message
     */
    getMessage(): String;

}

/**
 * Unify service management by converting manually-created services to application services, populating application services, and adding/removing CIs and connections. Use BusinessServiceManager methods in global server scripts. You must have the Application Service administrator [app_service_admin] role.
 * 
 * 
 */
declare class BusinessServiceManager {



    /**
     * Instantiates a BusinessServiceManager object.
     * 
     * @example
     * var bsManager = new SNC.BusinessServiceManager();
     */
    constructor();

    /**
     * Adds a CI to a manually-created application service.
     * 
     * @service_id Sys ID of the application service to add a CI to. Must be of type cmdb_ci_service_discovered.
     * @source_id Sys ID of the CI whose outgoing connection joins the target CI.
     * @target_id Sys ID of the CI to add to the service. Cannot be a blacklisted item. Blacklisted items are CIs added to the sa.mapping.user.manual.citype.blacklist system property that are excluded from specific operations.
     * @example
     * //Application service is 'PeopleSoft Portals'
     * //Source CI is windows server 'PS Apache01'
     * //Target CI is 'SAP WEB01'
     * 
     * var bsManager = new SNC.BusinessServiceManager();
     * var appService = bsManager.addCI('2fce42d80a0a0bb4004af34d7e3984c8','3a27d4370a0a0bb4006316812bf45439', '3a6cadc1c0a8ce01001f1e5d0d7d68fa');
     */
    addCI(service_id: String, source_id: String, target_id: String);

    /**
     * Adds a manually created connection to an application service.
     * 
     * @source_id Sys ID of the CI to add to the connection.
     * @manual_endpoint GlideRecord object in the cmdb_ci_endpoint_manual table to add to the application service.
     * @service_id Sys ID of the application service to add the connection to.
     * @example
     * var gr = new GlideRecord("cmdb_ci_endpoint_manual");
     * gr.initialize(); 
     * gr.name='myEndpoint'; 
     * gr.insert();
     * 
     * var bsManager = new SNC.BusinessServiceManager();
     * var appService = bsManager.addManualConnection("3a307c930a0a0bb400353965d0b8861f", gr, "2fce42d80a0a0bb4004af34d7e3984c8");
     */
    addManualConnection(source_id: String, manual_endpoint: Object, service_id: String);

    /**
     * Converts a manual service to an application service.
     * 
     * @service_id Sys ID of the manual service to convert.
     * @example
     * var bsManager = new SNC.BusinessServiceManager();
     * var appService = bsManager.migrateManualToApplicationService("451047c6c0a8016400de0ae6df9b9d76");
     * @returns True if the migration to an application service succeeds.
     */
    migrateManualToApplicationService(service_id: String): Boolean;

    /**
     * Populates an application service with relations and CIs from the designated entry point.
     * 
     * @service_id Sys ID of the application service to populate.
     * @levels Number of levels of CIs to add from the CMDB.
     * @black_listed_relation_types Relation types to exclude when populating the application service.
     * @example
     * var bsManager = new SNC.BusinessServiceManager();
     * var appService = bsManager.populateApplicationService("5bf65ebeedb91300964f6fa662989533", 10, "Depends on::Used by");
     * @returns True if the operation is successful.
     */
    populateApplicationService(service_id: String, levels: Number, black_listed_relation_types: String): Boolean;

    /**
     * Removes a manually created CI from an application service.
     * 
     * @service_id Sys ID of the application service to remove a CI from. Note: Passing a GlideRecord object is also supported. 
     * @target_id Sys ID of the CI to remove from the application service. Note: Passing a GlideRecord object is also supported. 
     * @example
     * var bsManager = new SNC.BusinessServiceManager();
     * var appService = bsManager.removeCI("2fce42d80a0a0bb4004af34d7e3984c8", "3a290cc60a0a0bb400000bdb386af1cf");
     */
    removeCI(service_id: String, target_id: String);

    /**
     * Removes a manually created connection and the connected CI from an application service.
     * 
     * @source_id Sys ID of the CI connected to the endpoint.
     * @endpoint_id Sys ID of the manually created connection to remove from the application service
     * @service_id Sys ID of the application service to remove the connection from.
     * @example
     * var bsManager = new SNC.BusinessServiceManager();
     * var appService = bsManager.removeManualConnection("3a307c930a0a0bb400353965d0b8861f", "60ce3176edb91300964f6fa6629895d1", "2fce42d80a0a0bb4004af34d7e3984c8");
     */
    removeManualConnection(source_id: String, endpoint_id: String, service_id: String);

}

/**
 * Helper functions found in the Change Management Collision Detector Plugin. Use these methods in server side scripts, or when using AJAX calls on the client. You must have the Change Management Collision Detector Plugin installed to use these methods.
 * 
 * 
 */
declare class ChangeCollisionHelper {



    /**
     * Adds the CI to the change's affected CI list.
     * 
     * @ci The sys_id of the configuration item
     * @changeId The change record's sys_id
     */
    addCiToChangeAffectedCis(ci: String, changeId: String);

    /**
     * Returns the Affected CI sys_ids for the given change.
     * 
     * @changeId A change record's sys_id
     * @returns An array of sys_ids of affected CIs.
     */
    getAffectedCisByChangeId(changeId: String): Array<any>;

    /**
     * Returns any blackout that overlap the period defined by startDate and endDate.
     * 
     * @startDate The beginning date
     * @endDate The ending date
     * @returns An array of blackouts (blackoutId:stringSpan).
     */
    getBlackoutsByDate(startDate: GlideDateTime, endDate: GlideDateTime): Array<any>;

    /**
     * Returns changes scheduled in the timespan (defined by startDate and endDate) that have the given CI in their Affected CIs list.
     * 
     * @ci The configuration item's sys_id
     * @startDate The beginning date
     * @endDate The ending date of the time span
     * @returns An array of change record's sys_ids
     */
    getChangesWithAffectedCi(ci: String, startDate: GlideDateTime, endDate: GlideDateTime): Array<any>;

    /**
     * Returns the changes that are in the timespan (startDate, endDate) and that are linked to the given CI.
     * 
     * @ci The configuration item's sys_id
     * @startDate The beginning date
     * @endDate The ending date of the time span
     * @returns An array of sys_ids for change records
     */
    getChangesWithCi(ci: String, startDate: GlideDateTime, endDate: GlideDateTime): Array<any>;

    /**
     * Returns the Maintenance Schedule for a CI.
     * 
     * @ci The configuration item's sys_id
     */
    getCiMaintenanceSchedule(ci: String);

    /**
     * Returns all the CIs that depend on the given CI.
     * 
     * @ci A configuration item's sys_id
     * @returns An array of CIs
     */
    getDependants(ci: String): Array<any>;

    /**
     * Returns all the CIs that the given CI depends on.
     * 
     * @ci The configuration item's sys_id
     * @returns An array of CIs
     */
    getDependencies(ci: String): Array<any>;

    /**
     * Check if an CI is already in the change's affected CIs list.
     * 
     * @ci The sys_id of the configuration item
     * @changeId The change record's sys_id
     * @returns True if the CI already is in the change's affected CI list.
     */
    isCiInAffectedCis(ci: String, changeId: String): Boolean;

    /**
     * Checks if the time span defined by startDate and endDate falls in the CI's maintenance window.
     * 
     * @startDate The beginning date
     * @endDate The ending date
     * @maintenanceWindow The configuration item's sys_id
     * @returns True if the time span is in the CI's maintenance window
     */
    isDateInCiMaintenanceWindows(startDate: GlideDateTime, endDate: GlideDateTime, maintenanceWindow: String): Boolean;

}

/**
 * Helper functions found in the Change Management Collision Detector Plugin. Use these methods in server side scripts, or when using AJAX calls on the client. You must have the Change Management Collision Detector Plugin installed to use these methods.
 * 
 * 
 */
declare class ChangeConflict {



    /**
     * Creates an instance of ChangeConflict.
     * 
     * @ciId A configuration item's sys_id
     * @changeId A change request's sys_id
     * @type A value from the conflict's type choice list
     */
    constructor(ciId: String, changeId: String, type: Number);

    /**
     * Returns a string representation of the conflict.
     * 
     * @returns The string representation of the conflict
     */
    toString(): String;

}

/**
 * Helper functions found in the Change Management Collision Detector Plugin. Use these methods in server side scripts, or when using AJAX calls on the client. You must have the Change Management Collision Detector Plugin installed to use these methods.
 * 
 * 
 */
declare class ChangeConflictHandler {



    /**
     * Creates an instance of ChangeConflictHandler.
     * 
     */
    constructor();

    /**
     * Adds the Change Conflict to a Change Conflict Container.
     * 
     * @chgConflict The sys_id of the change conflict
     */
    addChangeConflict(chgConflict: String);

    /**
     * Deletes conflicts that are associated with the same change request (by sys_id).
     * 
     * @changeId The sys_id of the change request
     */
    deleteConflictsByChangeId(changeId: String);

    /**
     * Returns an array of Change Conflicts from a Change Conflict Container.
     * 
     * @returns An array of change conflicts
     */
    getConflicts(): Array<any>;

    /**
     * Writes out the Change Conflicts in a Change Conflict Container array to individual Change Conflict records.
     * 
     */
    saveConflicts();

}

/**
 * Utility class for working with CI data structures in JavaScript. Instances of this class represent a CI (both its base record and any related lists), and the provided methods allow loading from or storing both the base record and related lists. * * This class acts as a container for simple classes acting as maps of property name/value pairs. This class contains three kinds of such maps. A single map representing the base CI table entry (such as one row cmdb_ci_linux_server and its superclasses). This map can be retrieved with the getData() method. Arrays of maps representing the instances of related lists, with each array representing a single related list and each element of such an array representing a single row of that related list. These arrays can be retrieved with the getRelatedList() method. Arrays of maps representing the instances of many-to-many tables, with each array representing a single many-to-many table and each element of such an array representing a single row of that many-to-many table. These arrays can be retrieved with the getM2MTable() method. * * Use with any server-side discovery script.
 * 
 * 
 */
declare class CIData {



    /**
     * Creates an instance of the CIData class.
     * 
     * @debugFlag True if debug logging is enabled.
     */
    constructor(debugFlag: String);

    /**
     * Adds the specified related list to this instance.
     * 
     * @relatedList The related list
     */
    addRelatedList(relatedList: Array<any>);

    /**
     * Converts the specified related list to a related list in a given sensor.
     * 
     * @sensor The sensor
     * @tableName The table name
     * @refField The reference field
     * @keyName The key name
     */
    convertRelatedList(sensor: String, tableName: String, refField: String, keyName: String);

    /**
     * Initializes the current CIData instance from the specified XML string.
     * 
     * @xml An XML string
     */
    fromXML(xml: String);

    /**
     * Gets the data map in the base CI record.
     * 
     * @returns The data map
     */
    getData(): Object;

    /**
     * Gets an array of data maps in the given many-to-many list (to this CI).The array is not in any particular order. If this is not a many-to-many list, returns an empty array.
     * 
     * @table The name of the table containing the related list. In the case of a many-to-many list, this is the name of the many-to-many table, not the target table.
     * @refField The name of the field in the related list that refers to this CI. In the case of a many-to-many list, this is the name of the referring field in the many-to-many table, not in the target table.
     * @returns an array of data maps in the given many-to-many list. If this is not a many-to-many list, returns an empty array.
     */
    getM2MTable(table: String, refField: String): Array<any>;

    /**
     * Gets an array of maps of data in the given related list (to this CI).The array is not in any particular order. In the case of a many-to-many list, this will be an array of instances of the target table, not the many-to-many table. For example, given 'cmdb_software_instance' and 'installed_on' (a many-to-many table and the field that refers to a CI), this method will return an array of maps representing cmdb_ci_spkg (the target table) instances.
     * 
     * @table Name of the table containing the related list. In the case of a many-to-many list, this is the name of the many-to-many table, not the target table.
     * @refField Name of the field in the related list that refers to this CI. In the case of a many-to-many list, this is the name of the referring field in the many-to-many table, not in the target table.
     * @returns An array of maps of data in the specified related list.
     */
    getRelatedList(table: String, refField: String): Array<any>;

    /**
     * Returns the instance of CIRelatedList for the given list.
     * 
     * @table Name of the table containing the related list. In the case of a many-to-many list, this is the name of the many-to-many table, not the target table.
     * @refField Name of the field in the related list that refers to this CI. In the case of a many-to-many list, this is the name of the referring field in the many-to-many table, not in the target table.
     * @returns Instance of the CIRelatedList for the specified list.
     */
    getRelatedListInstance(table: String, refField: String): Object;

    /**
     * Initializes this instance in preparation for loading a new CI.
     * 
     * @example
     * var cdta = CIData('false');
     * cdta.init();
     */
    init();

    /**
     * Loads the current data from a specified sys_id.
     * 
     * @cmdb_ci The sys_id of the CI
     * @example
     * var cdta = CIData('false');
     * cdta.init();
     * cdta.loadFromCI('ccaf9c0a8016400b98a06818d57c7');
     * @returns The current data from the specified CI.
     */
    loadFromCI(cmdb_ci: String): Object;

    /**
     * Converts the name of this instance to a string.
     * 
     * @returns Name of the instance
     */
    toString(): String;

    /**
     * Returns an XML string containing a serialized version of this instance (including any related lists).
     * 
     * @example
     * var cdta = CIData();
     * cdta.toXML();
     * @returns The XML string containing a serialized version of this instance and any related lists.
     */
    toXML(): String;

}

/**
 * Main class for discovery CI identification. Use this with any server-side discovery script for CI identification.
 * 
 * 
 */
declare class CIIdentification {



    /**
     * Creates an instance of the CIIdentification class.
     * 
     * @ciData The CI data to identify
     * @logger The discovery logger
     */
    constructor(ciData: String, logger: String);

    /**
     * Logs a message to the CI Identification log if debug logging is turned on.
     * 
     * @msg The message to log
     */
    debug(msg: String);

    /**
     * Identifies the CI. This is the entry point for the entire CI Identification process.
     * 
     * @returns The result returned by the identifier
     */
    process(): IDResult;

}

/**
 * Gets the result returned by an identifier. Use with any server-side discovery script.
 * 
 * 
 */
declare class CIIdentifierResult {



    /**
     * Creates an instance of the CIIdentifierResult class.
     * 
     * @matched An array of sys_ids of matching CIs; may have any number of entries including zero.
     * @matchable True if identifier had sufficient data to match
     * @terminatedChain True if the identifier chain should stop processing filters. False to continue.
     */
    CIIdentifierResult(matched: Array<any>, matchable: Boolean, terminatedChain: Boolean);

}

/**
 * Provides a wrapper for CIM CI data manipulation. Use with any server-side discovery script.
 * 
 * 
 */
declare class CimCIData {



    /**
     * Adds a serial number to the current CI, by type.
     * 
     * @type The serial number type. If out-of-box, use the CimCIData.serialType enum.
     * @serial The serial number
     * @returns The current CI
     */
    addSerial(type: String, serial: String): String;

    /**
     * Creates a new serial record.
     * 
     * @type The serial type to assign to the CI. If out-of-box, uses the CimCIData.serialType enum.
     * @serial The serial number to assign.
     */
    SerialRecord(type: String, serial: String);

    /**
     * Sets the make and model for the current CI.
     * 
     * @make The manufacturer
     * @model The model
     */
    setMakeAndModel(make: String, model: String);

}

/**
 * Performs identification for CIM probe results. Use in any server-side script to perform identification of CIM probe results.
 * 
 * 
 */
declare class CimIDSensor {



    /**
     * Configures a triggered probe before it is launched.
     * 
     * @probe An already configured probe that is ready to fire.
     * @returns True to fire this probe, false to skip it.
     */
    configureTriggeredProbe(probe: String): Boolean;

    /**
     * Gets the instance hash token.
     * 
     * @returns The hash token
     */
    getInstanceHashToken(): String;

    /**
     * Prepares the probe results.
     * 
     */
    prepare();

    /**
     * Processes all CIM probe query results for a CIM ID sensor.
     * 
     * @results The query results
     * @cimData The CI data of the device being identified.
     * @sensor The wrapping sensor, extends CimIDSensor
     */
    process(results: Object, cimData: CimCIData, sensor: CimIDSensor);

    /**
     * Runs a multi-probe script against a probe result.
     * 
     * @script The script
     * @probeResult The probe result
     * @probeRecord The probe ID
     */
    runMultiProbeScript(script: String, probeResult: Object, probeRecord: String);

    /**
     * Updates the device count.
     * 
     */
    updateDeviceCount();

}

/**
 * Represents the unique query identity of a CIM instance. Use with any server-side discovery script.
 * 
 * 
 */
declare class CimInstanceToken {



    /**
     * Parses the instance token.
     * 
     * @cimomip  
     * @returns The hash token
     */
    getHashToken(cimomip: String): String;

    /**
     * Parses the instance token.
     * 
     * @instance The CIM instance
     * @returns The parsed instance token, for example, CIM_ClassName{Key1='Value1',Key2='Value2'}
     */
    parse(instance: XMLObj): String;

}

/**
 * Maintains CIM probe meta data. Use in any server-side script where you need to maintain a CIM probe.
 * 
 * 
 */
declare class CimProbe {



    /**
     * Returns all the named queries for the current CIM probe.
     * 
     */
    getNamedQueries();

    /**
     * Returns all the queries for the current CIM probe.
     * 
     * @returns An array of strings of queries
     */
    getQueries(): Array<any>;

    /**
     * Returns all the records in the CIM Probe table.
     * 
     * @returns The query result
     */
    getQueryRecords(): GlideRecord;

}

/**
 * Processes CIM probe results. Use to process CIM probe results in any server-side discovery script.
 * 
 * 
 */
declare class CimProbeResult {



    /**
     * Gets the named instances for the specified named queries.
     * 
     * @namedQueries The named queries
     * @returns The named instances
     */
    getNamedInstances(namedQueries: String): String;

    /**
     * Gets all the queries for the current CIM probe.
     * 
     * @returns All Queries
     */
    getQueries(): StringArray;

}

/**
 * Utility class for working with CI Related lists. Each instance of this class contains the details of a single list that is related to a particular CI. The details of this list and the contents of the list are included. * * Use with any server-side discovery script.
 * 
 * 
 */
declare class CIRelatedList {



    /**
     * Creates an instance of the CIRelatedList class. With no arguments, simply constructs an empty instance.
     * 
     * @table The table containing the related list. If many-to-many, the many-to-many table.
     * @refField The reference field in the table for this related list.
     * @cmdb_ci The sys_id of the CI this list is related to.
     * @debugFlag If true, debug logging is enabled.
     */
    constructor(table: String, refField: String, cmdb_ci: String, debugFlag: String);

    /**
     * Adds the specified record to the related list.
     * 
     * @record The record to add
     */
    addRec(record: String);

    /**
     * Sets the given records to the related list.
     * 
     * @records The records to set
     */
    addRecs(records: String);

    /**
     * Appends an XML child to a field.
     * 
     * @parent The parent element
     * @name The element name
     * @datum The data to append
     */
    appendXMLChildFld(parent: String, name: String, datum: String);

    /**
     * Appends an XML child to a record.
     * 
     * @parent The parent element
     * @name The element name
     * @record The record
     */
    appendXMLChildRecord(parent: String, name: String, record: String);

    /**
     * Checks to see if this is a SysCollection table. If it is, sets the target table name and reference field name.
     * 
     * @returns An instance of CIRelatedList for the specified list.
     */
    checkSysCollection(): CIRelatedList;

    /**
     * Checks to see if this is a Sys many-to-many table. If it is, sets the target table name and reference field name.
     * 
     * @returns True if it is a sys many-to-many table; otherwise, false.
     */
    checkSysM2M(): Boolean;

    /**
     * Initializes this instance from the specified XML element.
     * 
     * @element An XML element
     */
    fromXML(element: String);

    /**
     * Populates the this.records field of this instance.
     * 
     */
    populate();

    /**
     * Removes all the related list items.
     * 
     */
    remove();

    /**
     * Makes a string representation of this instance, pushing each line onto the end of the given result array.This method is called from CIData.toString(), and assumes related list lines are to be indented two spaces.
     * 
     * @result The result to convert
     */
    toString(result: Array<any>);

    /**
     * Serializes this instance to XML in the given document and element.
     * 
     * @document The document
     * @element The rl element
     */
    toXML(document: String, element: String);

    /**
     * Converts a related list from XML to record format.
     * 
     * @records The record to create
     * @element The XML element
     */
    xmlToRecord(records: String, element: String);

}

/**
 * CIUtils is a utility class for working with configuration items. By default, when traversing CI relationships the system will use a max depth of 10. This can be overridden in the glide.relationship.max_depth property. * * The maximum number of items returns is 1000. This can be overridden in the glide.relationship.threshold property. * * The CIUtils class is available to server-side scripts.
 * 
 * 
 */
declare class CIUtils {



    /**
     * Determine which business services are affected by a specific CI.
     * 
     * @CI_sys_id The sys_id of a configuration item (cmdb_ci)
     * @example
     * var CIUtil = new CIUtils();
     *  
     * //get a server record
     * var server = new GlideRecord("cmdb_ci_server");
     * server.addQuery("name", "lnux100");
     * server.query();
     * if (server.next()) {
     *   //get the affected services, array of ids
     *   var serviceIds = CIUtil.servicesAffectedByCI(server.getUniqueValue());
     *   for (var i=0; i &lt; serviceIds.length; i++) {
     *     //get the service record
     *     var service = new GlideRecord("cmdb_ci_service");
     *     service.get(serviceIds[i]);
     *     gs.print(service.getDisplayValue());
     *   }
     * }
     * @returns An array of sys_id values for cmdb_ci records downstream of (or affected by) the specified item.
     */
    servicesAffectedByCI(CI_sys_id: String): Array<any>;

    /**
     * Determine which business services are affected by a task.
     * 
     * @task A task GlideRecord, for example incident, change_request, problem
     * @example
     * var CIUtil = new CIUtils();
     *  
     * //get an incident record
     * var inc = new GlideRecord("incident");
     * inc.addQuery("number", "INC00050");
     * inc.query();
     * if (inc.next()) {
     *   //get the affected services, array of ids
     *   var serviceIds = CIUtil.servicesAffectedByTask(inc);
     *   for (var i=0; i &lt; serviceIds.length; i++) {
     *     //get the service record
     *     var service = new GlideRecord("cmdb_ci_service");
     *     service.get(serviceIds[i]);
     *     gs.print(service.getDisplayValue());
     *   }
     * }
     * @returns An array of sys_id values for CIs downstream of (or affected by) the configuration item referenced by the task's cmdb_ci field.
     */
    servicesAffectedByTask(task: GlideRecord): Array<any>;

}

/**
 * Provides a classifier probe launch facility. Encapsulates an array of probe information records, initialized either from a JavaScript array or the XML serialized version. Use in any server-side script where you need to define a classifier probe launch facility.
 * 
 * 
 */
declare class ClassifierProbes {



    /**
     * Launches the next highest priority classifier from those in the list.
     * 
     * @returns True if a classifier is launched; otherwise, false.
     */
    launch(): Boolean;

    /**
     * Launches a supplementary probe.
     * 
     */
    launchSupplementary();

    /**
     * Returns the probe length.
     * 
     * @returns The probe length
     */
    size(): Number;

}

/**
 * Use the CMDBDuplicateTaskUtils API to create a De-duplication task that contains duplicate CIs that are of independent type. A de-duplication task can only contain CMDB CIs that are not in another de-duplication task.
 * 
 * 
 */
declare class CMDBDuplicateTaskUtils {



    /**
     * Creates an instance of the CMDBDuplicateTaskUtils class.
     * 
     */
    constructor();

    /**
     * Create a De-duplication task in which the sys_ids of duplicate tasks are specified.
     * 
     * @sysIDs A comma separated list of sys_IDs.
     * @example
     * // where sys-id1 and sys-id2 are sys_IDs of CIs in the cmdb_ci table
     * var sysIDs = 'sys-id1, sys-id2';
     * var dupTaskUtil = new CMDBDuplicateTaskUtils();
     * var deDupTaskID = dupTaskUtil.createDuplicateTask(sysIDs);
     * gs.info(deDupTaskID);
     * @returns The sys_ID of the created task. Returns null if the input string is empty, the input parameter contains a sys_ID that is not in the cmdb_ci table, or the input parameter contains a sys_ID that is in an open de-duplication task.
     */
    createDuplicateTask(sysIDs: String): String;

}

/**
 * The CMDBTransformUtil class uses the Identification and Reconciliation framework to minimize creation of duplicate CIs and to reconcile CI attributes by only accepting information from authorized sources when updating the CMDB in onBefore transform map scripts. This class cannot be used in other scripts. 
 * 
 * 
 */
declare class CMDBTransformUtil {



    /**
     * Creates a CMDBTransformUtil object.
     * 
     * @example
     * var cmdbUtil = new CMDBTransformUtil();
     */
    constructor();

    /**
     * Use this method in onBefore transform map scripts to get the error when the identifyAndReconcile() method was called.
     * 
     * @example
     * // add this code to the onBefore transform map script
     * // Call CMDB API to do Identification and Reconciliation of current row
     * var cmdbUtil = new CMDBTransformUtil();
     * cmdbUtil.setDataSource('ImportSet');
     * cmdbUtil.identifyAndReconcile(source, map, log);
     * ignore = true;
     * 
     * if (cmdbUtil.hasError()) {
     *         var errorMessage = cmdbUtil.getError();
     *         log.error(errorMessage);
     * } else {
     *         log.info('IE Output Payload: ' + cmdbUtil.getOutputPayload());
     *         log.info('Imported CI: ' + cmdbUtil.getOutputRecordSysId());
     * }
     * 
     * @returns The error message from identifyAndReconcile().
     */
    getError(): String;

    /**
     * Use this method in onBefore transform map scripts to get the JSON payload after the identifyAndReconcile() method is called.
     * 
     * @example
     * // add this code to the onBefore transform map script
     * // Call CMDB API to do Identification and Reconciliation of current row
     * var cmdbUtil = new CMDBTransformUtil();
     * cmdbUtil.setDataSource('ImportSet');
     * cmdbUtil.identifyAndReconcile(source, map, log);
     * ignore = true;
     * 
     * if (cmdbUtil.hasError()) {
     *         var errorMessage = cmdbUtil.getError();
     *         log.error(errorMessage);
     * } else {
     *         log.info('IE Output Payload: ' + cmdbUtil.getOutputPayload());
     *         log.info('Imported CI: ' + cmdbUtil.getOutputRecordSysId());
     * }
     * 
     * @returns A JSON formatted string that is a list of results for the configuration items in the input string. Each result string is in the format 'items: [{}], relations:[{}]', where each item within the items and relations lists contains name-value pairs. The possible name-value pairs within the items list are: className- the sys_class_name for the CI that was updated or created. operation, which is one of INSERT, UPDATE, UPDATE_WITH_UPGRADE, UPDATE_WITH_DOWNGRADE, UPDATE_WITH_SWITCH, DELETE, NO_CHANGE sysId - the sys_id of the CI that was updated or created. relatedSysIds - a list of sys_id values of CIs used during lookup based identification. maskedAttributes – a list of attributes whose update by a non-authoritative data source gets skipped as defined by the Reconciliation Rules. identifierEntrySysId - sys_id of identifier entry used during matching. errors - a list of errors in the format of (error, message string), where error can be ABANDONED, INVALID_INPUT_DATA, IDENTIFICATION_RULE_MISSING, IDENTIFICATION_RULE_FOR_LOOKUP_MISSING, NO_LOOKUP_RULES_FOR_DEPENDENT_CI, NO_CLASS_NAME_FOR_INDEPENDENT_CI, MISSING_DEPENDENCY, MULTIPLE_DEPENDENCIES, MULTIPLE_DUPLICATE_RECORDS, RELATION_CHAIN_ENDS_AT_QUALIFIER, QUALIFICATION_LOOP, TYPE_CONFLICT_IN_QUALIFICATION, MULTI_MATCH, REQUIRED_ATTRIBUTE_EMPTY, RECLASSIFICATION_NOT_ALLOWED duplicateIndices - a list of indexes of items that are duplicates of the current item. identificationAttempts - a list of attempts in the format of (attributes, identiferName, attemptResult, searchOnTable) where attributes - the attributes of identifier entry used during identification identiferName - the CI identifier to which this identifier entry belongs attemptResult - one of SKIPPED, NO_MATCH, MATCHED, MULTI_MATCH searchOnTable - the table searched during the identification process. The possible name-value pairs within the relations list are: className - the relationship CI's class name and is always cmdb_rel_ci operation - one of INSERT, UPDATE, NO_CHANGE sysId - the sys_id of the relationship CI inserted or updated 
     */
    getOutputPayload(): String;

    /**
     * Use this method in onBefore transform map scripts to get the sys_id of the CI that was inserted/updated.
     * 
     * @example
     * // add this code to the onBefore transform map script
     * // Call CMDB API to do Identification and Reconciliation of current row
     * var cmdbUtil = new CMDBTransformUtil();
     * cmdbUtil.setDataSource('ImportSet');
     * cmdbUtil.identifyAndReconcile(source, map, log);
     * ignore = true;
     * 
     * if (cmdbUtil.hasError()) {
     *         var errorMessage = cmdbUtil.getError();
     *         log.error(errorMessage);
     * } else {
     *         log.info('IE Output Payload: ' + cmdbUtil.getOutputPayload());
     *         log.info('Imported CI: ' + cmdbUtil.getOutputRecordSysId());
     * }
     * 
     * @returns The sys_id of the CI that was inserted/updated.
     */
    getOutputRecordSysId(): String;

    /**
     * Use this method in onBefore transform map scripts to determine if there was an error when the identifyAndReconcile() method was called.
     * 
     * @example
     * // add this code to the onBefore transform map script
     * // Call CMDB API to do Identification and Reconciliation of current row
     * var cmdbUtil = new CMDBTransformUtil();
     * cmdbUtil.setDataSource('ImportSet');
     * cmdbUtil.identifyAndReconcile(source, map, log);
     * ignore = true;
     * 
     * if (cmdbUtil.hasError()) {
     *         var errorMessage = cmdbUtil.getError();
     *         log.error(errorMessage);
     * } else {
     *         log.info('IE Output Payload: ' + cmdbUtil.getOutputPayload());
     *         log.info('Imported CI: ' + cmdbUtil.getOutputRecordSysId());
     * }
     * 
     * @returns True if the identifyAndReconcile() method had an error.
     */
    hasError(): Boolean;

    /**
     * Use this method in onBefore transform map scripts to insert or update a configuration item to the CDMB. Using this method instead of relying on the transform to insert or update the configuration item record reduces duplicate entries in the CDMB.This method is used in the onBefore script. Set ignore = true to prevent the transform from adding or updating the record a second time.
     * 
     * @source This is the global object available in transform map scripts that holds the incoming record.
     * @map This is the map object available in transform map scripts that holds the current transform map record.
     * @log This is the log object available in transform map scripts.
     * @example
     * // add this code to the onBefore transform map script
     * // Call CMDB API to do Identification and Reconciliation of current row
     * var cmdbUtil = new CMDBTransformUtil();
     * cmdbUtil.identifyAndReconcile(source, map, log);
     * ignore = true;
     */
    identifyAndReconcile (source: Object, map: Object, log: Object);

    /**
     * Use this method in onComplete transform map scripts to log the number of CIs inserted, updated, skipped, or had errors.
     * 
     * @log This is the log object available in transform map scripts.
     */
    logTransformStats(log: Object);

    /**
     * Use this method in onBefore transform map scripts to set the data source to be used when the identifyAndReconcile() method is called. If this method is not called, the default value 'ImportSet' is used.
     * 
     * @source The data source for the source CI record.
     * @example
     * // add this code to the onBefore transform map script
     * // Call CMDB API to do Identification and Reconciliation of current row
     * var cmdbUtil = new CMDBTransformUtil();
     * cmdbUtil.setDataSource('ImportSet');
     * cmdbUtil.identifyAndReconcile(source, map, log);
     * ignore = true;
     * 
     * if (cmdbUtil.hasError()) {
     *         var errorMessage = cmdbUtil.getError();
     *         log.error(errorMessage);
     * } else {
     *         log.info('IE Output Payload: ' + cmdbUtil.getOutputPayload());
     *         log.info('Imported CI: ' + cmdbUtil.getOutputRecordSysId());
     * }
     * 
     */
    setDataSource(source: String);

}

/**
 * The CMDBUtil API provides utility methods for creating and managing table relationships in the configuration management database (CMDB) and managing CMDB baselines. CMDBUtil is a JavaScript-accessible ScriptableObject. The CMDBUtil API has dynamic and static methods. You access dynamic methods by creating a SNC.CMDBUtil object. You access static methods by using SNC.CMDBUtil global object to call the methods. * * This example creates a CMDBUtil object. * * This example calls a static method. * * Use these methods to manage CMDB table relationships and baselines.
 * 
 * 
 */
declare class CMDBUtil {



    /**
     * Applies proposed changes in a task_ci record that represent an update set for all CIs associated with the task.This is a dynamic method.
     * 
     * @proposedChanges The collection of proposed changes in the change request (CHG).
     * @example
     * //Where current is a GlideRecord and action is the current UI action
     * var base = new SNC.CMDBUtil();
     * base.baselineProposedChangesApplyChanges(current);
     */
    baselineProposedChangesApplyChanges(proposedChanges: GlideRecord);

    /**
     * Generates the XML for proposed changes diff, and adds it to the corresponding task_ci record.This is a dynamic method.
     * 
     * @current The GlideRecord that contains the collection of proposed changes.
     * @changeSet The sysid of the task_ci record that represents the change set to use.
     * @example
     * //Where current is a GlideRecord and action is the current UI action
     * var base = new SNC.CMDBUtil();
     * base.baselineProposedChangesGenDIFF(current, action.get('sysparm_changeset'));
     */
    baselineProposedChangesGenDiff(current: GlideRecord, changeSet: String);

    /**
     * Bootstraps the environment by creating the database, creating the system dictionary table, and having the system dictionary table describe itself.This is a static method.
     * 
     * @dictFile The file name including path, of the dictionary to load.
     */
    bootstrap(dictFile: String);

    /**
     * Creates the specified CI relationship using the specified invocation parameters.If called without the first parameter, passing only four parameters, defaults to the CI Relationship [cmdb_rel_ci] table.This is a dynamic method.
     * 
     * @tableName The table name
     * @parentField The parent field
     * @childField The child field
     * @parentDesc The parent relationship descriptor
     * @childDesc The child relationship descriptor
     */
    createCIRelationship(tableName: String, parentField: String, childField: String, parentDesc: String, childDesc: Object);

    /**
     * Gets all the child tables of the specified table as a comma-separated list.This is a static method.
     * 
     * @baseTable The base table name.
     * @example
     * //Where cmdv_ci_computer is a table.
     * var output = SNC.CMDBUtil.getAllChildrenOfAsCommaList('cmdb_ci_computer');
     * gs.print(output);
     * @returns A comma-separated list of sys_ids of tables extending the base table.
     */
    getAllChildrenOfAsCommaList(baseTable: String): String;

    /**
     * Gets all the records in the CMDB View [cmdb_view] table.This is a dynamic method.
     * 
     * @returns The records in the CMDB view table.
     */
    getCMDBViews(): ArrayList;

    /**
     * Gets a list of all the parents of a table.This is a static method.
     * 
     * @tableName The table name
     * @returns List of tables that are parents of the specified table.
     */
    getTables(tableName: String): ArrayList;

    /**
     * Determines whether a CI class is defined in the Business Rule Exclusion Lists [cmdb_business_rule_exclusions] table. Use this method in an advanced condition to prevent a business rule from executing on excluded CI classes.For example, the Create Asset on insert business rule uses this method in the advanced condition to prevent the rule from creating assets for CI classes such as cmdb_ci_qualifier, cmdb_ci_endpoint, cmdb_ci_storage_volume, and cmdb_ci_vcenter_datastore_disk. Define classes for exclusion in the Business Rule Exclusion Lists [cmdb_business_rule_exclusions] table.
     * 
     * @className Name of the class to check for exclusion.
     * @example
     * //Returns true if the cmdb_ci_endpoint class is defined 
     * //in the Business Rule Exclusion Lists table
     * var exclusion = SNC.CMDBUtil.isExcludedFromBR("cmdb_ci_endpoint");
     * 
     * //Advanced condition that prevents business rules from executing on 
     * //classes in the Business Rule Exclusion Lists table
     * (!SNC.CMDBUtil.isExcludedFromBR(current.getTableName()))
     * @returns True if the class is defined in the Business Rule Exclusion Lists [cmdb_business_rule_exclusions] table; otherwise, false.
     */
    isExcludedFromBR(className: String): Boolean;

    /**
     * Wraps the call to RelationshipEventProcessor(), which processes any changes to CI relationships.This is a dynamic method.
     * 
     * @event The event record.
     * @target The target record.
     */
    processCIChange(event: GlideRecord, target: GlideRecord);

    /**
     * Wraps the call to RelationshipEventProcessor(), which processes any changes to CI relationships, with the specified type and triplet.This is a dynamic method.
     * 
     * @event The event record
     * @current The current record, which is either the relation record or a user record if the current process is a deletion.
     * @relType The type of relation that changed.
     * @triplet The child, parent, and class name from the relation that changed.
     */
    processRelChange(event: GlideRecord, current: GlideRecord, relType: String, triplet: String);

    /**
     * Deletes the specified CI relationship.If called without the first parameter, passing only four parameters, defaults to the CI Relationship [cmdb_rel_ci] table.This is a dynamic method.
     * 
     * @tableName The table name
     * @parentField The parent field
     * @childField The child field
     * @parentDesc The parent relationship descriptor
     * @childDesc The child relationship descriptor
     */
    removeCIRelationship(tableName: String, parentField: String, childField: String, parentDesc: String, childDesc: Object);

    /**
     * Changes the parent of the given table to the new parent.This is a static method.
     * 
     * @table The table to re-parent
     * @oldParent The old parent
     * @newParent The new parent
     * @returns True, if successful; otherwise, false.
     */
    reParentTable(table: String, oldParent: String, newParent: String): Boolean;

}

/**
 * The ConnectActionResponse API provides a method to create a GlideRecord. ConnectActionResponse methods are accessed through a global object (response) that is available only in Connect action scripts.
 * 
 * 
 */
declare class ConnectActionResponse {



    /**
     * Create a GlideRecord in the specified table with the specified values.Opens a form in the UI based upon the table, which replaces the Table and Document fields in the Live Group Profile record for the associated conversation.
     * 
     * @table Name of the table where the record is to be added.
     * @values An object of name value pairs where the names are field names in the table and the values are the field values.
     * @view The form view to load. This parameter is optional.
     * @example
     * response.newRecord("incident", {
     * 	short_description: conversation.document.short_description || "",
     * 	caller_id: conversation.document.opened_by
     * });
     */
    newRecord(table: String, values: Object, view: String);

}

/**
 * Implements a general-purpose criteria evaluator. The general use pattern is to construct the class, add as many criteria as needed, then evaluate.
 * 
 * 
 */
declare class CriteriaEvaluator {



    /**
     * Adds the criteria to be evaluated.
     * 
     * @lhComparand The left hand comparand. Must be a named value in the left hand values input into evaluate().
     * @operator The operator. Must be one of: equals, starts with, contains, does not contain, ends with, or regex matches.
     * @rhComparand The right hand comparand. Can be evaluated either as one of the right hand values input to evaluate() or as a literal string.
     */
    addCriterion(lhComparand: String, operator: String, rhComparand: String);

    /**
     * Evaluates the criteria.
     * 
     * @lhValues A hashmap of name-value pairs to evaluate the left hand comparands of the criteria.
     * @rhValues Optional right hand values to use instead of the literal value in evaluating the right hand comparands.
     * @any If true, any criterion matching suffices for a true result. If false, all criteria must match for a true result.
     * @returns True if the supplied values satisfy the criteria, false otherwise.
     */
    evaluate(lhValues: Object, rhValues: String, any: Boolean): Boolean;

}

/**
 * DateTimeUtils class is a collection of date/time functions. The DateTimeUtils class is provided via the Script Include DateTimeUtils. * * The DateTimeUtils class can be used in any server-side script, and is available through GlideAjax.
 * 
 * 
 */
declare class DateTimeUtils {



    /**
     * Converts Microsoft AD integer8 DateTime format into GlideDateTime format.Integer8 is also known as Microsoft Filetime format. This method is commonly used when importing AD user's date fields, such as Expiration Date.
     * 
     * @int64 A 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC).
     * @example
     * //convert and set account expiration date from AD
     * //this is an example that could be used in an LDAP import transform map to import the LDAP account 
     * //expires attribute to a customer created u_account_expires GlideDateTime field
     * var dtUtil = new DateTimeUtils();
     * target.u_account_expires = dtUtil.int8ToGlideDateTime(source.u_accountexpires);
     * @returns A GlideDateTime object set to the Integer8 date and time.
     */
    int8ToGlideDateTime(int64: Number): GlideDateTime;

    /**
     * Convert milliseconds to a GlideDateTime object
     * 
     * @milliseconds The number of milliseconds
     * @example
     * //example script to call the method from a client
     * Replace MILLISECONDSVALUE with your variable
     * var ga = new GlideAjax('DateTimeUtils');
     * ga.addParam('sysparm_name','msToGlideDateTime');
     * ga.addParam('sysparm_value', MILLISECONDSVALUE);
     * ga.getXMLWait();
     * var newGDT = ga.getAnswer();
     * @returns A GlideDateTime object
     */
    msToGlideDateTime(milliseconds: Number): GlideDateTime;

}

/**
 * Provides a set of miscellaneous functions used in discovery. Use methods to perform discovery functions, such as check for valid IP ranges, start and complete the discovery process, or send a warning message.
 * 
 * 
 */
declare class Discovery {



    /**
     * Creates an instance of the Discovery class.
     * 
     */
    constructor();

    /**
     * Called when the completed business rule is called because the discovery_status started has completed.
     * 
     */
    completed();

    /**
     * Starts a discovery of the CI with the given sysID, returning the sysID of the status record.
     * 
     * @cmdb_ci The sys_id of the CI to be discovered.
     * @example
     * var dj = new Discovery();
     * dj.discoveryFromCI('09dad0830a0a0f2500152f56b1adb0ab')
     * @returns The sysID of the status record found or created, or null if the CI could not be discovered.
     */
    discoveryFromCI(cmdb_ci: String): String;

    /**
     * Starts the current discovery job.
     * 
     * @example
     * var dj = new Discovery();
     * dj.discoveryStartJob();
     */
    discoveryStartJob();

    /**
     * Gets an array of IP addresses in the CI with a given sysID.
     * 
     * @ci_sysID The sys_id for the CI to look for
     * @example
     * var dj = new Discovery();
     * dj.getIPsInCI('09dad0830a0a0f2500152f56b1adb0ab');
     * @returns An array of IP addresses in the CI with the specified sys_id, or null if the CI doesn't exist.
     */
    getIPsinCI(ci_sysID: String): Array<any>;

    /**
     * Gets the DiscoverySchedule instance for any IP address in a given array and the IP address to be discovered.
     * 
     * @ips An array of IP addresses
     * @example
     * var dj = new Discovery();
     * var dinst = ['100.100.98.10', '100.100.98.9'];
     * dj.getScheduleContainingAnyIP(dinst);
     * @returns An object with two properties: "schedule" that has a DiscoverySchedule instance for a schedule that contains any IP address in the given array, and "ip" that has the IP address to be discovered. Returns null if no such schedule could be found for any IP.
     */
    getScheduleContainingAnyIP(ips: Array<any>): Object;

    /**
     * Determines if the current discovery schedule is valid.
     * 
     * @schedule The sys_id of the schedule to check.
     * @example
     * var dj = new Discovery();
     * dj.isValidDiscoverySchedule('08fcd0830a0a0b2600079f56b1adb9ae');
     * @returns True if the schedule is valid; otherwise, false.
     */
    isValidDiscoverySchedule(schedule: String): Boolean;

    /**
     * Determines if the IP range for the specified discovery schedule is valid.
     * 
     * @schedule The sys_id of the schedule to check
     * @example
     * var dj = new Discovery();
     * dj.isValidRange('08fcd0830a0a0b2600079f56b1adb9ae');
     * @returns True, if the range is valid; otherwise, false.
     */
    isValidRange(schedule: String): Boolean;

    /**
     * Logs a warning message.
     * 
     * @message The warning message
     * @example
     * var dj = new Discovery();
     * dj.warnMsg('This is a warning message');
     */
    warnMsg(message: String);

}

/**
 * Provides client-callable Ajax functions for Discovery. Use this script include in any server-side Discovery script to get device IP addresses or status, or set device status to ready from the client.
 * 
 * 
 */
declare class DiscoveryAjax {



    /**
     * Retrieves the number of records in the ECC queue, and the maximum entries.
     * 
     * @example
     * var da = new DiscoveryAjax();
     * gs.print(da.ajaxFunction_countECCRecords());
     * @returns The number of records in the queue followed by the maximum number of entries.
     */
    ajaxFunction_countECCRecords(): String;

    /**
     * Gets the IP address for the next device that is ready for discovery.
     * 
     * @example
     * var da = new DiscoveryAjax();
     * gs.print(da.ajaxFunction_discoverIP());
     * @returns The IP address of the device. If no device is ready, returns false.
     */
    ajaxFunction_discoverIP(): GlideRecord;

    /**
     * Gets the Discovery status of a device that has started and is active.
     * 
     * @example
     * var da = new DiscoveryAjax();
     * gs.print(da.ajaxFunction_discoverStatus());
     * @returns The discovery status ID
     */
    ajaxFunction_discoverStatus(): String;

    /**
     * Gets the sys_id for the current Discovery CI.
     * 
     * @example
     * var da = new DiscoveryAjax();
     * var id = da.ajaxFunction_getSysID();
     * @returns The sys_id
     */
    ajaxFunction_getSysID(): String;

    /**
     * Sets the status of all processed devices to ready.
     * 
     * @example
     * var da = new DiscoveryAjax();
     * da.ajaxFunction_setAllToReady();
     */
    ajaxFunction_setAllToReady();

}

/**
 * Processes the application discovery environment file. Use with any server-side discovery script where you need to process the application discovery environment file.
 * 
 * 
 */
declare class DiscoveryAPDEnvSensor {



    /**
     * Starts processing the application discovery environment file.
     * 
     * @result Te discovery result file
     */
    start(result: Object);

}

/**
 * The abstract sensor for parsing application files. Extend this class to parse application files.
 * 
 * 
 */
declare class DiscoveryAPDSensor {



    /**
     * Determines if the application file has valid content.
     * 
     * @result The application file
     * @returns True if the file contains valid content; otherwise, false.
     */
    hasValidContent(result: Object): Boolean;

    /**
     * Processes a custom application.
     * 
     * @dcaGR The application record
     * @versionResult The application version
     * @envResult The environment file
     */
    processCustom(dcaGR: GlideRecord, versionResult: String, envResult: Object);

    /**
     * Processes a part of the service provided by the current application.
     * 
     */
    processPartOfService();

    /**
     * Processes the result. UNIX-based results must be converted to a JavaScript object.
     * 
     * @result The application file
     * @returns The processed result
     */
    processResult(result: Object): Object;

    /**
     * Processes the services the current application consumes from other applications.
     * 
     */
    processServicesConsumed();

    /**
     * Processes the services provided by the current application.
     * 
     */
    processServicesProvided();

}

/**
 * Processes the application discovery version file. Use in any server-side discovery script where you need to process the application discovery version file.
 * 
 * 
 */
declare class DiscoveryAPDVersionSensor {



    /**
     * Finds the record for the specified application or, if not found, creates one.
     * 
     * @dcaGR The application classification
     * @returns The application
     */
    findOrCreateApplication(dcaGR: GlideRecord): GlideRecord;

    /**
     * Processes the application.
     * 
     */
    processApplication();

    /**
     * Creates an application-to-system relation.
     * 
     * @dcaGR The application record
     */
    processAppToSystemRelation(dcaGR: GlideRecord);

    /**
     * Processes the environment.
     * 
     * @returns The environment
     */
    processEnv(): GlideRecord;

    /**
     * Processes the XML files.
     * 
     */
    processXML();

    /**
     * Starts processing the application discovery version file.
     * 
     * @result The application file
     */
    start(result: Object);

}

/**
 * Determines how to match an application during application classification. Use in a discovery script to classify an application.
 * 
 * 
 */
declare class DiscoveryApplicationDiscoMatcher {



    /**
     * Determines if this is a new CI.
     * 
     * @returns True if new; otherwise, false.
     */
    isNewCI(): Boolean;

    /**
     * Attempts to match with an application. If no match is found, creates a new application entry.
     * 
     * @returns The matching application if found; otherwise, a new application entry.
     */
    match(): GlideRecord;

}

/**
 * Implements methods related to attachments used in Discovery. Use this API in any server-side Discovery script to delete Discovery attachments.
 * 
 * 
 */
declare class DiscoveryAttachments {



    /**
     * Deletes the attachments for the current Discovery record.
     * 
     */
    deleteAttachments();

}

/**
 * Provides a set of functions used in Discovery behavior and functionality. Use with any sever-side Discovery script.
 * 
 * 
 */
declare class DiscoveryBehavior {



    /**
     * Creates an instance of the DiscoveryBehavior class..
     * 
     */
    constructor();

    /**
     * Starts the basic functionality probe for the specified MID server.
     * 
     * @defaultMID The MID server
     * @example
     * var disb = new DiscoveryBehavior();
     * disb.fireBasicFunctionality("sandb01-358");
     */
    fireBasicFunctionality(defaultMID: String);

    /**
     * Starts the behavior functionality probe and logs the event.
     * 
     * @example
     * var disb = new DiscoveryBehavior();
     * disb.fireBehaviorFunctionality();
     */
    fireBehaviorFunctionality();

    /**
     * Starts the first Discovery execution phase for the specified MID server.
     * 
     * @defaultMID The MID server
     * @example
     * var disb = new DiscoveryBehavior();
     * disb.fireFirstPhase("sandb01-358");
     */
    fireFirstPhase(defaultMID: String);

    /**
     * Starts the next Discovery execution phase.
     * 
     * @example
     * var disb = new DiscoveryBehavior();
     * disb.fireFirstPhase('sandb01-358');
     * disb.fireNextPhase();
     */
    fireNextPhase();

    /**
     * Gets an array of hashmaps of the discovery_functionality table with all the instances in the next phase, and updates the scratchpad.last_phase entry.
     * 
     * @returns An array of hashmaps of the discovery_functionality table with all instances in the next phase.
     */
    getFunctionality(): Array<any>;

    /**
     * Retrieves the current Discovery Behavior ID.
     * 
     * @returns The Discovery Behavior ID
     */
    getId(): String;

    /**
     * Gets the MID server Windows domain for the specified Discovery function.
     * 
     * @dis_Function The discovery function
     * @returns The Windows domain
     */
    getMidWinDomain(dis_Function: String): GlideRecord;

    /**
     * Determines if the current device has unscanned ports.
     * 
     * @returns True if there are unscanned ports; otherwise, false.
     */
    haveUnscannedPorts(): Boolean;

    /**
     * Determines if the current device ID is valid.
     * 
     * @returns True if the current device ID is valid; otherwise, false.
     */
    isValid(): Boolean;

    /**
     * Determines if there are functionality criteria for the given discovery_functionality record.
     * 
     * @dis_function The discovery function
     * @returns True if there are no functionality criteria for the given discovery_functionality record, or there is criteria and it meets the criteria; false, if there is criteria but it does not meet the criteria
     */
    meetsCriteria(dis_function: String): Boolean;

    /**
     * Coverts a string to lowercase.
     * 
     * @str The string to convert
     * @example
     * var discb = new DiscoveryBehavior();
     * discb.safeLower("String with UPPERCASE letters");
     * @returns The string converted to lower case. Returns an empty string if the parameter is not a string.
     */
    safeLower(str: String): String;

    /**
     * Starts a Discovery scan for the specified MID server and ports.
     * 
     * @mid The name of the MID server
     * @ports The ports to scan
     */
    triggerPortScanner(mid: String, ports: String);

}

/**
 * Encapsulates a discovery behavior. Use with any server-side discovery script.
 * 
 * 
 */
declare class DiscoveryBehaviorRecord {



    /**
     * Creates an instance of the DiscoveryBehaviorRecord class.
     * 
     * @source Must be a MIDServer instance, a GlideRecord for a behavior, or a string sysID of a behavior record. If the source is a MIDServer instance, then a simple synthetic behavior is created, with the "All" Discovery Functionality and the given MIDServer. If the source is a sysID or a GlideRecord, the behavior is loaded from the database.
     * @discover  
     */
    constructor(source: Object, discover: String);

    /**
     * Starts the first discovery execution phase for the specified MID server.
     * 
     */
    firstPhase();

    /**
     * Returns the functionality for this phase.
     * 
     * @phase The phase
     * @returns The functionality for the phase.
     */
    getPhase(phase: String): String;

    /**
     * Gets the port probes for the specified stage and status.
     * 
     * @phase The current probe phase
     * @status The current probe status
     * @returns Each object has these properties: midServer: the MIDServer instance for which services exist portProbes: a hashmap of DiscoveryPortProbe instances (by name) needed for this MID server 
     */
    getPortProbesForPhase(phase: String, status: String): Anarrayofobjects;

    /**
     * Gets a hashmap of information from this behavior if we can find a port probe that probes the given service name and for which the functionality criteria are met with the given left-hand values and right-hand values. Returns null if no such port probe exists.
     * 
     * @result The ShazzamResult instance for the device being processed.
     * @scanner The ShazzamScanner instance for the scanner being processed.
     * @phase The current phase of the behavior.
     * @midServer The MIDserver instance for the MID server whose Shazzam results are being processed.
     * @status The DiscoveryStatus instance for the current discover.
     * @returns A hashmap with these properties, or null if none. behavior: the DiscoveryBehaviorRecord instance containing the service found functionality: the DiscoveryFunctionality instance containing the service found functionalityDefinition: the DiscoveryFunctionalityDefinition instance containing the service found portProbe: the DiscoveryPortProbe instance containing the service found service: the IPService instance found 
     */
    getStuffForResult(result: String, scanner: String, phase: String, midServer: String, status: String): Object;

    /**
     * Starts the next discovery execution phase.
     * 
     * @prevPhase The last completed execution phase.
     */
    nextPhase(prevPhase: String);

}

/**
 * Reconciles records that are related by CI relations. Use with any server-side discovery script.
 * 
 * 
 */
declare class DiscoveryCIRelationReconciler {



    /**
     * Creates an instance of the DiscoveryCIRelationReconciler class.
     * 
     * @fromID The sys_id of the parent CI to be related from.
     * @nature The relationship type descriptor
     * @toTable The table of CIs to be related
     * @ciData An array of CIs to create or update and relate to
     * @keys Fields that make up a unique identity when related to the from CI
     * @retireMissing If true, CIs of the same type that are related, but do not match the CIs specified, will be marked absent.
     * @reason The reason for needing reconciliation.
     */
    constructor(fromID: String, nature: String, toTable: String, ciData: Array<any>, keys: String, retireMissing: Boolean, reason: String);

    /**
     * Inserts and updates all the provided CIs, updating the original CI object with the appropriate IDs, then scans all relationships of the same type and class name from the origin for CIs that are not in the current list and retires those missing CIs.
     * 
     * @returns The matching application if found, or the new application entry if not found.
     */
    reconcile(): GlideRecord;

}

/**
 * Provides a mechanism for re-wiring classified process associations to their cluster rather than a cluster node. Use this API in a discovery script when you need to classify processes.
 * 
 * 
 */
declare class DiscoveryClusteredProcessHelper {



    /**
     * Returns all classified processes that have a "Runs on::Runs" relationship with the given child.
     * 
     * @returns The classified processes
     */
    getClassifiedProcesses(): GlideRecord;

    /**
     * Returns the first valid cluster where the current CI is a node.
     * 
     * @returns The first valid cluster where this CI is a node.
     */
    getCluster(): GlideRecord;

    /**
     * Returns a classified process that already exists on the cluster.
     * 
     * @procName The process to get
     * @returns The process record
     */
    getExistingProc(procName: String): GlideRecord;

    /**
     * Determines which classified processes support clustering, by creating a array of supported processes.
     * 
     */
    getSupportedProcs();

    /**
     * Checks if the specified process is a cluster resource.
     * 
     * @process The process to check
     * @returns True if the process is cluster resource; otherwise, false.
     */
    isClusterResource(process: Object): Boolean;

    /**
     * Determines if the specified process is listening on all TCP connections.
     * 
     * @pid The process identifier of the process to check
     * @returns True if listening on all connections; otherwise, false.
     */
    isListeningOnAll(pid: String): Boolean;

    /**
     * Builds up TCP half connections for clustered processes that are listening on * (enumerate over cluster IPs in addition to the CI IPs that are already there).
     * 
     * @deviceGR The device record
     */
    layer7Connections(deviceGR: GlideRecord);

    /**
     * If the current device is a member of a cluster, processes classified processes that can be clustered.
     * 
     * @deviceGR The record of the device to process.
     */
    process(deviceGR: GlideRecord);

    /**
     * Processes any existing classified processes associated with the cluster, and newly discovered classified processes from one of the cluster nodes.
     * 
     */
    processClusteredProcs();

    /**
     * Rewrites the "@host" portion of an existing cluster process name if a node has overwritten it.
     * 
     * @classyProc The cluster process name.
     */
    processExisting(classyProc: Object);

    /**
     * Processes a new classified process.
     * 
     * @classyProc The classification process
     */
    processNew(classyProc: Object);

    /**
     * Removes the relationship between the classified process and the cluster node.
     * 
     * @process The classified process
     */
    removeNodeRelationship(process: Object);

}

/**
 * Creates range sets from IP networks, transforms the results of a network discovery into range sets that may be incorporated into discovery schedules. Use with any server-side discovery script.
 * 
 * 
 */
declare class DiscoveryCreateRangeSets {



    /**
     * Creates an instance of the DiscoveryCreateRangeSets class.
     * 
     * @statusID The status ID
     * @example
     * var disccr = new DiscoveryCreateRangeSets("0010100101");
     */
    constructor(statusID: String);

    /**
     * Increments the number of sensor records that were processed by one.
     * 
     * @example
     * var disccr = new DiscoveryCreateRangeSets("0010100101");
     * disccr.bumpStatusCompleted();
     */
    bumpStatusCompleted();

    /**
     * Creates a range item.
     * 
     * @subnet The subnet range
     */
    createRangeItem(subnet: String);

    /**
     * Ensures a range is set for a specified router.
     * 
     * @routerID The router ID
     */
    ensureRangeSet(routerID: String);

    /**
     * Processes the specified network.
     * 
     * @netGR The network to process
     */
    processNetwork(netGR: GlideRecord);

    /**
     * Processes all of the current networks.
     * 
     * @example
     * var disccr = new DiscoveryCreateRangeSets("0010100101");
     * disccr.processNetworks();
     */
    processNetworks();

    /**
     * Ensures that an item exists in a specified subnet.
     * 
     * @subnet The subnet range
     */
    rangeItemExists(subnet: String);

    /**
     * Updates the number of probe messages sent to by the specified number.
     * 
     * @startCount The number to increment
     * @example
     * var disccr = new DiscoveryCreateRangeSets("0010100101");
     * disccr.updateStatusStarted('10');
     */
    updateStatusStarted(startCount: Number);

}

/**
 * Encapsulates a discovery functionality record Use with any server-side discovery script.
 * 
 * 
 */
declare class DiscoveryFunctionality {

    /** The active flag. */
    active: String
    /** An instance of DiscoveryBehavior associated with this instance. */
    behavior: DiscoveryBehavior
    /** A JavaScript array of DiscoveryFunctionalityCriterion instances associated with this
    instance. */
    criteria: Array<any>
    /** An instance of DiscoveryFunctionalityDefinition associated with this
    instance. */
    functionality: DiscoveryFunctionalityDefinition
    /** The match criteria for this functionality. */
    matchCriteria: String
    /** The first instance of MIDServer associated with this instance. */
    midServer: MIDServer
    /** A JavaScript array of MIDServer instances associated with this instance. */
    midServers: Array<any>
    /** The phase number of this instance. */
    phase: Number
    /** The sys_id of the discovery status record. */
    sysID: String


    /**
     * Creates an instance of the DiscoveryFunctionality class..
     * 
     * @source Must be either a GlideRecord or a sysID.
     * @behavior Optional - used to resolve the behaviour reference if its sysID matches the reference.
     */
    constructor(source: Object, behavior: String);

    /**
     * Evaluates the criteria in this functionality using the provided left-hand and right-hand values.
     * 
     * @lhValue A hashmap of left-hand criteria values.
     * @rhValue A hashmap of right-hand criteria values.
     * @returns True if the criteria are met.
     */
    evaluateCriteria(lhValue: Object, rhValue: Object): Boolean;

    /**
     * Gets a JavaScript array of DiscoveryFunctionality instances related to the specified behavior.
     * 
     * @behavior A DiscoveryBehaviorRecord instance
     * @returns A JavaScript array of DiscoveryFunctionality instances.
     */
    getForBehavior(behavior: GlideRecord): Array<any>;

    /**
     * Retrieves a hashmap of information from the current functionality if a port probe that probes the given service name can be found and for which the functionality criteria are met with the given left-hand values and right-hand values. Returns null if no such port probe exists.
     * 
     * @name Name of the service for which a port probe is desired
     * @lhCriteria A hashmap of left-hand criteria values, for example "win_domain"="service-now.com"
     * @rhCriteria A hashmap of right-hand criteria values, for example "mid_win_domain"="bogus.com"
     * @returns A hashmap with these properties, or null if none. behavior: the DiscoveryBehaviorRecord instance containing the service found functionality: the DiscoveryFunctionality instance containing the service found functionalityDefinition: the DiscoveryFunctionalityDefinition instance containing the service found portProbe: the DiscoveryPortProbe instance containing the service found service: the IPService instance found 
     */
    getStuffForServiceName(name: String, lhCriteria: Object, rhCriteria: Object): Object;

    /**
     * Retrieves a JavaScript array of one synthetic DiscoveryFunctionality instance, for the given MID server.
     * 
     * @midServer A MidServer instance
     * @discover What kind of discovery, 'IPs', 'CIs', or 'Nets'
     * @returns A JavaScript array of DiscoveryFunctionality instances.
     */
    getSyntheticBasic(midServer: String, discover: String): Array<any>;

}

/**
 * Encapsulates a Discovery functionality criterion. Use with any server-side discovery script to get instances associated with s specific functionality.
 * 
 * 
 */
declare class DiscoveryFunctionalityCriterion {



    /**
     * Creates an instance of the DiscoveryFunctionalityCriterion class.
     * 
     * @source Must be either a GlideRecord instance or a sysID string.
     * @functionality Optional used to resolve the functionality reference if its sysID matches the reference.
     */
    constructor(source: Object, functionality: String);

    /**
     * Retrieves an array of DiscoveryFunctionalityCriterion instances associated with the given functionality.
     * 
     * @functionality The functionality
     * @returns An array of DiscoveryFunctionalityCriterion instances with the specified functionality.
     */
    getForFunctionality(functionality: String): Array<any>;

}

/**
 * Encapsulates ta Discovery functionality definition. Use with any sever-side discovery script to define discovery functionality.
 * 
 * 
 */
declare class DiscoveryFunctionalityDefinition {



    /**
     * Creates an instance of the DiscoveryFunctionalityDefinition class.
     * 
     * @source Either a GlideRecord or sysID string for a discovery functionality.
     */
    constructor(source: Object);

    /**
     * Gets an array of DiscoveryFunctionalityCriterion instances associated with the given functionality.
     * 
     * @example
     * var dfd = new DiscoveryFunctionalityDefinition('b43214af1293412acaafaaa12cfff4');
     * dfd.getAll();
     * @returns An array of DiscoveryFunctionalityCriterion instances associated with the functionality.
     */
    getAll(): Array<any>;

    /**
     * Gets the specified DiscoveryFunctionalityCriterion instance.
     * 
     * @name The name of the DiscoveryFunctionalityCriterion
     * @example
     * var dfd = new DiscoveryFunctionalityDefinition('b43214af1293412acaafaaa12cfff4');
     * dfd.getNamed('Southwest-SNMP');
     * @returns An instance of the specified DiscoveryFunctionalityCriterion.
     */
    getNamed(name: String): DiscoveryFunctionalityCriterion;

    /**
     * Checks if the trigger type is Run Once, i.e., at one specific date and time.
     * 
     * @example
     * var dfd = new DiscoveryFunctionalityDefinition('b43214af1293412acaafaaa12cfff4');
     * var trigtype = dfd.isRunOnce();
     * @returns True if the trigger type is Run Once; otherwise, false.
     */
    isRunOnce(): Boolean;

}

/**
 * A set of functions used in Discovery. 
 * 
 * 
 */
declare class DiscoveryFunctions {



    /**
     * Creates a relationship between two virtual machines.
     * 
     * @parent The parent virtual machine.
     * @child The child virtual machine
     * @pDescription A description of the parent virtual machine
     * @cDescription A description of the child virtual machine
     * @returns The sys_id of the relationship
     */
    createRelationship(parent: GlideRecord,orthesys_id(String), child: GlideRecord,orthesys_id(String), pDescription: String, cDescription: String): String;

    /**
     * Creates a relationship between the specified parent and child if none already exists.
     * 
     * @parent The parent virtual machine
     * @child The child virtual machine
     * @descriptor The relationship descriptor
     * @returns The sys_id of the relationship if found or created; otherwise, returns null or undefined.
     */
    createRelationshipIfNotExists(parent: GlideRecord, child: GlideRecord, descriptor: String): String;

    /**
     * Deletes a virtual machine by record (cmdb_ci_computer) and workflow application (cmdb_ci_appl).
     * 
     * @gr The cmdb_ci_computer for the virtual machine
     * @workflow The workflow application cmdb_ci_appl
     */
    deleteCI(gr: GlideRecord, workflow: GlideRecord);

    /**
     * Deletes virtual machines by traversing through the relationship tree.Traverses through the relationships that have RUNS_ON and HOSTED_ON relationships, looking for all the parent CIs that run on or are hosted on the child CI(s) and deletes them.
     * 
     * @appList The application list
     */
    deleteCIAndRelationshipsRecursive(appList: String);

    /**
     * Deletes a virtual machine by its sys_id.
     * 
     * @sysId The sys_id of the virtual machine to delete.
     * @workflow The workflow of the virtual machine
     */
    deleteCIBySysId(sysId: String, workflow: GlideRecord);

    /**
     * Finds the relationship type for the current VM given its reference table and descriptor.
     * 
     * @refTable The reference table
     * @descriptor The relationship descriptor
     * @returns The relationship type
     */
    findCIRelationshipType(refTable: String, descriptor: String): String;

    /**
     * Finds the relationship type for the current virtual machine given its parent and child descriptors.
     * 
     * @refTable The reference table
     * @pDesc The parent descriptor
     * @cDesc The child descriptor
     * @returns The relationship type
     */
    findCIRelationshipTypeByDesc(refTable: String, pDesc: String, cDesc: String): String;

    /**
     * Finds the node value with a specified attribute.
     * 
     * @node The current node
     * @attrName The attribute for which to search
     * @example
     * Example payload:
     * &lt;results probe_time="6313"&gt;
     *   &lt;result&gt;
     *     &lt;Registry&gt;
     *        &lt;entry key="HKEY_LOCAL_MACHINE"&gt;
     *           &lt;entry key="Software"&gt;
     *              &lt;entry key="Microsoft"&gt;
     *                 &lt;entry key="Windows"&gt;
     *                     &lt;entry key="Name"&gt;
     *                         &lt;value&gt;Just a name&lt;/value&gt;
     *                      &lt;/entry&gt;
     *                   &lt;/entry&gt;
     *                &lt;/entry&gt;
     *             &lt;/entry&gt;
     *          &lt;/entry&gt;
     *       &lt;/Registry&gt;
     *     &lt;/entry&gt;
     * &lt;/results&gt;
     *  
     *  // To find the value of the key called "name", here's how these methods can be used.
     *  // registry is a variable representing the payload
     *  var node = findRegistryNode(registry, "HKEY_LOCAL_MACHINE.Software.Microsoft");
     *  var name = findNodeValueWithAttribute(node, "Name");
     * @returns The node array, if found; otherwise, returns null.
     */
    findNodeValueWithAttribute(node: Object, attrName: String): Object;

    /**
     * Brief description of the method.
     * 
     * @currNode The current node
     * @attrName The attribute name
     * @returns The node array, if found; otherwise, returns null.
     */
    findNodeWithAttribute(currNode: Object, attrName: String): Object;

    /**
     * Finds the registry node for a given registry item.
     * 
     * @currNode The current node
     * @regName The registry name
     * @example
     * Example payload:
     * &lt;results probe_time="6313"&gt;
     *   &lt;result&gt;
     *     &lt;Registry&gt;
     *        &lt;entry key="HKEY_LOCAL_MACHINE"&gt;
     *           &lt;entry key="Software"&gt;
     *              &lt;entry key="Microsoft"&gt;
     *                 &lt;entry key="Windows"&gt;
     *                     &lt;entry key="Name"&gt;
     *                         &lt;value&gt;Just a name&lt;/value&gt;
     *                      &lt;/entry&gt;
     *                   &lt;/entry&gt;
     *                &lt;/entry&gt;
     *             &lt;/entry&gt;
     *          &lt;/entry&gt;
     *       &lt;/Registry&gt;
     *     &lt;/entry&gt;
     * &lt;/results&gt;
     *  
     *  // registry is a variable representing the payload
     *  var node = findRegistryNode(registry, "HKEY_LOCAL_MACHINE.Software.Microsoft");
     * @returns The node if found, otherwise null.
     */
    findRegistryNode(currNode: String, regName: String): Node;

    /**
     * Gets the discovery type for the specified status ID.
     * 
     * @statusID The discovery status ID
     * @returns The discovery type
     */
    getDiscoveryType(statusID: String): GlideRecord;

    /**
     * Gets the fields that have changed for the specified device.
     * 
     * @gr The device
     * @example
     * var df = new DiscoveryFunctions();
     * df.getFieldsThatChanged("device1");
     * @returns An array of fields that have changed.
     */
    getFieldsThatChanged(gr: GlideRecord): Array<any>;

    /**
     * Gets the schedule record.
     * 
     * @returns The schedule record
     */
    getScheduleRecord(): GlideRecord;

    /**
     * Gets the service assigned to the specified port.
     * 
     * @port The port to check
     * @returns The service assigned to the port.
     */
    getService(port: String): GlideRecord;

    /**
     * Gets the status record.
     * 
     * @returns The Discovery status record
     */
    getStatusRecord(): GlideRecord;

    /**
     * Gets the XML memory table.
     * 
     * @tableName The table name
     * @doc The document where the table resides.
     * @path The path to the table
     * @returns The XML memory table
     */
    getXMLMemoryTable(tableName: String, doc: String, path: String): String;

    /**
     * Inserts a new process ID.
     * 
     * @pids The process ID
     * @app_sys_id The application sys_id
     * @ci_sys_id The virtual machine ID
     */
    insertPIDs(pids: String, app_sys_id: String, ci_sys_id: String);

    /**
     * Determines if the given IP address is within the current IP range.
     * 
     * @ip The IP address to check
     * @example
     * var df = new DiscoveryFunctions();
     * df.isInRange("71.191.290.131");
     * @returns True if the IP address is in range, false otherwise.
     */
    isInRange(ip: String): Boolean;

    /**
     * Reclassifies a device.
     * 
     * @device The device to reclassify
     * @newClassName The new classification
     * @reason The reason for the change
     * @returns The reclassified CI
     */
    reclassify(device: GlideRecord, newClassName: String, reason: String): GlideRecord;

    /**
     * Determines whether a relationship already exists between the parent and child.
     * 
     * @parent The parent virtual machine
     * @child The child virtual machine
     * @descriptor The relationship descriptor
     * @returns The record for the relationship if it exists.
     */
    relationshipExists(parent: GlideRecord, child: GlideRecord, descriptor: GlideRecord): GlideRecord;

    /**
     * Updates the history of the current device.
     * 
     * @gr The device
     * @sensor The sensor
     * @eccID The External Communication Channel (ECC) queue ID.
     */
    updatedHistory(gr: GlideRecord, sensor: String, eccID: String);

    /**
     * Updates the process ID.
     * 
     * @pids The process ID
     * @app_sys_id The application sys_id
     * @ci_sys_id The virtual machine ID
     */
    updatePIDS(pids: String, app_sys_id: String, ci_sys_id: String);

}

/**
 * Builds a URL for the calculated issues_link field in discovery_device_history. Use with any server-side discovery script where you need a build a URL for a calculated issues link.
 * 
 * 
 */
declare class DiscoveryIssuesURLBuilder {



    /**
     * Builds and returns the URL for the calculated issues_link field in discovery_device_history.
     * 
     * @deviceHistory The device history record
     * @returns The URL
     */
    url(deviceHistory: GlideRecord): String;

}

/**
 * Encapsulates a scheduled job that kicks off a discovery. Use with any server-side discovery script.
 * 
 * 
 */
declare class DiscoveryJob {



    /**
     * Creates an instance of the DiscoveryJob class.
     * 
     */
    constructor();

    /**
     * Determines if the discovery job has been run at least once.
     * 
     * @example
     * var dj = new DiscoveryJob();
     * gs.print(dj.isRunOnce());
     * @returns True if the job has been run one or more times. False if the job has not been run.
     */
    isRunOnce(): Boolean;

}

/**
 * Provides methods for convenient logging of Discovery events. Use with any server-side script where you want to log Discovery events.
 * 
 * 
 */
declare class DiscoveryLogger {



    /**
     * Creates an instance of the DiscoveryLogger.
     * 
     * @sys_id A sys_id of a discovery status record.
     * @example
     * var dlogger = new DiscoveryLogger(current.sys_id);
     */
    constructor(sys_id: String);

    /**
     * Logs error events.
     * 
     * @msg The message detailing the outcome of the activity or the discovery process.
     * @source The activity, such as SNMP Identity or Windows Identity, where the event occurred.
     * @sensor The sensor that processed the results of the probe.
     * @ci The device for which a matching CI was found in the CMDB.
     * @example
     * var dlogger = new DiscoveryLogger(current.sys_id);
     * dlogger.error('Error message', 'Discovery');
     */
    error(msg: String, source: String, sensor: String, ci: String);

    /**
     * Logs information events.
     * 
     * @msg The message detailing the outcome of the activity or the discovery process.
     * @source The activity, such as SNMP Identity or Windows Identity, where the event occurred.
     * @sensor The sensor that processed the results of the probe.
     * @ci The device for which a matching CI was found in the CMDB.
     * @example
     * var dlogger = new DiscoveryLogger(current.sys_id);
     * dlogger.info('Discovery started', 'Discovery');
     */
    info(msg: String, source: String, sensor: String, ci: String);

    /**
     * Logs all events.
     * 
     * @msg The message detailing the outcome of the activity or the discovery process.
     * @source The activity, such as SNMP Identity or Windows Identity, where the event occurred.
     * @sensor The sensor that processed the results of the probe.
     * @ci The device for which a matching CI was found in the CMDB.
     * @example
     * var dlogger = new DiscoveryLogger(current.sys_id);
     * dlogger.log('Message text', 'Discovery');
     */
    log(msg: String, source: String, sensor: String, ci: String);

    /**
     * Logs warning events.
     * 
     * @msg The message detailing the outcome of the activity or the discovery process.
     * @source The activity, such as SNMP Identity or Windows Identity, where the event occurred.
     * @sensor The sensor that processed the results of the probe.
     * @ci The device for which a matching CI was found in the CMDB.
     * @example
     * var dlogger = new DiscoveryLogger(current.sys_id);
     * dlogger.warn('Warning message', 'Discovery');
     */
    warn(msg: String, source: String, sensor: String, ci: String);

}

/**
 * Provides utilities for parsing XML files returned by a Mac OS. Use where you want to parse XML files returned by a Mac OS during the discovery process.
 * 
 * 
 */
declare class DiscoveryMacProfileUtils {



    /**
     * Returns the child elements for a specified node as an array.
     * 
     * @el The node for which to get the child elements.
     * @returns An array of child elements
     */
    getArrayFromNode(el: String): String;

    /**
     * Returns the base element for a specified output.
     * 
     * @output The output for which to get the base element.
     * @returns The base element
     */
    getBaseElement(output: String): String;

    /**
     * Returns the child elements for a specified node as a hash map.
     * 
     * @el The node for which to get the child elements
     * @returns A hash map of child elements.
     */
    getHashFromNode(el: String): Object;

}

/**
 * Sensor that processes MSSQL data fetched from either the PowershellMSSQL probe or the RemoteRunner probe. Use with any server-side discovery script.
 * 
 * 
 */
declare class DiscoveryMSSQLSensor {



    /**
     * Parses the data fetched from the probe.
     * 
     * @result The data fetched from the probe
     */
    parseResult(result: Object);

    /**
     * Populates the database catalogs with the data fetched from the probe.
     * 
     * @result The data fetched from the probe
     */
    populateDBCatalogs(result: Object);

    /**
     * Does nothing if there is no data fetched from the probe.
     * 
     */
    zeroResults();

}

/**
 * Implements multisensors by running the multisensor scripts to process the information for results (called once for each probe). Use in any server-side script where you need to implement a multisensor.
 * 
 * 
 */
declare class DiscoveryMultiSensor {



    /**
     * Logs the event if the sensor script has no payload data to process.
     * 
     * @name The sensor name
     */
    logEmptyPayload(name: String);

    /**
     * Prepares the sensor by loading the CI data.
     * 
     */
    prepare();

    /**
     * Determines if the script is valid. Logs an error if the script is invalid.
     * 
     * @script The script to validate
     * @msgr The multisensor record
     * @returns True if the script is valid; otherwise, false.
     */
    validateScript(script: String, msgr: GlideRecord): Boolean;

}

/**
 * Encapsulates discovery phases using Shazzam. Use this script include during the discovery scanning phase.
 * 
 * 
 */
declare class DiscoveryPhaser {



    /**
     * Creates an instance of the DiscoveryPhaser class.
     * 
     * @discoveryStatus The discovery status
     */
    constructor(discoveryStatus: GlideRecord);

    /**
     * Determines if any ports were scanned for the specified probe.
     * 
     * @portProbes The probes to check
     * @returns True, if the ports were scanned; otherwise, false.
     */
    anyScanned(portProbes: String): Boolean;

    /**
     * Determines if there are any remaining phases for the discovery probe.
     * 
     * @returns True, if there are phases remaining; otherwise, false.
     */
    hasNextPhase(): Boolean;

}

/**
 * Encapsulates the notion of a discovery port probe. Use the DiscoveryPortProbe class during the discovery scanning phase.
 * 
 * 
 */
declare class DiscoveryPortProbe {

    /** The Active flag is true if the port probe is active; otherwise false. */
    Active: Boolean
    /** Table name to use for classification when this port probe is active. */
    class: String
    /** The classification priority. */
    classificationPriority: Number
    /** True if it is a conditional scanner; otherwise, false. */
    conditional: Boolean
    /** The port probe description. */
    Description: String
    /** The discoverCIs flag is true if the port probe is active to discover CIs. */
    discoverCIs: Boolean
    /** The port probe name. */
    Name: String
    /** The name of the Java class on the MID server to use as a scanner. */
    scanner: String
    /** The optional script associated with the current port probe. */
    script: String
    /** A JavaScript array of the IPService instances associated with the current port
    probe. */
    services: Array<any>
    /** The sys_id of the port probe record. */
    sysID: String
    /** The sysID of the probe triggered by the current port probe. */
    triggersProbeID: String


    /**
     * Creates an instance of the DiscoveryPortProbe class.
     * 
     * @source Either a GlideRecord instance or a sysID string.
     */
    constructor(source: Object);

}

/**
 * Provides a set of functions used in discovery port scanning. Use this class during the discovery scanning phase
 * 
 * 
 */
declare class DiscoveryPortScanner {



    /**
     * Creates an instance of the DiscoveryPortScanner class.
     * 
     */
    constructor();

    /**
     * Fires the port probe for the specified port.
     * 
     * @port The port to probe.
     * @example
     * var dscps = new DiscoveryPortScanner();
     * dscps.firePortProbeByPort("1434");
     * @returns The number of probes fired.
     */
    firePortProbeByPort(port: String): Number;

    /**
     * Gets a list of all service ports.
     * 
     * @example
     * var dscps = new DiscoveryPortScanner();
     * gs.print(dscps.getAllServicePorts());
     * @returns A list of all service ports
     */
    getAllServicePorts(): Array<any>;

    /**
     * Brief description of the method.
     * 
     * @name Name of the port probe
     * @returns The port probe
     */
    getPortProbeByName(name: String): GlideRecord;

    /**
     * Gets all the current port probes for the current device.
     * 
     * @example
     * var dscps = new DiscoveryPortScanner();
     * dscps.getPortProbes();
     * @returns The port probes
     */
    getPortProbes(): GlideRecord;

    /**
     * Returns the port probes for a specified service port.
     * 
     * @servicePort The service port
     * @returns The service probes. Returns null if there are no service probes.
     */
    getPPFromSP(servicePort: String): GlideRecord;

    /**
     * Returns the service ports for a specified port probe.
     * 
     * @portProbe The port probe
     * @returns A list of all service ports
     */
    getSPFromPP(portProbe: DiscoveryPortProbe): Array<any>;

    /**
     * Returns the service ports for a specified probe process ID.
     * 
     * @ppid The probe process ID.
     * @returns A list of all service ports
     */
    getSPFromPPId(ppid: String): Array<any>;

    /**
     * Puts the specified probe and port on the discovery schedule.
     * 
     * @portProbe The port probe to schedule
     * @port The port to probe
     * @returns The number of probes added to the schedule.
     */
    scheduleProbe(portProbe: DiscoveryPortProbe, port: String): Number;

    /**
     * Updates the service ports for a specified CMDB configuration item.
     * 
     * @openPorts The ports that are open
     * @scannedPorts The ports that have been scanned
     * @cmdbCi The CMDB configuration item
     */
    updateCIServicePorts(openPorts: Array<any>, scannedPorts: String, cmdbCi: String);

}

/**
 * Determines how to match an application during process classification. Use with any discovery script where you need match an application during process classification.
 * 
 * 
 */
declare class DiscoveryProcessAppMatch {



    /**
     * Matches an application during process classification.
     * 
     * @returns True if there are phases remaining; otherwise, false.
     */
    match(): Boolean;

}

/**
 * Provides an abstract sensor class for running discovery processes. Use this to implement your own sensor to run discovery processes.
 * 
 * 
 */
declare class DiscoveryProcessConnectionsSensor {



    /**
     * Adds a connection to the sensor.
     * 
     * @dtcp The connection to add
     */
    addConnection(dtcp: Object);

    /**
     * Adds an array of connections to the sensor.
     * 
     * @connections An array of connections to add
     */
    addConnections(connections: Array<any>);

    /**
     * Adds a single listener.
     * 
     * @dtcp The discovery TCP
     */
    addListener(dtcp: Object);

    /**
     * Adds an array of listeners.
     * 
     * @listeners An array of discovery TCPs
     */
    addListeners(listeners: Array<any>);

    /**
     * Completes a number of tasks after a connection has been reconciled, including checking for a print server.
     * 
     */
    after();

    /**
     * Logs the connections made by the sensor.
     * 
     */
    logConnections();

    /**
     * Provide code for this method to parse the output.
     * 
     * @output The output to parse
     */
    parse(output: Object);

}

/**
 * Provides tools for working with UNIX process status information returned by the ps command. Most UNIX platforms share a common output for the ps command. This object is shared among the various ps sensors in discovery. Use in any server-side discovery script.
 * 
 * 
 */
declare class DiscoveryPsSensor {



    /**
     * Returns the operating system type, either ESXi or UNIX.
     * 
     * @returns The OS type, either esx or unix.
     */
    getOSType(): String;

    /**
     * Maps the process status results returned from the ps command.
     * 
     * @result The result of the ps command
     */
    mapProcesses(result: Object);

    /**
     * Parses the column header.
     * 
     * @line The column header to parse
     * @returns The column line items
     */
    parseColumnHeader(line: String): Object;

    /**
     * Parses a line returned by the ps command.
     * 
     * @line The line to parse
     * @returns The parsed line values
     */
    parseLine(line: String): Object;

}

/**
 * The abstract sensor for running processes. Use to create a sensor for running processes.
 * 
 * 
 */
declare class DiscoveryRunningProcessSensor {



    /**
     * Adds a discovered sensor to the specified process.
     * 
     * @fc The process to add the sensor to.
     */
    addDiscovered(fc: String);

    /**
     * After the reconciler finishes processing, finishes other tasks and starts application mapping.
     * 
     */
    after();

    /**
     * Determines if the cluster has any relationships.
     * 
     * @ci The cluster node cmdb_ci
     * @returns True if the cluster has relationships; otherwise, false.
     */
    hasClusterRelationship(ci: Object): Boolean;

    /**
     * Adds any inserts to the specified process.
     * 
     * @correlationId The correlation ID
     * @classifiedProcess The classified process
     */
    insertCiProcess(correlationId: String, classifiedProcess: Object);

    /**
     * Performs both pending inserts and updates to the specified process.
     * 
     * @classifiedProcess The process into which inserts of updates will be made.
     */
    insertOrUpdate(classifiedProcess: Object);

    /**
     * Determines if a classified process can be clustered.
     * 
     * @classifiedProcess The classified process
     * @returns True if the process can be clustered; otherwise, false.
     */
    isClusterable(classifiedProcess: Object): Boolean;

    /**
     * Implement your own map process by overwriting this method with a class extending this object.
     * 
     * @result The result from the discovery sensor
     */
    mapProcesses(result: Object);

    /**
     * Triggers the probe when the process is discovered.
     * 
     */
    processDiscovered();

    /**
     * Sets the field values of the CI, if values are available.
     * 
     * @ci The CI whose fields are to be set.
     * @fields The fields to set
     */
    setFields(ci: Object, fields: Object);

    /**
     * Adds any updates to the specified process.
     * 
     * @ci The CI of the process to update
     * @correlationid The correlation ID
     * @classifiedProcess The classified process
     */
    updateCiProcess(ci: Object, correlationid: String, classifiedProcess: Object);

}

/**
 * Encapsulates a Discovery schedule. Use with any schedule-related server-side discovery script.
 * 
 * 
 */
declare class DiscoverySchedule {

    /** True if this discovery schedule is active. */
    active: Boolean
    /** What to discover. */
    discover: String
    /** True if include alive was checked. */
    includeAlive: Boolean
    /** The location reference in the schedule, or null if none. */
    location: String
    /** True to log state changes. */
    logStateChanges: Boolean
    /** The GlideElement of max_run parameter. */
    maxRun: GlideElement
    /** The MIDServer instance for the associated MID server. */
    midServer: MIDServer
    /** The sys_id of the associated MID server. */
    midServerID: String
    /** The name of this discovery schedule. */
    name: String
    /** A JavaScript array of IPIncludeExcludeCollection instances, one per range. */
    ranges: IPIncludeExcludeCollection
    /** The sys_id of this discovery schedule record. */
    sysID: String


    /**
     * Creates an instance of the DiscoverySchedule class.
     * 
     * @source Either a GlideRecord for the discovery schedule record, or a string containing the sysID for the desired discovery schedule record.
     */
    constructor(source: Object);

    /**
     * Adds a connection to the sensor.
     * 
     * @dtcp The connection
     */
    addConnection(dtcp: String);

    /**
     * Adds an array of connections to the sensor.
     * 
     * @connections An array of connections
     */
    addConnections(connections: Array<any>);

    /**
     * Adds an array of listeners.
     * 
     * @listeners Discovery TCPs.
     */
    addListeners(listeners: Array<any>);

    /**
     * Determines if the current range contains the given IP address.
     * 
     * @ip The IP address in dot-decimal notation.
     * @returns True if the range includes the IP address, false otherwise.
     */
    contains(ip: String): Boolean;

    /**
     * Gets the correct behavior for the specified IP address, or null if none can be found.
     * 
     * @ip The IP address in dot-decimal notation.
     * @returns A DiscoveryBehavior object.
     */
    getBehaviorForIP(ip: String): DiscoveryBehavior;

    /**
     * Retrieves the DiscoveryBehavior instance for the given range.
     * 
     * @ipiec The IPIncludeExcludeCollection for the range.
     * @returns The DiscoveryBehavior record.
     */
    getBehaviorForRange(ipiec: String): GlideRecord;

    /**
     * Logs the connections made by the sensor.
     * 
     */
    logConnections();

}

/**
 * This class describes the default sensor object. All sensors should extend this class. Use this class to define your own discovery sensors. 
 * 
 * 
 */
declare class DiscoverySensor {



    /**
     * Exposes the base values in CIData to the classifiers. Currently used by Windows, Unix, and SNMP.
     * 
     * @sensor The sensor object
     */
    addCIDataBaseValue(sensor: Object);

    /**
     * Adds the CI to the related list.
     * 
     * @tableName The table to add to
     * @dataArray The data array
     * @refName The reference name
     * @keyName The key name
     */
    addToRelatedList(tableName: String, dataArray: Array<any>, refName: String, keyName: String);

    /**
     * Optionally override this in the sensor to finish after processing and saving all results. This method is invoked once after all results have been processed and saved.
     * 
     */
    after();

    /**
     * Checks if the device history is not yet created. If so, do not write to it.
     * 
     * @result The result from the probe
     * @returns True if a history for the deice has been created; otherwise, false.
     */
    checkEmptyPayload(result: Object): Boolean;

    /**
     * Checks whether an error has occurred, and if so calls the function to process the error.
     * 
     * @result The result from the probe
     */
    checkErrorPayload(result: object);

    /**
     * If debugging is turned on, logs the message.
     * 
     * @msg The message to log
     */
    debug(msg: String);

    /**
     * Optionally override this in the sensor to finish after processing all results. This method is invoked once after all results have been processed.
     * 
     */
    finish();

    /**
     * Fires additional classifiers.
     * 
     */
    fireAdditionalClassifier();

    /**
     * Returns the agent name for the probe.
     * 
     * @returns The agent name
     */
    getAgent(): String;

    /**
     * Returns the Configuration Management Database (CMDB) Configuration Item (CI) of the current device.
     * 
     * @returns The current CMDB CI
     */
    getCmdbCi(): GlideRecord;

    /**
     * Returns the current Configuration Management Database (CMDB) record.
     * 
     * @returns The current CMDB record
     */
    getCmdbRecord(): GlideRecord;

    /**
     * Returns the current device's CI object.
     * 
     * @returns The current device CI
     */
    getDeviceCi(): Object;

    /**
     * Returns the queue ID of the current probe.
     * 
     * @returns The queue ID
     */
    getEccQueueId(): String;

    /**
     * Returns the ECC Queue record for the current probe.
     * 
     * @returns The ECC queue record
     */
    getEccQueueRecord(): GlideRecord;

    /**
     * Returns a specified parameter from the Discovery probe.
     * 
     * @returns The requested parameter value
     */
    getParameter(): String;

    /**
     * Returns the name of the current sensor.
     * 
     * @returns The sensor name
     */
    getSensorName(): String;

    /**
     * Returns the probe's Source field value.
     * 
     * @returns Usually contains the IP address that the probe ran against, or if the probe ran against multiple IP addresses, a human-readable description.
     */
    getSource(): String;

    /**
     * Optionally override this method to handle errors.
     * 
     * @error The error message
     */
    handleError(error: String);

    /**
     * Initializes the sensor.
     * 
     * @definition The discovery definition
     */
    init(definition: Object);

    /**
     * Checks to see if debugging mode is on.
     * 
     * @returns True if debugging mode is on; otherwise, false.
     */
    isDebugging(): Boolean;

    /**
     * Creates a log entry if the device history is empty.
     * 
     */
    logEmptyPayload();

    /**
     * Checks for warnings and logs them.
     * 
     * @result The result from the probe
     */
    logWarningPayload(result: Object);

    /**
     * Provides main processing sequence for the script. Loops recursively until a sys_id is found, then processes the CI.
     * 
     */
    main();

    /**
     * Optionally override this in the sensor to prepare for processing results. This method is invoked once before any results have been processed.
     * 
     */
    prepare();

    /**
     * Override this in the sensor to process each result.
     * 
     * @result The result from the probe
     */
    process(result: Object);

    /**
     * Processes an error by eliminating duplicates, writing the error to the error map, and sending the error to the error handler.
     * 
     * @msg The message to process
     */
    processError(msg: String);

    /**
     * Processes a warning message by ignoring duplicate messages and calling handleWarning().
     * 
     * @msg The warning message
     */
    processWarning(msg: String);

    /**
     * Reclassifies a device to the specified classification.
     * 
     * @ciClass The new classification
     * @returns The cmdb record
     */
    reclassify(ciClass: String): GlideRecord;

    /**
     * Runs the sensor, including preparation, checking for and logging any warnings and errors, and checking the payload to ensure that a valid sensor is available to process, and calling finish().
     * 
     */
    run();

    /**
     * Adds variables to the ci_data variable after running the classification script and storing the variables in ci_data.
     * 
     * @script The classification script
     * @ciData The CI data
     */
    runClassificationScript(script: String, ciData: Object);

    /**
     * If there is a device history, saves the processed data from the probe.
     * 
     */
    save();

    /**
     * Sets the current sensor data from a Java map.
     * 
     * @javaMap The sensor data
     */
    setCurrentFromJavaMap(javaMap: JavaMap);

    /**
     * Sets the trigger value from the probe.
     * 
     * @value The probe trigger
     */
    setTriggerProbes(value: String);

    /**
     * Updates the sensor data and related lists.
     * 
     * @data The sensor data
     */
    update(data: Object);

    /**
     * Updates the status count and the device count.
     * 
     */
    updateCounts();

    /**
     * Updates the count of completed devices.
     * 
     */
    updateDeviceCount();

    /**
     * Updates the status count.
     * 
     */
    updateStatusCount();

    /**
     * Override this in the sensor to change the behavior with no results.
     * 
     */
    zeroResults();

}

/**
 * Provides an abstract sensor class for running discovery processes. Use to implement your own sensor to run discovery processes with any schedule-related server-side discovery script.
 * 
 * 
 */
declare class DiscoveryStatus {



    /**
     * Creates an instance of the DiscoveryStatus class.
     * 
     * @statusGR The discovery status
     */
    constructor(statusGR: GlideRecord);

    /**
     * Adds a connection to the sensor.
     * 
     * @dtcp The connection to add
     */
    addConnection(dtcp: String);

    /**
     * Adds an array of connections to the sensor.
     * 
     * @connections An array of connections
     */
    addConnections(connections: Array<any>);

    /**
     * Adds a single listener.
     * 
     * @dtcp The discovery TCP
     */
    addListener(dtcp: String);

    /**
     * Adds an array of listeners.
     * 
     * @listeners An array of discovery TCPs
     */
    addListeners(listeners: Array<any>);

    /**
     * Completes a number of tasks after a connection has been reconciled, including checking for a print server.
     * 
     */
    after();

    /**
     * Logs the connections made by the sensor.
     * 
     */
    logConnections();

    /**
     * Provide code for this method to parse the output.
     * 
     * @output The output to parse
     */
    parse(output: String);

    /**
     * Called by the Prototype JavaScript Framework during object processing. Provide a value for the parameter, but do not call this method directly.
     * 
     * @result The discovery result
     */
    process(result: String);

}

/**
 * Represents a TCP connection belonging to a process. Provides methods for managing discovery TCP/IP connections. Use wherever you need to manage discovery TCP connections.
 * 
 * 
 */
declare class DiscoveryTCPConnection {



    /**
     * Brief description of the method.
     * 
     * @returns The connection command
     */
    getCommand(): String;

    /**
     * Returns the host name of the from host.
     * 
     * @returns The host name of the from host
     */
    getFromHost(): String;

    /**
     * Returns the port number of the from host.
     * 
     * @returns The port number of the from host.
     */
    getFromPort(): String;

    /**
     * Returns the IP address and port number for the specified port.
     * 
     * @hostPort The host's port
     * @returns The host IP address and port number in the format host:port. The String[] array with 0 as the host and 1 as the port.
     */
    getHostPort(hostPort: String): String;

    /**
     * Returns the process identifier (PID) of the current application.
     * 
     * @returns The current application's process identifier.
     */
    getPID(): String;

    /**
     * Returns the host name of the to host.
     * 
     * @returns The host name of the to host.
     */
    getToHost(): String;

    /**
     * Returns the port number of the to host.
     * 
     * @returns The port number of the to host.
     */
    getToPort(): String;

    /**
     * Determines if the current device is listening.
     * 
     * @returns True if the device is listening; otherwise, false.
     */
    isListening(): Boolean;

    /**
     * Determines if there is a from host and from port.
     * 
     * @returns True if there is a from host and from port; otherwise, false.
     */
    isValid(): Boolean;

    /**
     * Determines if there is a valid connection with the from host and port.
     * 
     * @example
     * var dtcpc = new DiscoveryTCPConnection();
     * gs.print(dtcpc.isValid());
     * @returns True if the connection is valid; otherwise, false.
     */
    isValidConnection(): Boolean;

    /**
     * Sets the connection command for the current process.
     * 
     * @cmd The connection command
     */
    setCommand(cmd: String);

    /**
     * Sets up the discovery TCP connection.
     * 
     * @connectStr The connection string
     */
    setConnection(connectStr: String);

    /**
     * Sets the host name and port of the from host.
     * 
     * @hostName The name of the host
     * @portName The name of the port
     */
    setFrom(hostName: String, portName: String);

    /**
     * Sets a listener for the current device.
     * 
     * @b  
     */
    setListening(b: Boolean);

    /**
     * Sets the process identifier (PID) for the application.
     * 
     * @pid The application's process identifier.
     */
    setPID(pid: String);

    /**
     * Sets the host name and port number of the to host.
     * 
     * @hostName The host name
     * @portName The port number
     */
    setTo(hostName: String, portName: String);

    /**
     * Returns the current connection command and connection string in string format.
     * 
     * @returns The current connection command and connection string.
     */
    toString(): String;

}

/**
 * Use this script include in any server-side script to display a list of discovery probes and sensors in a time line on a schedule page. This API generates a view that shows discovery probes and sensors on the time line. It parses the ecc_queue and sorts the returned items to display a list of nodes and sensor times with respect to their probe. See the TimelineAbstractSchedulePage API for the correct implementation and API usage.
 * 
 * 
 */
declare class DiscoveryTimeline {



    /**
     * Brief description of the method.
     * 
     * @example
     * var discl = new DiscoveryTimeline();
     * discl.getItems();
     */
    getItems();

}

/**
 * A utility class providing methods for the discovery of UI actions. Use with any server-side script to perform condition checks for Discovery UI actions.
 * 
 * 
 */
declare class DiscoveryUIActionUtils {



    /**
     * Determines if there are newer entries in the device history table.
     * 
     * @example
     * var disb = new DiscoveryUIActionUtils();
     * disb.hasNewerDeviceHistory();
     * @returns True if there are newer entries; otherwise, false.
     */
    hasNewerDeviceHistory(): Boolean;

    /**
     * Determines if there are older entries in the device history table.
     * 
     * @example
     * var disb = new DiscoveryUIActionUtils();
     * disb.hasOlderDeviceHistory();
     * @returns True if there are older entries; otherwise, false.
     */
    hasOlderDeviceHistory(): Boolean;

}

/**
 * Sensor for processing VMWare information from UNIX and Windows. Use with any server-side discovery script.
 * 
 * 
 */
declare class DiscoveryVMWareSensor {



    /**
     * Creates a link to the virtual servers.
     * 
     * @images The VMWare images
     * @vmWare The CI of the VMWare, which can be the ESXi box, or a VMWare application running on top.
     */
    createLinkToVirtualServers(images: Object, vmWare: CI);

    /**
     * Deletes the VM images.
     * 
     * @vmWare The VMWare images to delete.
     * @imageProcessed The processed image
     */
    deleteVMImagesFromVMWare(vmWare: Object, imageProcessed: Object);

    /**
     * Parses the result returned from the discovery sensor.
     * 
     * @result The result returned by the sensor.
     */
    parseResult(result: Object);

    /**
     * Parses the VM file.
     * 
     * @file The file
     * @returns  
     */
    parseVMFile(file: String): Array<any>;

    /**
     * Returns the VMware host (ESXi box) where the current application is running.
     * 
     * @vms The VM node
     * @returns The parsed instances.
     */
    parseVMNodes(vms: Object): Array<any>;

    /**
     * Updates the VMware images and links to the virtual servers.
     * 
     * @instance The instance to process
     */
    processInstances(instance: Object);

    /**
     * Returns the VM version information.
     * 
     * @vmList The result returned by the sensor.
     */
    processVersion(vmList: Object);

    /**
     * Updates the VMware images.
     * 
     * @instances An array of instances to process.
     * @vmWare The VMWare images to update.
     * @returns The processed images
     */
    updateVMWareImages(instances: Array<any>, vmWare: Object): Array<any>;

}

/**
 * Base class for Windows classify and Windows cluster sensors. Use with any server-side discovery script.
 * 
 * 
 */
declare class DiscoveryWindowsClusterBaseSensor {



    /**
     * Associates Windows clusters with resources in the result returned by the sensor
     * 
     * @result The result from the sensor
     */
    associateClustersToResources(result: Object);

    /**
     * Associates Windows clusters with specific nodes in the result returned by the sensor.
     * 
     * @result The result from the sensor
     */
    associateClustertoNodes(result: Object);

    /**
     * Associates resources with specific nodes in the result returned by the sensor.
     * 
     * @result The result from the sensor
     */
    associateResourcesToNodes(result: Object);

    /**
     * Changes the CI sys_id for the current device to the specified CI sys_id.
     * 
     * @newCIGR The new CI sys_id for the device.
     */
    changeCI(newCIGR: String);

    /**
     * Finds the specified cluster record.
     * 
     * @name The cluster record to find
     * @returns The requested cluster record
     */
    findCluster(name: String): GlideRecord;

    /**
     * Finds the Windows clusters in the result returned by the sensor.
     * 
     * @result The result from the sensor
     */
    findClusters(result: Object);

    /**
     * Finds the Windows cluster nodes in the result returned by the sensor, and creates an object for each with information about the node, including name, status, description, state, caption, and server.
     * 
     * @result The result from the sensor
     */
    findNodes(result: Object);

    /**
     * Finds the requested cluster; if it does not exist, creates a new cluster record under the specified name.
     * 
     * @name The cluster name to find or, if it does not exist, the name for the new cluster record.
     * @returns The found, or newly created, cluster record.
     */
    findOrCreateCluster(name: String): GlideRecord;

    /**
     * Finds the Windows cluster resources and puts them into an array of resource information.
     * 
     * @result The result from the sensor
     */
    findResources(result: Object);

    /**
     * Returns the value of a specified property.
     * 
     * @name The property
     * @source The property's source
     * @returns The requested name/value pair.
     */
    getPropValue(name: String, source: String): String;

    /**
     * Converts the specified value to a string.
     * 
     * @value The value to convert
     * @returns The value converted to a string; if the value parameter is empty, returns null.
     */
    primStr(value: Object): String;

    /**
     * Converts cluster properties to a readable format.
     * 
     * @properties The properties to convert
     * @returns The converted properties in the format [property name:property value], with one property:value pair per line.
     */
    propertiesToHumanReadable(properties: String): String;

    /**
     * Queries the Windows Cluster (cmdb_ci_win_cluster) table for the specified cluster.
     * 
     * @name The cluster for which to search.
     * @returns The record for the specified cluster.
     */
    queryForCluster(name: String): GlideRecord;

}

/**
 * Provides methods for calculating durations and due dates. 
 * 
 * 
 */
declare class DurationCalculator {



    /**
     * Constructor for DurationCalculator class.
     * 
     * @example
     * var dc = new DurationCalculator();
     */
    constructor();

    /**
     * Calculates an end date and time based on a specified start datetime and duration (seconds).Upon completion, this.endDateTime, this.seconds, and this.totalSeconds properties are set to indicate the results of the calculation. Prior to calling this method, you must call setStartDateTime() with the start time to use in the computation.
     * 
     * @seconds Number of seconds to add to the startDateTime to compute the other values.
     * @example
     * var gdt = new GlideDateTime("2012-05-01 00:00:00");
     * dc.setStartDateTime(gdt);
     * if(!dc.calcDuration(2*24*3600)){ // 2 days
     *   gs.log("*** Error calculating duration");
     *   return;
     * }
     *     
     * @returns False if input value is not a number.
     */
    calcDuration(seconds: Number): Boolean;

    /**
     * Calculates the due date starting at start and adding days using the schedule and time zone.Called from relative duration definitions, initiated by calcRelativeDuration(), as calculator.calcRelativeDueDate(calculator.startDateTime, days). When the day that the work is due is found, sets the time to endTime of that day. If there are not enough days left in the schedule, uses the last day in the schedule.
     * 
     * @start Start datetime for the computation.
     * @days Number of days to add to the start datetime.
     * @endTime Time due of the computed day due in "hh:mm:ss" format, or blank to indicate the end of the work day
     * @example
     * var dc = new DurationCalculator();
     * dc.calcRelativeDueDate("2012-04-10 08:00:00", 2, "08:00:00")
     * @returns True if the completion date is within the schedule. False if the completion date falls outside the schedule. Undefined if no schedule was set prior to calling this method.
     */
    calcRelativeDueDate(start: GlideDateTime, days: Number, endTime: String): Boolean;

    /**
     * Calculates the duration using the specified relative duration script.Upon completion, the this.endDateTime and this.seconds properties are set to indicate the results of the calculation.
     * 
     * @relativeDurationID sys_id of relative duration schedule (table cmn_relative_duration).
     * @example
     * var dc = new DurationCalculator();
     * dc.calcRelativeDuration('08fcd0830a0a1b2600074f56b1ad7cb');
     * @returns The result of the duration script.
     */
    calcRelativeDuration(relativeDurationID: String): Boolean;

    /**
     * Returns the actual duration between startTime and endTime within the already-specified schedule and optionally overridden timezone.Sets this.endDateTime (for completeness), this.seconds, and this.totalSeconds.
     * 
     * @startTime The start time. If not provided the current value is used (set using setStartDateTime()).
     * @endTime The end time. If not provided the current value is used (set using setEndDateTime()).
     * @returns The schedule duration in seconds (same as calling getSeconds()). Returns 0 if endTime is before startTime.
     */
    calcScheduleDuration(startTime: GlideDateTime, endTime: GlideDateTime): Number;

    /**
     * Gets the actual duration between startTime and endTime within the already-specified schedule and optionally overridden timezone. Sets this.endDateTime (for completeness), this.seconds, and this.totalSeconds.Sets this.endDateTime (for completeness), this.seconds, and this.totalSeconds.
     * 
     * @startTime The start time. If not provided the current value is used (set using setStartDateTime()).
     * @endTime The end time. If not provided the current value is used (set using setEndDateTime()).
     * @example
     * var dc = new DurationCalculator();
     * gs.print(dc.calcScheduleDuration("2012-04-10 08:00:00","2012-04-14 06:00:00"));
     *     
     * @returns The schedule duration in seconds (same as calling getSeconds()). Returns 0 if endTime is before startTime.
     */
    calcScheduleDuration(startTime: String, endTime: String): Number;

    /**
     * Gets the endDateTime property that was set by calcDuration/calcRelativeDuration, indicating the end date and time for the duration.
     * 
     * @example
     * var dc = new DurationCalculator();
     * dc.calcDuration(52);
     * gs.print(dc.getEndDateTime());
     * @returns The end datetime.
     */
    getEndDateTime(): GlideDateTime;

    /**
     * Gets the this.seconds property that was set by calcDuration/calcRelativeDuration, indicating the total number of seconds of work to be performed for the duration. This is the total work time, not the total time between start and end times and may be used to determine percentages of the work time.This is the total work time, not the total time between start and end times and may be used to determine percentages of the work time.
     * 
     * @example
     * var dc = new DurationCalculator();
     * dc.calcDuration(52);
     * gs.print(dc.getSeconds());
     * @returns The total work time, in seconds.
     */
    getSeconds(): Number;

    /**
     * Gets the totalSeconds value that was set by a call to calculate(record).
     * 
     * @example
     * var dc = new DurationCalculator();
     * dc.calcDuration(52);
     * gs.print(dc.getTotalSeconds());
     * @returns The total number of seconds.
     */
    getTotalSeconds(): Number;

    /**
     * Checks if a time occurs after a specified time of day.
     * 
     * @dt The Datetime to compare to.
     * @tm The test datetime.
     * @example
     * var dc = new DurationCalculator();
     * gs.print(dc.isAfter("2012-04-10 08:00:00", "07:00:00"));
     * @returns True if tm is after dt.
     */
    isAfter(dt: GlideDateTime, tm: String): Boolean;

    /**
     * Sets the schedule and time zone to use for calculating the due date.
     * 
     * @schedId The schedule sys_id (table cmn_schedule).
     * @timezone (Optional) Time zone string value.
     * @example
     * var dc = new DurationCalculator();
     * dc.setSchedule('08fcd0830a0a0b2600079f56b1adb9ae', 'Los Angeles');
     */
    setSchedule(schedId: String, timezone: String);

    /**
     * Sets the start datetime for the duration calculations.
     * 
     * @description (Optional) The start time in GMT for subsequent calculations. If not present then the current datetime is used.
     * @amount amount
     * @example
     * var dc = new DurationCalculator();
     * dc.calcDuration(52);
     * gs.print(dc.getEndDateTime());
     */
    setStartDateTime(description: GlideDateTime, amount: Number);

    /**
     * Sets the start datetime for the duration calculations.
     * 
     * @start (Optional) The start time in GMT for subsequent calculations. If not present then the current datetime is used.
     * @example
     * var dc = new DurationCalculator();
     * dc.setStartDateTime("2012-04-10 08:00:00")
     */
    setStartDateTime(start: String);

    /**
     * Sets the time zone to use for calculating the due date.
     * 
     * @timezone Value of the time zone.
     * @example
     * var dc = new DurationCalculator();
     * dc.setTimeZone("Los Angeles");
     */
    setTimeZone(timezone: String);

}

/**
 * The ExpenseAllocation API is included with the Cost Management Plugin as a script include record. It is used by various cost management processes and can also be used for generating custom expense allocation records (fm_expense_allocation) from scripted expense allocation rules. 
 * 
 * 
 */
declare class ExpenseAllocation {



    /**
     * Called when you create a new ExpenseAllocation object.This is not needed if scripting advanced allocation rules. This object is already available as the allocation variable.
     * 
     * @expense GlideRecord identifying the source of the expense.
     * @rule GlideRecord identifying the rule to use in allocating the expense line.
     * @example
     * var allocation=new ExpenseAllocation(expenseGlideRecord, ruleGlideRecord);
     * @returns The ExpenseAllocation object just created.
     */
    constructor(expense: GlideRecord, rule: GlideRecord): ExpenseAllocationobject;

    /**
     * Creates an expense allocation (fm_expense_allocation) record referencing the parameters provided during instantiation and this method.
     * 
     * @target GlideRecord target of the allocation, for example a cost center record to allocate an expense to Decimal amount - the amount of the allocation.
     * @amount The amount of the allocation.
     * @example
     * var allocation=new ExpenseAllocation(expenseGlideRecord, ruleGlideRecord);
     * allocation.createAllocation(costCenterGlideRecord, 2345.67);
     * @returns True if the expense allocation was successfully created.
     */
    createAllocation(target: GlideRecord, amount: Number): Boolean;

}

/**
 * The ExpenseLine API is included with the Cost Management Plugin as a script include record. It is used by various cost management processes and can also be used for generating expense line (fm_expense_line) records from your own server-side scripts. 
 * 
 * 
 */
declare class ExpenseLine {



    /**
     * Constructor for ExpenseLine object.
     * 
     * @source GlideRecord identifying the source of the expense
     * @amount Decimal number identifying the amount of the expense
     * @description (Optional) Description of the expense.
     * @example
     * //get some random CI to be used as an expense source
     *         var ci = new GlideRecord("cmdb_ci_server");
     *         ci.query();
     *         ci.next();
     *         
     *         //create expense line
     *         var exp = new ExpenseLine(ci, 234.56, "Test expense line");
     * @returns The ExpenseLine object just instantiated.
     */
    constructor(source: GlideRecord, amount: Number, description: String): ExpenseLineobject;

    /**
     * Creates a new expense line record.
     * 
     * @example
     * //get some random CI to be used as an expense sourcevar ci =new GlideRecord("cmdb_ci_server");
     * ci.query();
     * ci.next();
     *  
     * //create expense line
     * var exp =new ExpenseLine(ci,234.56,"Test expense line");
     * exp.setSummaryType("run_business");
     * var success = exp.createExpense();
     * 
     * @returns True if the expense line was successfully created.
     */
    createExpense(): Boolean;

    /**
     * Used internally by the createExpense method to process CI relationships when the expense source is a cmdb_ci record.
     * 
     */
    processCIParents();

    /**
     * Identifies the source rate card or distribution cost that was the source of expense line generation.This is not the source (CI, task) of the expense.
     * 
     * @costSource GlideRecord of CI rate card cost, distribution cost, or task rate card. This is generally only used for system-generated expense lines.
     */
    setCostSource(costSource: GlideRecord);

    /**
     * Defines the description of an expense.
     * 
     * @description Description of expense.
     */
    setDescription(description: String);

    /**
     * Sets the parent field on the expense line.This is generally only used by the system when generating indirect expenses such as business service aggregated expenses.
     * 
     * @expense Parent expense line record.
     */
    setParent(expense: GlideRecord);

    /**
     * Flags the expense as recurring by setting the recurring field to true.Expense lines are set to false by default so there is no need to call setRecurring(false).
     * 
     * @recurring Set to true to identify expense line as a recurring expense.
     */
    setRecurring(recurring: Boolean);

    /**
     * Sets a value for the expense line summary_type field.
     * 
     * @summaryType Typically you would set this to a value already specified in the expense line summary type field choice list.
     * @example
     * //get some random CI to be used as an expense sourcevar ci =new GlideRecord("cmdb_ci_server");
     * ci.query();
     * ci.next();
     *  
     * //create expense line
     * var exp =new ExpenseLine(ci,234.56,"Test expense line");
     * exp.setSummaryType("run_business");
     */
    setSummaryType(summaryType: String);

}

/**
 * Extracts terms from an attachment. This class is called with the ScriptedExtractor object, SysAttachmentInputStream, the sys_id for the attachment, and the extension for the attachment. The getTerms() method is called to extract the terms from the attachment that should be indexed. The getTerms() method should just return a string that contains the terms. If you prefer to input a file rather than an inputStream, call extractor.getFile() to get the File object containing the attachment.
 * 
 * 
 */
declare class ExtractTermsFromAttachment {



}

/**
 * Use FlowAPI methods to execute actions, flows, or subflows in server-side scripts using either blocking or non-blocking methods. Access FlowAPI methods in global and scoped scripts using the sn_fd.FlowAPI object. Create calls to your flows using the Code Snippet action in Flow Designer, or use the methods detailed here to update scripts manually.
 * 
 * 
 */
declare class FlowAPI {



    /**
     * Run an action from a server-side script synchronously.Execute an action from within a business rule, script include, or any other server-side script. Actions run using this method run synchronously, so the method has access to outputs created by the action. Use startAction to run an action asynchronously.
     * 
     * @name The scope and name of the action to be executed, for example global.action_name.
     * @inputs Inputs defined for the action.
     * @timeout (Optional) Timeout in milliseconds. This value overrides the default timeout specified by the com.glide.hub.flow_api.default_execution_time property. After timeout expires an exception will be thrown.
     * @example
     * 
     * (function() {
     * 	
     * 	try {
     * 		var inputs = {};
     * 		inputs['name'] = ; // String 
     * 		inputs['password2'] = ; // Password (2 Way Encrypted) 
     * 		
     * 		// Execute Synchronously: Run in foreground. Code snippet has access to outputs.
     * 		// var timeout = ; //timeout in ms
     *               //sn_fd.FlowAPI.executeAction('global.actionforpassword2test', inputs, timeout)
     *               var outputs = sn_fd.FlowAPI.executeAction('global.actionforpassword2test', inputs);
     * 
     * 		// Get Outputs:
     * 		// Note: outputs can only be retrieved when executing synchronously.
     * 		var output = outputs['output']; // Password (2 Way Encrypted)
     * 		
     * 	} catch (ex) {
     * 		var message = ex.getMessage();
     * 		gs.error(message);
     * 	}	
     * })();
     * @returns The action outputs.
     */
    executeAction(name: String, inputs: Object, timeout: Number): Object;

    /**
     * Run a flow from a server-side script synchronously.Execute a flow from within a business rule, script include, or any other server-side script. Flows run using this method run synchronously. Use startFlow to run a flow asynchronously.
     * 
     * @name The scope and name of the flow to be executed, for example global.flow_name.
     * @inputs Arguments used in the flow.
     * @timeout (Optional) Timeout in milliseconds. This value overrides the default timeout specified by the com.glide.hub.flow_api.default_execution_time property. After the timeout expires, an exception is thrown.
     * @example
     * 
     * (function() {
     * 	try {
     * 		var inputs = {};
     * 		inputs['current'] = ; // GlideRecord of table:  
     * 		inputs['table_name'] = 'incident';
     * 
     *               // Execute Synchronously: Run in foreground.
     *               // var timeout = ; //timeout in ms
     *               //sn_fd.FlowAPI.executeFlow('global.test_flow', inputs, timeout)
     *               sn_fd.FlowAPI.executeFlow('global.test_flow', inputs);
     * 	} catch (ex) {
     * 		var message = ex.getMessage();
     * 		gs.error(message);
     * 	}
     * })();
     * @returns  
     */
    executeFlow(name: String, inputs: Object, timeout: Number): None;

    /**
     * Run an subflow from a server-side script synchronously.Execute a subflow from within a business rule, script include, or any other server-side script. Subflows run using this method run synchronously. Use startSubflow to run an subflow asynchronously.
     * 
     * @name The scope and name of the subflow to be executed, for example global.subflow_name.
     * @inputs Inputs defined for the subflow.
     * @timeout (Optional) Timeout in milliseconds. This value overrides the default timeout specified by the com.glide.hub.flow_api.default_execution_time property. After timeout expires an exception will be thrown.
     * @example
     * 
     * (function() {
     * 	
     * 	try {
     * 		var inputs = {};
     * 		inputs['name'] = ; // String 
     * 		inputs['password2'] = ; // Password (2 Way Encrypted) 
     * 		
     * 		// Execute Synchronously: Run in foreground.
     * 		// var timeout = ; //timeout in ms
     *               //sn_fd.FlowAPI.executeSubflow('global.subflowTest', inputs, timeout)
     *               var outputs = sn_fd.FlowAPI.executeSubflow('global.subflowTest', inputs);
     * 		
     * 	} catch (ex) {
     * 		var message = ex.getMessage();
     * 		gs.error(message);
     * 	}	
     * })();
     * @returns  
     */
    executeSubflow(name: String, inputs: Object, timeout: Number): None;

    /**
     * Build password2 values inside a script step.Identify an encrypted password2 value returned from a GlideRecord, enabling the system to display the value as a masked password rather than an encrypted string.
     * 
     * @password Encrypted password2 value.
     * @example
     * 
     * (function execute(inputs, outputs) {
     * 	// ...code...
     * 	var gr = new GlideRecord('sys_user');
     * 	gr.addQuery('first_name' , 'Abel');
     * 	gr.query();
     * 	gr.next();
     * 	var pwVal = gr.getValue('pw2');
     * 	outputs['usedSetEncrypted'] = sn_fd.GlideActionUtil.setEncryptedOutput(pwVal);
     * 	outputs['justSetDirectly'] = pwVal;
     * })(inputs, outputs);
     * @returns Encrypted password2 value, recognised by the engine as a password value.
     */
    setEncryptedOutput(password: String): String;

    /**
     * Run an action from a server-side script asynchronously.Execute an action from within a business rule, script include, or any other server-side script. Actions run using this method run asynchronously, and scripts using this method does not have access to any outputs created by the action. Use executeAction to run an action synchronously and access the outputs it generates.
     * 
     * @name The scope and name of the action to be executed, for example global.action_name.
     * @inputs Inputs defined for the action.
     * @example
     * 
     * (function() {
     * 	try {
     * 		var inputs = {};
     * 		inputs['ah_task'] = myTaskRecord; // GlideRecord of table: task 
     * 		inputs['ah_comment'] ='Test Comment' ; // String 
     * 		sn_fd.FlowAPI.startAction('sn_itsm_spoke.add_comment', inputs);				
     * 	} catch (ex) {
     * 		var message = ex.getMessage();
     * 		gs.error(message);
     * 	}
     * })();
     */
    startAction(name: String, inputs: Object);

    /**
     * Run a flow from a server-side script.Execute a flow from within a business rule, script include, or any other server-side script. Flows executed with this method run asynchronously.
     * 
     * @name The scope and name of the flow to be executed, for example global.flow_name.
     * @inputs Arguments used in the flow.
     * @example
     * 
     * (function() {
     * 	try {
     * 		var inputs = {};
     * 		inputs['current'] = ; // GlideRecord of table:  
     * 		inputs['table_name'] = 'incident';
     * 
     * 		sn_fd.FlowAPI.startFlow('global.test_flow', inputs);		
     * 	} catch (ex) {
     * 		var message = ex.getMessage();
     * 		gs.error(message);
     * 	}
     * })();
     */
    startFlow(name: String, inputs: Object);

    /**
     * Run a subflow from a server-side script.Execute a subflow from within a business rule, script include, or any other server-side script. Subflows run using this method run asynchronously Scripts that include this method do not have access to outputs created by the flow. Use executeSubflow to run a subflow synchronously and access the outputs it generates.
     * 
     * @name The scope and name of the subflow to be executed, for example global.subflow_name.
     * @inputs Arguments used in the subflow.
     * @example
     * (function() {
     * 	try {
     * 		var inputs = {};
     * 		inputs['ah_task'] = myTaskRecord; // GlideRecord of table: task 
     * 		inputs['ah_comment'] ='Test Comment' ; // String 
     * 		sn_fd.FlowAPI.startSubflow('global.test_subflow', inputs);
     * 	} catch (ex) {
     * 		var message = ex.getMessage();
     * 		gs.error(message);
     * 	}
     * 	
     * })();
     */
    startSubflow(name: String, inputs: Object);

}

/**
 * FormInfoHeader allows you to add an HTML message as a form info message. The addMessage function is commonly used in record producers. * * The FormInfoHeader class is available to server-side script.
 * 
 * 
 */
declare class FormInfoHeader {



    /**
     * Adds an HTML message to the form header, where form info messages are displayed.
     * 
     * @message A message that may include HTML tags.
     * @example
     * gs.include("FormInfoHeader");
     *   var fi = new FormInfoHeader();
     *   fi.addMessage('This incident was opened on your behalf&lt;br/&gt;
     *      The IT department will contact you for further information or when the incident is resolved');
     */
    addMessage(message: String);

}

/**
 * Concrete reconciler for generic UPS alarms. Use this API for SNMP-related discovery.
 * 
 * 
 */
declare class GenericUPSAlarmsReconciler {



    /**
     * Returns the reconciliation field.
     * 
     * @returns The reconciliation field
     */
    getReconcilationField(): String;

    /**
     * Returns the reconciliation key.
     * 
     * @returns The reconciliation key
     */
    getReconcilationKey(): String;

    /**
     * Determines if the generic UPS Bypass information has changed.
     * 
     * @returns True if the information has changed; otherwise, false.
     */
    hasChanged(): Boolean;

    /**
     * Reads the database fields.
     * 
     */
    readDatabaseFields();

    /**
     * Reads the discovered information.
     * 
     */
    readDiscovered();

    /**
     * Sets the database fields.
     * 
     */
    setDatabaseFields();

}

/**
 * Concrete reconciler for generic UPS bypasses. Use this API for SNMP-related discovery.
 * 
 * 
 */
declare class GenericUPSBypassReconciler {



    /**
     * Returns the reconciliation field.
     * 
     * @returns The reconciliation field
     */
    getReconcilationField(): String;

    /**
     * Returns the reconciliation key.
     * 
     * @returns The reconciliation key
     */
    getReconcilationKey(): String;

    /**
     * Determines if the generic UPS Bypass information has changed.
     * 
     * @returns True if the information has changed; otherwise, false.
     */
    hasChanged(): Boolean;

    /**
     * Reads the database fields.
     * 
     */
    readDatabaseFields();

    /**
     * Reads the discovered information.
     * 
     */
    readDiscovered();

    /**
     * Sets the database fields.
     * 
     */
    setDatabaseFields();

}

/**
 * Concrete reconciler for generic UPS inputs. Use this API for SNMP-related discovery.
 * 
 * 
 */
declare class GenericUPSInputsReconciler {



    /**
     * Returns the reconciliation field.
     * 
     * @returns The reconciliation field
     */
    getReconcilationField(): String;

    /**
     * Returns the reconciliation key.
     * 
     * @returns The reconciliation key
     */
    getReconcilationKey(): String;

    /**
     * Determines if the generic UPS Bypass information has changed.
     * 
     * @returns True if the information has changed; otherwise, false.
     */
    hasChanged(): Boolean;

    /**
     * Reads the database fields.
     * 
     */
    readDatabaseFields();

    /**
     * Reads the discovered information.
     * 
     */
    readDiscovered();

    /**
     * Sets the database fields.
     * 
     */
    setDatabaseFields();

}

/**
 * Concrete reconciler for generic UPS outputs. Use this API for SNMP-related discovery.
 * 
 * 
 */
declare class GenericUPSOutputsReconciler {



    /**
     * Returns the reconciliation field.
     * 
     * @returns The reconciliation field
     */
    getReconcilationField(): String;

    /**
     * Returns the reconciliation key.
     * 
     */
    getReconcilationKey();

    /**
     * Determines if the generic UPS bypass information has changed.
     * 
     * @returns True if the information has changed; otherwise, false.
     */
    hasChanged(): Boolean;

    /**
     * Reads the database fields.
     * 
     */
    readDatabaseFields();

    /**
     * Reads the discovered information.
     * 
     */
    readDiscovered();

    /**
     * Sets the database fields.
     * 
     */
    setDatabaseFields();

}

/**
 * GlideAggregate enables you to easily create database aggregation queries. The GlideAggregate class is an extension of GlideRecord and provides database aggregation (COUNT, SUM, MIN, MAX, AVG) queries. This functionality can be helpful when creating customized reports or in calculations for calculated fields. The GlideAggregate class works only on number fields. * * When you use GlideAggregate on currency or price fields, you are working with the reference currency value. Be sure to convert the aggregate values to the user's session currency for display. Because the conversion rate between the currency or price value (displayed value) and its reference currency value (aggregation value) might change, the result may not be what the user expects. * * Note: When using an on-premise system, the database server time zone must be set to GMT/UTC for this class to work properly.
 * 
 * 
 */
declare class GlideAggregate {



    /**
     * Adds an aggregate.
     * 
     * @agg Name of the aggregate to add, for example, COUNT, MIN, or MAX
     * @name (Optional) Name of the column to aggregate. Null is the default.
     * @example
     * function doMyBusinessRule(assigned_to, number) {
     *   var agg = new GlideAggregate('incident');
     *   agg.addQuery('assigned_to', assigned_to);
     *   agg.addQuery('category', number);
     *   agg.addAggregate("COUNT");
     *   agg.query();
     *   var answer = 'false';
     *   if (agg.next()) {
     *     answer = agg.getAggregate("COUNT");
     *     if (answer &gt; 0)
     *       answer = 'true';
     *     else
     *       answer = 'false';
     *   }
     *   return answer; 
     * }
     */
    addAggregate(agg: String, name: String);

    /**
     * Adds an encoded query to the other queries that may have been set for this aggregate.
     * 
     * @query An encoded query string to add to the aggregate.
     * @example
     * var agg = new GlideAggregate('incident');
     * agg.addAggregate('count','category'); 
     * agg.orderByAggregate('count', 'category'); 
     * agg.orderBy('category'); 
     * agg.addQuery('opened_at', '&gt;=', 'javascript:gs.monthsAgoStart(2)'); 
     * agg.addQuery('opened_at', '&lt;=', 'javascript:gs.monthsAgoEnd(2)'); 
     * agg.query(); 
     * while (agg.next()) { 
     *   var category = agg.category;
     *   var count = agg.getAggregate('count','category');
     *   var query = agg.getQuery();  
     *   var agg2 = new GlideAggregate('incident');   
     *   agg2.addAggregate('count','category');
     *   agg2.orderByAggregate('count', 'category');
     *   agg2.orderBy('category');
     *   agg2.addQuery('opened_at', '&gt;=', 'javascript:gs.monthsAgoStart(3)');
     *   agg2.addQuery('opened_at', '&lt;=', 'javascript:gs.monthsAgoEnd(3)');
     *   agg2.addEncodedQuery(query);
     *   agg2.query();
     *   var last = "";
     *   while (agg2.next()) {
     *      last = agg2.getAggregate('count','category');      
     *   }
     *   gs.log(category + ": Last month:" + count + " Previous Month:" + last);
     *  
     * }
     */
    addEncodedQuery(query: String);

    /**
     * Adds a "having" element to the aggregate e.g. select category, count(*) from incident group by category HAVING count(*) > 5.
     * 
     * @name The aggregate to filter on for example, COUNT.
     * @operator The operator symbol for example <, >, =, !=.
     * @value The value to query on, for example '5'.
     */
    addHaving(name: String, operator: String, value: String);

    /**
     * Adds a trend for a field.
     * 
     * @fieldName The name of the field for which trending should occur.
     * @timeInterval The time interval for the trend. The following choices are available: year, quarter, date, week, month, dayofweek, hour, value.
     * @example
     * var trend = new GlideAggregate('incident');  
     * trend.addTrend ('opened_at','Month');  
     * trend.addAggregate('COUNT');  
     * trend.setGroup(false);  
     * trend.query();  
     * while(trend.next()) {  
     *    gs.print(trend.getValue('timeref') + ': ' + trend.getAggregate('COUNT'));  
     * }  
     */
    addTrend(fieldName: String, timeInterval: String);

    /**
     * Gets the value of an aggregate from the current record.
     * 
     * @agg The type of the aggregate, for example, SUM or Count.
     * @name Name of the field to get the aggregate from.
     * @example
     * function doMyBusinessRule(assigned_to, number) {
     *   var agg = new GlideAggregate('incident');
     *   agg.addQuery('assigned_to', assigned_to);
     *   agg.addQuery('category', number);
     *   agg.addAggregate("COUNT");
     *   agg.query();
     *   var answer = 'false';
     *   if (agg.next()) {
     *     answer = agg.getAggregate("COUNT");
     *     if (answer &gt; 0)
     *       answer = 'true';
     *     else
     *       answer = 'false';
     *   }
     *   return answer; 
     * }
     * @returns The value of the aggregate.
     */
    getAggregate(agg: String, name: String): String;

    /**
     * Retrieves the query necessary to return the current aggregate.
     * 
     * @example
     * var agg = new GlideAggregate('incident');
     * agg.addAggregate('count','category'); 
     * agg.orderByAggregate('count', 'category'); 
     * agg.orderBy('category'); 
     * agg.addQuery('opened_at', '&gt;=', 'javascript:gs.monthsAgoStart(2)'); 
     * agg.addQuery('opened_at', '&lt;=', 'javascript:gs.monthsAgoEnd(2)'); 
     * agg.query(); 
     * while (agg.next()) { 
     *   var category = agg.category;
     *   var count = agg.getAggregate('count','category');
     *   var query = agg.getQuery();  
     *   var agg2 = new GlideAggregate('incident');   
     *   agg2.addAggregate('count','category');
     *   agg2.orderByAggregate('count', 'category');
     *   agg2.orderBy('category');
     *   agg2.addQuery('opened_at', '&gt;=', 'javascript:gs.monthsAgoStart(3)');
     *   agg2.addQuery('opened_at', '&lt;=', 'javascript:gs.monthsAgoEnd(3)');
     *   agg2.addEncodedQuery(query);
     *   agg2.query();
     *   var last = "";
     *   while (agg2.next()) {
     *      last = agg2.getAggregate('count','category');      
     *   }
     *   gs.log(category + ": Last month:" + count + " Previous Month:" + last);
     *  
     * }
     * @returns The query.
     */
    getQuery(): String;

    /**
     * Returns the number of records by summing an aggregate.
     * 
     * @agg The aggregate
     * @name The name of the field to aggregate
     * @returns The total
     */
    getTotal(agg: String, name: String): Number;

    /**
     * Gets the value of a field.
     * 
     * @name The name of the field.
     * @returns The value of the field.
     */
    getValue(name: String): String;

    /**
     * Provides the name of a field to use in grouping the aggregates.May be called numerous times to set multiple group fields.
     * 
     * @name Name of the field.
     * @example
     *  var count = new GlideAggregate('incident');
     *   count.addAggregate('MIN', 'sys_mod_count');
     *   count.addAggregate('MAX', 'sys_mod_count');
     *   count.addAggregate('AVG', 'sys_mod_count');
     *   count.groupBy('category');
     *   count.query();   
     *   while (count.next()) {  
     *      var min = count.getAggregate('MIN', 'sys_mod_count');
     *      var max = count.getAggregate('MAX', 'sys_mod_count');
     *      var avg = count.getAggregate('AVG', 'sys_mod_count');
     *      var category = count.category.getDisplayValue();
     *      gs.log(category + " Update counts: MIN = " + min + " MAX = " + max + " AVG = " + avg);
     *   }
     */
    groupBy(name: String);

    /**
     * Provides the name of a field that should be used to order the aggregates. The field will also be added to the group-by list.
     * 
     * @name Name of the field used to order the aggregates.
     * @example
     * var agg = new GlideAggregate('incident');
     * agg.addAggregate('count','category'); 
     * agg.orderByAggregate('count', 'category'); 
     * agg.orderBy('category'); 
     * agg.addQuery('opened_at', '&gt;=', 'javascript:gs.monthsAgoStart(2)'); 
     * agg.addQuery('opened_at', '&lt;=', 'javascript:gs.monthsAgoEnd(2)'); 
     * agg.query(); 
     * while (agg.next()) { 
     *   var category = agg.category;
     *   var count = agg.getAggregate('count','category');
     *   var query = agg.getQuery();  
     *   var agg2 = new GlideAggregate('incident');   
     *   agg2.addAggregate('count','category');
     *   agg2.orderByAggregate('count', 'category');
     *   agg2.orderBy('category');
     *   agg2.addQuery('opened_at', '&gt;=', 'javascript:gs.monthsAgoStart(3)');
     *   agg2.addQuery('opened_at', '&lt;=', 'javascript:gs.monthsAgoEnd(3)');
     *   agg2.addEncodedQuery(query);
     *   agg2.query();
     *   var last = "";
     *   while (agg2.next()) {
     *      last = agg2.getAggregate('count','category');      
     *   }
     *   gs.log(category + ": Last month:" + count + " Previous Month:" + last);
     *  
     * }
     */
    orderBy(name: String);

    /**
     * Orders the aggregates based on the specified aggregate and field.
     * 
     * @agg Type of aggregation, for example SUM, COUNT, MIN, MAX.
     * @fieldName Name of the field to aggregate.
     * @example
     * var agg = new GlideAggregate('incident');
     * agg.addAggregate('count','category'); 
     * agg.orderByAggregate('count', 'category'); 
     * agg.orderBy('category'); 
     * agg.addQuery('opened_at', '&gt;=', 'javascript:gs.monthsAgoStart(2)'); 
     * agg.addQuery('opened_at', '&lt;=', 'javascript:gs.monthsAgoEnd(2)'); 
     * agg.query(); 
     * while (agg.next()) { 
     *   var category = agg.category;
     *   var count = agg.getAggregate('count','category');
     *   var query = agg.getQuery();  
     *   var agg2 = new GlideAggregate('incident');   
     *   agg2.addAggregate('count','category');
     *   agg2.orderByAggregate('count', 'category');
     *   agg2.orderBy('category');
     *   agg2.addQuery('opened_at', '&gt;=', 'javascript:gs.monthsAgoStart(3)');
     *   agg2.addQuery('opened_at', '&lt;=', 'javascript:gs.monthsAgoEnd(3)');
     *   agg2.addEncodedQuery(query);
     *   agg2.query();
     *   var last = "";
     *   while (agg2.next()) {
     *      last = agg2.getAggregate('count','category');      
     *   }
     *   gs.log(category + ": Last month:" + count + " Previous Month:" + last);
     *  
     * }
     */
    orderByAggregate(agg: String, fieldName: String);

    /**
     * Issues the query and gets the results.
     * 
     * @example
     * var agg = new GlideAggregate('incident');
     * agg.addAggregate('count','category'); 
     * agg.orderByAggregate('count', 'category'); 
     * agg.orderBy('category'); 
     * agg.addQuery('opened_at', '&gt;=', 'javascript:gs.monthsAgoStart(2)'); 
     * agg.addQuery('opened_at', '&lt;=', 'javascript:gs.monthsAgoEnd(2)'); 
     * agg.query(); 
     * while (agg.next()) { 
     *   var category = agg.category;
     *   var count = agg.getAggregate('count','category');
     *   var query = agg.getQuery();  
     *   var agg2 = new GlideAggregate('incident');   
     *   agg2.addAggregate('count','category');
     *   agg2.orderByAggregate('count', 'category');
     *   agg2.orderBy('category');
     *   agg2.addQuery('opened_at', '&gt;=', 'javascript:gs.monthsAgoStart(3)');
     *   agg2.addQuery('opened_at', '&lt;=', 'javascript:gs.monthsAgoEnd(3)');
     *   agg2.addEncodedQuery(query);
     *   agg2.query();
     *   var last = "";
     *   while (agg2.next()) {
     *      last = agg2.getAggregate('count','category');      
     *   }
     *   gs.log(category + ": Last month:" + count + " Previous Month:" + last);
     */
    query();

    /**
     * Sets whether the results are to be grouped.
     * 
     * @b Set to true if grouping is true, otherwise set to false.
     * @example
     * var ga = new GlideAggregate('incident');
     * ga.addAggregate('COUNT', 'category');
     *  
     * ga.setGroup(true);
     * 
     */
    setGroup(b: Boolean);

}

/**
 * The GlideappCalculationHelper API is a scriptable object that provides methods that add items to an existing request or request the recalculation of the price of a request. The methods for this API are used in global server-side scripts (script includes, business rules, etc.). There is currently no support for scoped applications. * * 
 * 
 * 
 */
declare class GlideappCalculationHelper {



    /**
     * Adds one or more of a specified catalog item to an existing request.
     * 
     * @requestID sys_id of the request to which to add the catalog item(s)
     * @catalogID sys_id of the catalog item to add to the request
     * @quantity Number of the specified catalog item to add to the request
     * @example
     * var catItemId = "04b7e94b4f7b4200086eeed18110c7fd";
     * var requestId = "6eed229047801200e0ef563dbb9a71c2";
     * var helper = new GlideappCalculationHelper()
     * helper.addItemToExistingRequest(requestId, catItemId, "1");
     */
    addItemToExistingRequest(requestID: String, catalogID: String, quantity: String);

    /**
     * Recalculates the price of all of the items in a specified request.
     * 
     * @requestID sys_id of the request for which to recalculate the price
     * @example
     * var catItemId = "04b7e94b4f7b4200086eeed18110c7fd";
     * var requestId = "6eed229047801200e0ef563dbb9a71c2";
     * var helper = new GlideappCalculationHelper()
     * //Add an item to the request
     * helper.addItemToExistingRequest(requestId, catItemId, "1");
     * //Re-calculate the price of the request after adding the item
     * helper.rebalanceRequest(requestId);
     */
    rebalanceRequest(requestID: String);

}

/**
 * APIs available for encrypting certificates. Use these methods to generate a hash for the certificate, sign data using a private key, and generate a message authentication code.
 * 
 * 
 */
declare class GlideCertificateEncryption {



    /**
     * Instantiates a GlideCertificateEncryption object.
     * 
     */
    constructor();

    /**
     * Generates the Message Authentication Code (MAC), which is used to authenticate a message.
     * 
     * @key Key used to sign the message.
     * @algorithm Algorithm used to generate the MAC: HmacSHA256, HmacSHA1, HmacMD5, and so on.
     * @data The data to be processed.
     * @example
     * var mac = new GlideCertificateEncryption;
     *         var key = "sample_key"; 
     *         key = GlideStringUtil.base64Encode(key);
     *         mac.generateMac("sample_key", "HmacSHA256", "sample_data");
     * @returns MAC in base64 format.
     */
    generateMac(key: String, algorithm: String, data: String): String;

    /**
     * Generates a hash (SHA-1, SHA-256, and so on) for the certificate from Trust Store Cert.
     * 
     * @certificateID sys_id of the certificate record in the X.509 Certificate [sys_certificate] table.
     * @algorithm SHA-1, SHA-256, and so on
     * @returns Thumbprint in base64 format.
     */
    getThumbPrint(certificateID: String, algorithm: String): String;

    /**
     * Generates a hash (SHA-1, SHA-256, and so on) for the certificate from the key store entry.
     * 
     * @certificateID sys_id of the certificate record in the X.509 Certificate [sys_certificate] table.
     * @alias Alias name for the certificate.
     * @algorithm SHA-1, SHA-256, and so on.
     * @returns Thumbprint in base64 format.
     */
    getThumbPrintFromKeystore(certificateID: String, alias: String, algorithm: String): String;

    /**
     * Signs the data using the private key and the given algorithm.
     * 
     * @certificateID sys_id of the certificate record in the X.509 Certificate [sys_certificate] table.
     * @alias Private key name.
     * @aliaspassword Password for the private key.
     * @datatosign Data to sign.
     * @algorithm SHA-1, SHA-256, and so on.
     * @example
     * var gce = new GlideCertificateEncryption;
     * gce.sign("recordID", "alias", "password", "SHA-1", "sign this data");
     * @returns Signed data in base64 format.
     */
    sign(certificateID: String, alias: String, aliaspassword: String, datatosign: String, algorithm: String): String;

}

/**
 * The GlideConversation API provides access to information in a Connect message. GlideConversation properties are accessed through a global object (conversation) that is available only in Connect action conditions and scripts. * * Connect conversations are stored on the Live Group Profile [live_group_profile] table.
 * 
 * 
 */
declare class GlideConversation {

    /** The conversation's description. */
    description: String
    /** The sysID of the document associated with the conversation.<p>This field is set for feed conversations, and contains the sysID of the record being
        discussed.</p> */
    document: GlideRecord
    /** The name of the conversation. */
    name: String
    /** The queue entry associated with the conversation.<p>The queue entry is a reference field pointing to the chat_queue_entry table. This field is
        only available on support conversations. The queue chat entry is used to track the state of
        the conversation. This property is not changed if an incident record is created from the
        support conversation using the <span class="keyword apiname">newRecord()</span> method.</p> */
    queueEntry: GlideRecord
    /** The sys_id of the conversation. */
    sys_id: String
    /** The name of the table containing the record being discussed.<p>This field is set for feed conversations, and is set to the table holding the record.</p> */
    table: String
    /** The conversation type.<p>This is not the message type.</p> */
    type: String


}

/**
 * The GlideDateTime class provides methods for performing operations on GlideDateTime objects, such as instantiating GlideDateTime objects or working with glide_date_time fields. Use the GlideDateTime methods to perform date-time operations, such as instantiating a GlideDateTime object, performing date-time calculations, formatting a date-time, or converting between date-time formats.
 * 
 * 
 */
declare class GlideDateTime {



    /**
     * Instantiates a new GlideDateTime object from a date and time value in the UTC time zone specified with the format yyyy-MM-dd HH:mm:ss.
     * 
     * @dateTime A UTC date and time using the format yyyy-MM-dd HH:mm:ss.
     * @example
     * var gdt = new GlideDateTime("2011-01-01 12:00:00");
     */
    constructor(dateTime: String);

    /**
     * Instantiates a new GlideDateTime object set to the time of a specified GlideDateTime object in GMT format.
     * 
     * @gDT Object used to set the time of the new object.
     * @example
     * var start = new GlideDateTime("2011-01-01 12:00:00");
     * var end = new GlideDateTime(start);
     * gs.print(end);
     */
    constructor(gDT: GlideDateTime);

    /**
     * Instantiates a new GlideDateTime object with the current date and time in GMT format.
     * 
     * @example
     * var gdt = new GlideDateTime();
     */
    constructor();

    /**
     * Adds a GlideTime object to the current GlideDateTime object.
     * 
     * @time The time to add.
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * var gtime1 = new GlideTime();
     * gtime1.setValue("00:00:20");
     * gdt.add(gtime1);
     * gs.print(gdt.getTime());
     */
    add(time: GlideTime);

    /**
     * Adds a specified number of milliseconds to the GlideDateTime object.
     * 
     * @milliseconds The number of milliseconds to add
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gs.print(gdt.getNumericValue());
     * gdt.add(10);
     * gs.print(gdt.getNumericValue());
     */
    add(milliseconds: Number);

    /**
     * Adds a specified number of days to the current GlideDateTime object. A negative parameter subtracts days.Use addDaysLocalTime() and addDaysUTC() instead of this method.
     * 
     * @days The number of days to add. Use a negative number to subtract.
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gdt.addDays(-1);
     * gs.print(gdt.getDate());
     */
    addDays(days: Number);

    /**
     * Adds a specified number of days to the current GlideDateTime object. A negative parameter subtracts days.The method determines the local date and time equivalent to the value stored by the GlideDateTime object, then adds or subtracts days using the local date and time values.
     * 
     * @days The number of days to add. Use a negative value to subtract.
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gdt.addDaysLocalTime(-1);
     * gs.print(gdt.getLocalDate());
     */
    addDaysLocalTime(days: Number);

    /**
     * Adds a specified number of days to the current GlideDateTime object. A negative parameter subtracts days.The method determines the UTC date and time equivalent to the value stored by the GlideDateTime object, then adds or subtracts days using the UTC date and time values.
     * 
     * @days The number of days to add. Use a negative value to subtract.
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gdt.addDaysUTC(-1);
     * gs.print(gdt.getDate());
     */
    addDaysUTC(days: Number);

    /**
     * Adds a specified number of months to the current GlideDateTime object. A negative parameter subtracts months.Use addMonthsLocalTime() or addMonthsUTC() instead of this method.
     * 
     * @months The number of months to add. Use a negative number to subtract.
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gdt.addMonths(2);
     * gs.print(gdt.getDate());
     */
    addMonths(months: Number);

    /**
     * Adds a specified number of months to the current GlideDateTime object. A negative parameter subtracts months.The method determines the local date and time equivalent to the value stored by the GlideDateTime object, then adds or subtracts months using the local date and time values.
     * 
     * @months The number of months to add. Use a negative value to subtract.
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gdt.addMonthsLocalTime(2);
     * gs.print(gdt.getDate());
     */
    addMonthsLocalTime(months: Number);

    /**
     * Adds a specified number of months to the current GlideDateTime object. A negative parameter subtracts months.The method determines the UTC date and time equivalent to the value stored by the GlideDateTime object, then adds or subtracts months using the UTC date and time values.
     * 
     * @months The number of months to add. Use a negative number to subtract.
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gdt.addMonthsUTC(2);
     * gs.print(gdt.getDate());
     */
    addMonthsUTC(months: Number);

    /**
     * Adds a specified number of seconds to the GlideDateTime object.
     * 
     * @seconds The number of seconds to add
     * @example
     * var gdt = new GlideDateTime("2011-12-07 08:00:00");
     * gdt.addSeconds(1000);
     * gs.print(gdt.getValue());
     */
    addSeconds(seconds: Number);

    /**
     * Adds a specified number of weeks to the current GlideDateTime object. A negative parameter subtracts weeks.Use addWeeksLocalTime() and addWeeksUTC() instead of this method.
     * 
     * @weeks The number of weeks to add. Use a negative number to subtract.
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gdt.addWeeks(-1);
     * gs.print(gdt.getDate());
     */
    addWeeks(weeks: Number);

    /**
     * Adds a specified number of weeks to the current GlideDateTime object. A negative parameter subtracts weeks.The method determines the local date and time equivalent to the value stored by the GlideDateTime object, then adds or subtracts weeks using the local date and time values.
     * 
     * @weeks The number of weeks to add. Use a negative number to subtract.
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gdt.addWeeksLocalTime(-1);
     * gs.print(gdt.getDate());
     */
    addWeeksLocalTime(weeks: Number);

    /**
     * Adds a specified number of weeks to the current GlideDateTime object. A negative parameter subtracts weeks.The method determines the UTC date and time equivalent to the value stored by the GlideDateTime object, then adds or subtracts weeks using the UTC date and time values.
     * 
     * @weeks The number of weeks to add. Use a negative number to subtract.
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gdt.addWeeksUTC(-1);
     * gs.print(gdt.getDate());
     */
    addWeeksUTC(weeks: Number);

    /**
     * Adds a specified number of years to the current GlideDateTime object. A negative parameter subtracts years.Use addYearsLocalTime() or addYearsUTC() instead of this method.
     * 
     * @years The number of years to add. Use a negative value to subtract.
     * @example
     * var gdt = new GlideDateTime("2010-08-31 08:00:00");
     * gdt.addYears(1);
     * gs.print(gdt.getDate());
     */
    addYears(years: Number);

    /**
     * Adds a specified number of years to the current GlideDateTime object. A negative parameter subtracts years.The method determines the local date and time equivalent to the value stored by the GlideDateTime object, then adds or subtracts years using the local date and time values.
     * 
     * @years The number of years to add. To subtract use a negative value.
     * @example
     * var gdt = new GlideDateTime("2010-08-31 08:00:00");
     * gdt.addYearsLocalTime(1);
     * gs.print(gdt.getDate());
     */
    addYearsLocalTime(years: Number);

    /**
     * Adds a specified number of years to the current GlideDateTime object. A negative parameter subtracts years.The date and time value stored by GlideDateTime object is interpreted as being in the UTC time zone.
     * 
     * @years The number of years to add. Use a negative value to subtract.
     * @example
     * var gdt = new GlideDateTime("2010-08-31 08:00:00");
     * gdt.addYearsUTC(1);
     * gs.print(gdt.getDate());
     */
    addYearsUTC(years: Number);

    /**
     * Compares two date and time objects to determine whether one occurs before the other or if they are equivalent.
     * 
     * @dateTime Date time in a GlideDateTime object
     * @example
     * var initDate = new GlideDateTime("2011-08-01 12:00:00");
     * var compDate1 = new GlideDateTime("2011-08-01 12:00:00");
     * var compDate2 = new GlideDateTime("2011-07-31 12:00:00");
     * var compDate3 = new GlideDateTime("2011-08-04 16:00:00");
     *  
     * gs.info(initDate.compareTo(compDate1)); // Equals (0)
     * gs.info(initDate.compareTo(compDate2)); // initDate is after compDate2 (1)
     * gs.info(initDate.compareTo(compDate3)); // initDate is before compDate3 (-1)
     * @returns  0 = Dates are equal 1 = The object's date is after the date specified in the parameter -1 = The object's date is before the date specified in the parameter 
     */
    compareTo(dateTime: Object): Number;

    /**
     * Compares an object with an existing value for equality.
     * 
     * @GDT The object to compare. Can be a GlideDateTIme object or a valid date time string.
     * @example
     * var gdt = new GlideDateTime("2011-08-31 00:00:00");
     * gs.print(gdt.equals("2011-09-30 00:12:01"));
     * @returns True if they are equal, false otherwise.
     */
    equals(GDT: Object): Boolean;

    /**
     * Gets the date stored by the GlideDateTime object, expressed in the standard format, yyyy-MM-dd, and the system time zone, UTC by default.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gs.print(gdt.getDate());
     * @returns The date in the system time zone.
     */
    getDate(): GlideDate;

    /**
     * Gets the current day of the month in the UTC time zone.Use getDayOfMonthLocalTime() and getDayOfMonthUTC() instead of this method.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-12-02 12:00:00");
     * gs.print(gdt.getDayOfMonth());
     * @returns The day of the month in the UTC time zone, from 1 to 31.
     */
    getDayOfMonth(): Number;

    /**
     * Gets the day of the month stored by the GlideDateTime object, expressed in the current user's time zone.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-12-02 12:00:00");
     * gs.print(gdt.getDayOfMonthLocalTime());
     * @returns The day of the month in the user's time zone, from 1 to 31.
     */
    getDayOfMonthLocalTime(): Number;

    /**
     * Gets the day of the month stored by the GlideDateTime object, expressed in the UTC time zone.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-12-02 12:00:00");
     * gs.print(gdt.getDayOfMonthUTC());
     * @returns The day of the month in the UTC time zone, from 1 to 31.
     */
    getDayOfMonthUTC(): Number;

    /**
     * Retrieves the day of the week stored by the GlideDateTime object, expressed in the user's time zone.Use getDayOfWeekLocalTime() and getDayOfWeekUTC() instead of this method.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-12-01 12:00:00");
     * gs.print(gdt.getDayOfWeek());
     * @returns The day of the week value - Monday = 1, ... Sunday = 7.
     */
    getDayOfWeek(): Number;

    /**
     * Gets the day of the week stored by the GlideDateTime object, expressed in the user's time zone.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-12-01 12:00:00");
     * gs.print(gdt.getDayOfWeekLocalTime());
     * @returns The day of the week value - Monday = 1, ... Sunday = 7
     */
    getDayOfWeekLocalTime(): Number;

    /**
     * Gets the day of the week stored by the GlideDateTime object, expressed in the UTC time zone.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-12-01 12:00:00");
     * gs.print(gdt.getDayOfWeekUTC());
     * @returns The day of the week value - Monday = 1, ... Sunday = 7
     */
    getDayOfWeekUTC(): Number;

    /**
     * Gets the number of days in the month stored by the GlideDateTime object, expressed in the Java Virtual Machine time zone.Use getDaysInMonthLocalTime() and getDaysInMonthUTC() instead of this method.
     * 
     * @example
     * var gdt = new GlideDateTime(); //December
     * gs.print(gdt.getDaysInMonth());
     * @returns The number of days in the current month in the Java Virtual Machine time zone.
     */
    getDaysInMonth(): Number;

    /**
     * Gets the number of days in the month stored by the GlideDateTime object, expressed in the current user's time zone.
     * 
     * @example
     * var gdt = new GlideDateTime(); //December
     * gs.print(gdt.getDaysInMonthLocalTime());
     * @returns The number of days in the current month in the user's time zone.
     */
    getDaysInMonthLocalTime(): Number;

    /**
     * Gets the number of days in the month stored by the GlideDateTime object, expressed in the UTC time zone.
     * 
     * @example
     * var gdt = new GlideDateTime(); //December
     * gs.print(gdt.getDaysInMonthUTC());
     * @returns The number of days in the month stored by the GlideDateTime object, expressed in the UTC time zone.
     */
    getDaysInMonthUTC(): Number;

    /**
     * Gets the date and time value in the current user's display format and time zone. Referring to the GlideDateTime object directly returns the date and time value in the GMT time zone.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gs.print(gdt.getDisplayValue());
     * @returns The date and time in the user's format and time zone. Keep in mind when designing business rules or script includes that this method may return values in different formats for different users.
     */
    getDisplayValue(): String;

    /**
     * Returns the display value in the internal format (yyyy-MM-dd HH:mm:ss). This method is useful for date/time fields, but not for date fields.
     * 
     * @example
     * // Wednesday
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gs.print(gdt.getDisplayValueInternal());
     * @returns The date and time values for the GlideDateTime object in the current user's time zone and the internal date and time format of yyyy-MM-dd HH:mm:ss.
     */
    getDisplayValueInternal(): String;

    /**
     * Gets the amount of time that daylight saving time is offset.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gs.print(gdt.getDSTOffset());
     * @returns Amount of time, in milliseconds, that daylight saving is offset. Returns 0 if there is no offset or if the time is not during daylight saving time.
     */
    getDSTOffset(): Number;

    /**
     * Gets the current error message.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-08-31 aa:00:00"); //bad
     * gs.print(gdt.isValid()); //false
     * gs.print(gdt.getErrorMsg()); //reason
     * @returns The error message
     */
    getErrorMsg(): String;

    /**
     * Returns the object's time in the local time zone and in the internal format.
     * 
     * @returns The object's time in the local time zone and the internal format.
     */
    getInternalFormattedLocalTime(): String;

    /**
     * Returns a date and time object set to midnight of a specified day using UTC.
     * 
     * @dayOfTheWeek The day of the week for which to return the date/time object.
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gs.print(gdt.getInternalMidnight(2));
     * @returns A GlideDateTime object set to midnight.
     */
    getInternalMidnight(dayOfTheWeek: Number): GlideDateTime;

    /**
     * Gets the date stored by the GlideDateTime object, expressed in the standard format, yyyy-MM-dd, and the current user's time zone.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gs.print(gdt.getLocalDate());
     * @returns The date in the user's time zone.
     */
    getLocalDate(): GlideDate;

    /**
     * Gets the time in the user's time zone.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gs.print(gdt.getLocalTime());
     * @returns The time in the user's time zone.
     */
    getLocalTime(): GlideTime;

    /**
     * Retrieves the month stored by the GlideDateTime object, expressed in Java Virtual Machine time zone.Use getMonthLocalTime() and getMonthUTC() instead of this method.
     * 
     * @example
     * var gdt = new GlideDateTime(); //December
     * gs.print(gdt.getMonth());
     * @returns The numerical value of the month, Jan=1, Dec=12.
     */
    getMonth(): Number;

    /**
     * Gets the month stored by the GlideDateTime object, expressed in the current user's time zone.
     * 
     * @example
     * var gdt = new GlideDateTime(); //December
     * gs.print(gdt.getMonthLocalTime());
     * @returns The numerical value of the month, Jan=1, Dec=12.
     */
    getMonthLocalTime(): Number;

    /**
     * Gets the month stored by the GlideDateTime object, expressed in the UTC time zone.
     * 
     * @example
     * var gdt = new GlideDateTime(); //December
     * gs.print(gdt.getMonthUTC());
     * @returns The numerical value of the month, Jan=1, Dec=12.
     */
    getMonthUTC(): Number;

    /**
     * Gets the number of milliseconds since January 1, 1970, 00:00:00 GMT.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gs.print(gdt.getNumericValue());
     * @returns The number of milliseconds since January 1, 1970, 00:00:00 GMT.
     */
    getNumericValue(): Number;

    /**
     * Retrieves the amount of time elapsed since the midnight of a specified day to the current time.
     * 
     * @dayOfWeek Day of week value from 1 to 7. 1 = Monday, 7=Sunday.
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00"); //Wednesday
     * var dur = new GlideDuration();
     *  
     * var span = gdt.getSpanTime(1); //how much time since Monday 00:00:00
     * dur.setValue(span);
     * gs.print(dur.getDisplayValue());
     * @returns The amount of time elapsed since midnight of the specified day. To display the result in user-friendly terms, set the value to GlideDuration.
     */
    getSpanTime(dayOfWeek: Number): GlideTime;

    /**
     * Gets the Unix duration stamp.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gs.print(gdt.getTime());
     * @returns The Unix duration stamp in system format based on GMT time.
     */
    getTime(): GlideTime;

    /**
     * Gets the time zone offset in milliseconds.
     * 
     * @example
     * var gdt = new GlideDateTime();
     * gdt.getLocalTime(); // PST local time
     * gs.print(gdt.getTZOffset());
     * @returns The number of milliseconds of the time zone offset
     */
    getTZOffset(): Number;

    /**
     * Returns the object's time in local time zone in the user's format.
     * 
     * @returns The object's time in local time and the user's format.
     */
    getUserFormattedLocalTime(): String;

    /**
     * Retrieves the time zone for the current user session.This method is equivalent to gs.getSession().getTimeZone().
     * 
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gs.print(gdt.getUserTimeZone());
     * @returns TimeZone object for the current user.
     */
    getUserTimeZone(): TimeZone;

    /**
     * Retrieves a GlideDateTime object with the time set to midnight using the UTC time zone.This method sets the date of the new GlideDateTime object as the specified day of the week within the week of the original GlideDateTime object.
     * 
     * @dayOfTheWeek The day of the week, from 1 to 7. Monday=1, Sunday=7. Do not enter 0 in this parameter.
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00"); // Wednesday, 3rd day of the week.
     * gs.print(gdt.getUTCMidnight(5)); //Friday, 5th day of the week.
     * @returns A new GlideDateTime object, set to midnight.
     */
    getUTCMidnight(dayOfTheWeek: Number): GlideDateTime;

    /**
     * Gets the date and time value stored by the GlideDateTime object in the internal format, yyyy-MM-dd HH:mm:ss, and the system time zone, UTC by default.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gs.print(gdt.getValue());
     * @returns The date and time in the internal format and system time zone.
     */
    getValue(): String;

    /**
     * Gets the number of the week stored by the GlideDateTime object, expressed in the current user's time zone.All weeks begin on Sunday. The first week of the year is the week that contains at least one day of the new year. The week beginning Sunday 2015-12-27 is considered the first week of 2016 as that week contains January 1 and 2.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-12-01 12:00:00");
     * gs.print(gdt.getWeekOfYearUTC());
     * @returns The number of the current week. The highest week number in a year is either 52 or 53.
     */
    getWeekOfYearLocalTime(): Number;

    /**
     * Gets the number of the week stored by the GlideDateTime object, expressed in the UTC time zone.All weeks begin on Sunday. The first week of the year is the week that contains at least one day of the new year. The week beginning Sunday 2015-12-27 is considered the first week of 2016 as that week contains January 1 and 2.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-12-01 12:00:00");
     * gs.print(gdt.getWeekOfYearUTC());
     * @returns The number of the current week in UTC time. The highest week number in a year is either 52 or 53.
     */
    getWeekOfYearUTC(): Number;

    /**
     * Retrieves the year stored by the GlideDateTime object, expressed in the Java Virtual Machine time zone.Use getYearLocalTime() and getYearUTC() instead of this method.
     * 
     * @example
     * var gdt = new GlideDateTime(); //2011
     * gs.print(gdt.getYear());
     * @returns The 4-digit year value in the Java Virtual Machine time zone.
     */
    getYear(): Number;

    /**
     * Gets the year stored by the GlideDateTime object, expressed in the current user's time zone.
     * 
     * @example
     * var gdt = new GlideDateTime(); //2011
     * gs.print(gdt.getYearLocalTime());
     * @returns The 4-digit year value in the user's time zone.
     */
    getYearLocalTime(): Number;

    /**
     * Gets the year stored by the GlideDateTime object, expressed in the UTC time zone.
     * 
     * @example
     * var gdt = new GlideDateTime(); //2011
     * gs.print(gdt.getYearUTC());
     * @returns The 4-digit year value in the UTC time zone.
     */
    getYearUTC(): number;

    /**
     * Determines if an object's date is set.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gs.print(gdt.hasDate());
     * @returns True if the object's date is set, false otherwise.
     */
    hasDate(): Boolean;

    /**
     * Determines if the object's time uses a daylight saving offset
     * 
     * @example
     * var gdt = new GlideDateTime("2011-08-31 00:00:00");
     * gs.print(gdt.isDST()); //true
     * @returns True if the time is daylight saving time, false otherwise.
     */
    isDST(): Boolean;

    /**
     * Determines if a value is a valid date and time.
     * 
     * @example
     * var gdt = new GlideDateTime("2011-08-31 aa:00:00"); //bad
     * gs.print(gdt.isValid()); //false
     * @returns True if value is valid, false otherwise.
     */
    isValid(): Boolean;

    /**
     * Sets the day of the month to a specified value.Use setDayOfMonthLocalTime(day) and setDayOfMonthUTC(day) instead of this method.
     * 
     * @day Day of the month, from 1 to 31.
     * @example
     * var gdt = new GlideDateTime();
     * gdt.setDayOfMonth(9);
     * gs.print(gdt.getDayOfMonth());
     */
    setDayOfMonth(day: Number);

    /**
     * Sets the day of the month to a specified value in the current user's time zone.
     * 
     * @day The day of month to change to, from 1 to 31. If this value is greater than the maximum number of days in the month, the value is set to the last day of the month.
     * @example
     * var gdt = new GlideDateTime();
     * gdt.setDayOfMonthLocalTime(9);
     * gs.print(gdt.getDayOfMonthLocalTime());
     */
    setDayOfMonthLocalTime(day: Number);

    /**
     * Sets the day of the month to a specified value in the UTC time zone.
     * 
     * @day The day of month to change to, from 1 to 31. If this value is greater than the maximum number of days in the month, the value is set to the last day of the month.
     * @example
     * var gdt = new GlideDateTime();
     * gdt.setDayOfMonthUTC(9);
     * gs.print(gdt.getDayOfMonthUTC());
     */
    setDayOfMonthUTC(day: Number);

    /**
     * Sets a date and time value using the current user's display format and time zone.
     * 
     * @asDisplayed The date and time in the current user's display format and time zone. The parameter must be formatted using the current user's preferred display format, such as MM-dd-yyyy HH:mm:ss. To assign the current date and time to a variable in a workflow script, use &lt;variable&gt;.setDisplayValue(gs.nowDateTime);.
     * @example
     * var gdt = new GlideDateTime("2011-02-02 12:00:00");
     * gdt.setDisplayValue("2011-01-01 12:00:00");
     * gs.print(gdt.getValue());
     */
    setDisplayValue(asDisplayed: String);

    /**
     * Sets a date and time value using the current user's time zone and the specified date and time format.This method throws a runtime exception if the date and time format used in the dateTime parameter does not match the format parameter. You can retrieve the error message by calling getErrorMsg() on the GlideDateTime object after the exception is caught.
     * 
     * @dateTime The date and time in the current user's time zone.
     * @format The format to use to parse the dateTime parameter.
     * @example
     * var gdt = new GlideDateTime("2011-02-02 12:00:00");
     * gdt.setDisplayValue("20-5-2011 12:00:00", "dd-MM-yyyy HH:mm:ss");
     * gs.print(gdt.getValue());
     */
    setDisplayValue(dateTime: String, format: String);

    /**
     * Sets a date and time value using the internal format (yyyy-MM-dd HH:mm:ss) and the current user's time zone.
     * 
     * @dateTime The date and time in internal format
     * @example
     * var gdt = new GlideDateTime("2011-02-02 12:00:00");
     * gdt.setDisplayValueInternal("2011-01-01 12:00:00");
     * gs.print(gdt.getValue());
     */
    setDisplayValueInternal(dateTime: String);

    /**
     * Sets a date and time value using the internal format (yyyy-MM-dd HH:mm:ss) and the current user's time zone.This method attempts to parse incomplete date and time values.
     * 
     * @dateTime The date and time in internal format.
     */
    setDisplayValueInternalWithAlternates(dateTime: String);

    /**
     * Sets the date and time of the current object using an existing GlideDateTime object.This method is equivalent to instantiating a new object with a GlideDateTime parameter.
     * 
     * @gDT A GlideDateTime object
     * @example
     * var dt1 = new GlideDateTime("2011-01-01 12:00:00");
     * var dt2 = new GlideDateTime("2011-02-02 08:00:00");
     * dt1.setGlideDateTime(dt2);
     * gs.print(dt1.getValue());
     */
    setGlideDateTime(gDT: GlideDateTime);

    /**
     * Sets the date and time.This method is equivalent to setValue(Object).
     * 
     * @dateTime The date and time to use. Accepts either a string in the GMT time zone in the internal format, or a GlideDateTime object.
     * @example
     * var gdt = new GlideDateTime();
     * gdt.setInitialValue("2011-01-01 12:00:00");
     * gs.print(gdt.getValue());
     */
    setInitialValue(dateTime: String);

    /**
     * Sets the month stored by the GlideDateTime object to a specified value using the Java Virtual Machine time zone.Use setMonthLocalTime() or setMonthUTC() instead of this method.
     * 
     * @month The month to change to.
     * @example
     * var gdt = new GlideDateTime();
     * gdt.setMonth(1);
     * gs.print(gdt.getMonth());
     */
    setMonth(month: Number);

    /**
     * Sets the month stored by the GlideDateTime object to a specified value using the current user's time zone.
     * 
     * @month The month to change to.
     * @example
     * var gdt = new GlideDateTime();
     * gdt.setMonthLocalTime(1);
     * gs.print(gdt.getMonthLocalTime());
     */
    setMonthLocalTime(month: Number);

    /**
     * Sets the month stored by the GlideDateTime object to a specified value using the UTC time zone.
     * 
     * @month The month to change to.
     * @example
     * var gdt = new GlideDateTime();
     * gdt.setMonthUTC(1);
     * gs.print(gdt.getMonthUTC());
     */
    setMonthUTC(month: Number);

    /**
     * Sets the date and time to the number of milliseconds since January 1, 1970 00:00:00 GMT.
     * 
     * @milliseconds Number of milliseconds
     * @example
     * var gdt = new GlideDateTime();
     * gdt.setNumericValue(1314777600000);
     * gs.print(gdt.getValue());
     */
    setNumericValue(milliseconds: Number);

    /**
     * Sets the time zone of the GlideDateTime object to be the specified time zone.
     * 
     * @timeZone A time zone object
     * @example
     * var tz = gs.getSession().getTimeZone();
     * var gdt = new GlideDateTime(); 
     * gdt.setTZ(tz);
     */
    setTZ(timeZone: TimeZone);

    /**
     * Sets the date and time of the GlideDateTime object.This method is equivalent to setInitialValue().
     * 
     * @dateTime The date and time to use. This parameter may be one of several types. A string in the UTC time zone and the internal format of yyyy-MM-dd HH:mm:ss: Sets the value of the object to the specified date and time. Using the method this way is equivalent to instantiating a new GlideDateTime object using the GlideDateTime(value) constructor. If the date and time format used does not match the internal format, the method attempts to set the date and time using other available formats. Resolving the date and time this way can lead to inaccurate data due to ambiguity in the day and month values. When using a non-standard date and time format, use setValue(dt, format) instead. A GlideDateTime object: Sets the value of the object to the date and time stored by the GlideDateTime passed in the parameter. Using the method this way is equivalent to instantiating a new GlideDateTime object using the GlideDateTime(g) constructor. A Java Date object: Sets the value of the object using the value stored by the Java Date object. Using the method this way is equivalent to passing the value returned by the Java Date object getTime() to the GlideDateTime setNumericValue() method. This method does not accept JavaScript Date objects. A JavaScript Number: Sets the value of the object using the Number value as milliseconds past January 1, 1970 00:00:00 GMT. Using the method this way is equivalent to the setNumericValue(milliseconds) method. A Java Integer or Long: Sets the value of the object using the Integer or Long value as milliseconds past January 1, 1970 00:00:00 GMT. Using the method this way is equivalent to the setNumericValue(milliseconds) method. 
     * @example
     * var gdt = new GlideDateTime("2011-01-01 12:00:00");
     * gdt.setValue("2011-02-02 08:00:00");
     * gs.print(gdt.getValue());
     */
    setValue(dateTime: Object);

    /**
     * Sets a date and time value using the UTC time zone and the specified date and time format.This method throws a runtime exception if the date and time format used in the dateTime parameter does not match the format parameter. You can retrieve the error message by calling getErrorMsg() on the GlideDateTime object after the exception is caught.
     * 
     * @dateTime The date and time to use.
     * @format The format to use.
     * @example
     * var gdt = new GlideDateTime("2011-01-01 12:00:00");
     * gdt.setValueUTC("15-02-2011 08:00:00", "dd-MM-yyyy HH:mm:ss");
     * gs.print(gdt.getValue());
     */
    setValueUTC(dateTime: String, format: String);

    /**
     * Sets the year stored by the GlideDateTime object to a specified value using the Java Virtual Machine time zone.Use setYearLocalTime() or setYearUTC() instead of this method.
     * 
     * @year The year to change to.
     * @example
     * var gdt = new GlideDateTime();
     * gdt.setYear(2013);
     * gs.print(gdt.getYear());
     */
    setYear(year: Number);

    /**
     * Sets the year stored by the GlideDateTime object to a specified value using the current user's time zone.
     * 
     * @year The year to change to.
     * @example
     * var gdt = new GlideDateTime();
     * gdt.setYearLocalTime(2013);
     * gs.print(gdt.getYearLocalTime());
     */
    setYearLocalTime(year: Number);

    /**
     * Sets the year stored by the GlideDateTime object to a specified value using the UTC time zone.
     * 
     * @year The year to change to.
     * @example
     * var gdt = new GlideDateTime();
     * gdt.setYearUTC(2013);
     * gs.print(gdt.getYearUTC());
     */
    setYearUTC(year: Number);

    /**
     * Gets the duration difference between two GlideDateTime values.
     * 
     * @start The start value
     * @end The end value
     * @example
     * var gdt1 = new GlideDateTime("2011-08-28 09:00:00");
     * var gdt2 = new GlideDateTime("2011-08-31 08:00:00");
     * var dur = new GlideDuration();
     *  
     * var dur = GlideDateTime.subtract(gdt1, gdt2); //the difference between gdt1 and gdt2
     * gs.print(dur.getDisplayValue());
     * @returns The time between the two values
     */
    subtract(start: GlideDateTime, end: GlideDateTime): GlideDuration;

    /**
     * Subtracts a specified amount of time.
     * 
     * @time The time to subtract
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * var gtime1 = new GlideTime();
     * gtime1.setValue("00:00:20");
     * gdt.subtract(gtime1);
     * gs.print(gdt.getTime());
     */
    subtract(time: GlideTime);

    /**
     * Subtracts a specified number of milliseconds from the GlideDateTime object.
     * 
     * @milliseconds The number of milliseconds to subtract
     * @example
     * var gdt = new GlideDateTime("2011-12-07 08:00:00");
     * gdt.subtract(1000);
     * gs.print(gdt.getValue());
     */
    subtract(milliseconds: Number);

    /**
     * Returns the date and time value stored by the GlideDateTime object in the internal format, yyyy-MM-dd HH:mm:ss, and the system time zone, UTC by default.This method is equivalent to getValue().
     * 
     * @example
     * var gdt = new GlideDateTime("2011-08-31 08:00:00");
     * gs.print(gdt.toString());
     * @returns The date and time stored by the GlideDateTime object in the system time zone and format.
     */
    toString(): String;

}

/**
 * The GlideElement API provides a number of convenient script methods for dealing with fields and their values. GlideElement methods are available for the fields of the current GlideRecord. 
 * 
 * 
 */
declare class GlideElement {



    /**
     * Determines if the user's role permits the creation of new records in this field.
     * 
     * @returns True if the field can be created, false otherwise.
     */
    canCreate(): Boolean;

    /**
     * Determines whether the user's role permits them to read the associated GlideRecord.
     * 
     * @returns True if the field can be read, false otherwise.
     */
    canRead(): Boolean;

    /**
     * Determines whether the user's role permits them to write to the associated GlideRecord.
     * 
     * @returns True if the user can write to the field, false otherwise.
     */
    canWrite(): Boolean;

    /**
     * Determines if the current field has been modified. This functionality is available for all available data types, except Journal fields.Note: The changes() method is not supported within ACL scripts.
     * 
     * @returns True if the field has changed, false otherwise.
     */
    changes(): Boolean;

    /**
     * Determines if the previous value of the current field matches the specified object.Note: If the GlideRecord on which you are performing this method has only been initialized and read, and has not been written, the underlying before-and-after values are the same. In this case, the method returns "false", as there has been no change to the data store.
     * 
     * @value An object value to check against the previous value of the current field.
     * @example
     * if (theState.changesTo(resolvedState)) {
     *   operation = 4; //Resolved
     * }
     * else if (theState.changesTo(closedState)) {
     *   operation = 11; //Resolution Accepted
     * }
     * else if (theState.changesFrom(resolvedState) || theState.changesFrom(closedState)) {
     *   operation = 10; //Re-open
     * }
     * else {
     *   operation = 6; //Update
     * }
     * @returns True if the previous value matches the parameter, false if it does not.
     */
    changesFrom(value: Object): Boolean;

    /**
     * Determines if the new value of a field, after a change, matches the specified object.
     * 
     * @value An object value to check against the new value of the current field.
     * @example
     * if (theState.changesTo(resolvedState)) {
     *   operation = 4; //Resolved
     * }
     * else if (theState.changesTo(closedState)) {
     *   operation = 11; //Resolution Accepted
     * }
     * else if (theState.changesFrom(resolvedState) || theState.changesFrom(closedState)) {
     *   operation = 10; //Re-open
     * }
     * else {
     *   operation = 6; //Update
     * }
     * @returns True if the new value matches the parameter, false if it does not.
     */
    changesTo(value: Object): Boolean;

    /**
     * Debugs the object and adds debug messages using setError(String).
     * 
     * @o An object to debug.
     */
    debug(o: Object);

    /**
     * Returns the value of the specified attribute from the dictionary.If the attribute is a boolean attribute, use getBooleanAttribute(String) to get the value as a boolean rather than as a string.
     * 
     * @attributeName Attribute name
     * @example
     * doit();
     * function doit() {
     *   var gr = new GlideRecord('sys_user');
     *   gr.query("user_name","admin");
     *   if (gr.next()) {
     *     gs.print("we got one");
     *     gs.print(gr.location.getAttribute("tree_picker"));
     *   }
     *  
     * }
     * @returns Attribute value
     */
    getAttribute(attributeName: String): String;

    /**
     * Gets the base table of the field.
     * 
     * @returns Name of the base table. This may be different from the table that the field is defined on. See "Tables and Classes" in the product documentation.
     */
    getBaseTableName(): String;

    /**
     * Returns the Boolean value of the specified attribute from the dictionary.To get the value as a string, use getAttribute(string).
     * 
     * @attributeName Attribute name
     * @returns Boolean value of the attribute. Returns false if the attribute does not exist.
     */
    getBooleanAttribute(attributeName: String): Boolean;

    /**
     * Generates a choice list for a field. Returns the choice values from the base table only, not from the extended table.
     * 
     * @value An optional dependent value.
     * @returns The choice values for the field.
     */
    getChoices(value: String): arraylist;

    /**
     * Gets the choice label for the current choice value.
     * 
     * @returns The choice label.
     */
    getChoiceValue(): String;

    /**
     * Gets the number of debug messages logged by debug().
     * 
     * @returns The number of debug messages.
     */
    getDebugCount(): Number;

    /**
     * Checks whether or not the field is dependent on another field.
     * 
     * @returns Name of the field on which the current field depends.
     */
    getDependent(): String;

    /**
     * Gets the table that the current table depends on.
     * 
     * @returns The name of the table.
     */
    getDependentTable(): String;

    /**
     * Gets the formatted display value of the field.
     * 
     * @maxChar Optional, maximum number of characters to return.
     * @example
     * var fields = current.getFields();
     * for (var i = 0; i &lt; fields.size(); i++) { 
     *   var field = fields.get(i);
     *   var name = field.getName(); 
     *   var value = field.getDisplayValue(); 
     *   gs.print(i + ". " + name + "=" + value); 
     * }
     * @returns Display value of the field.
     */
    getDisplayValue(maxChar: Number): String;

    /**
     * Gets the formatted display value of a field, or a specified substitute value if the display value is null or empty.
     * 
     * @maxChar Optional, the maximum number of characters to be returned.
     * @nullSub The value to return if the display value is null or empty.
     * @returns The formatted display value of the field, or the specified substitute value.
     */
    getDisplayValueExt(maxChar: Number, nullSub: String): String;

    /**
     * Returns an element descriptor.
     * 
     * @example
     * var fields = current.getFields();
     * for (i=0; i&lt;fields.size(); i++) { 
     *   var field = fields.get(i);
     *   var descriptor = field.getED(); 
     *   gs.print("type=" + descriptor.getType() + 
     *     " internalType=" + descriptor.getInternalType()); 
     * }
     * @returns The field's element descriptor.
     */
    getED(): ElementDescriptor;

    /**
     * Gets the value for a given element.
     * 
     * @value An element
     * @returns The value of the element.
     */
    getElementValue(value: String): String;

    /**
     * Gets error debug messages.
     * 
     * @returns A string of debug messages
     */
    getError(): String;

    /**
     * Gets the escaped value for the current element.
     * 
     * @returns The escaped value of the current element.
     */
    getEscapedValue(): String;

    /**
     * Gets the CSS style for the field.
     * 
     * @example
     * var fields = current.getFields();
     * for (var i = 0; i &lt; fields.size(); i++) { 
     *   var field = fields.get(i);
     *   var name = field.getName(); 
     *   var value = field.getDisplayValue(); 
     *   gs.print(i + ". " + name + "=" + value); 
     * }
     * @returns The CSS style for the field.
     */
    getFieldStyle(): String;

    /**
     * Gets a glide object.
     * 
     * @example
     * function calcDateDelta(start, end, calendar) {
     *   var cal = GlideCalendar.getCalendar(calendar);
     *   if (!cal.isValid())
     *       return null;
     *   var realStart = start.getGlideObject();
     *   var realEnd = end.getGlideObject();  
     *   var duration = cal.subtract(realStart, realEnd);
     *   return duration;
     * }
     * @returns A Glide object.
     */
    getGlideObject(): Object;

    /**
     * Gets a glide record.
     * 
     * @example
     * function task_ci_allocate() {
     *    var cnt = g_list.getRowCount();
     *    if (cnt == 0)
     *       return;
     *  
     *    var pct = 100.0 / cnt;
     *    var pct = (parseInt((pct + .005) * 100)) / 100;
     *    var gr = g_list.getGlideRecord();
     *    gr.query();
     *    while (gr.next()) {
     *       gr.u_allocation = pct;
     *       gr.update();
     *    }
     * }
     * @returns A glide record
     */
    getGlideRecord(): GlideRecord;

    /**
     * Returns the HTML value of a field.
     * 
     * @maxChars Optional. Maximum number of characters to return.
     * @example
     * var inccause = new GlideRecord("incident");
     * inccause.short_description = current.short_description;
     * inccause.comments = current.comments.getHTMLValue();
     * inccause.insert();
     * @returns HTML value for the field.
     */
    getHTMLValue(maxChars: Number): String;

    /**
     * Returns the HTML value of a field, or a specified substitute value if the HTML value is null or empty.
     * 
     * @maxChar The maximum number of characters to return.
     * @nullSub The value to return if the HTML value is null or empty.
     * @returns The HTML value or the specified substitute value.
     */
    getHTMLValueExt(maxChar: Number, nullSub: String): String;

    /**
     * Returns either the most recent journal entry or all journal entries.
     * 
     * @mostRecent If 1, returns the most recent entry. If -1, returns all journal entries.
     * @example
     * //gets all journal entries as a string where each entry is delimited by '\n\n'
     * var notes = current.work_notes.getJournalEntry(-1); 
     * //stores each entry into an array of strings
     * var na = notes.split("\n\n");  
     *                       
     * for (var i = 0; i &lt; na.length; i++)                 
     *   gs.print(na[i]);
     * @returns For the most recent entry, returns a string that contains the field label, timestamp, and user display name of the journal entry. For all journal entries, returns the same information for all journal entries ever entered as a single string with each entry delimited by "\n\n".
     */
    getJournalEntry(mostRecent: Number): String;

    /**
     * Returns the object's label.
     * 
     * @example
     * var gr = new GlideRecord("sc_req_item");
     * gr.addQuery("request", current.sysapproval);
     * gr.query();
     * while(gr.next()) {
     *     var nicePrice = gr.price.toString();
     *     if (nicePrice != ) {
     *         nicePrice = parseFloat(nicePrice);
     *         nicePrice = nicePrice.toFixed(2);
     *     }
     *     template.print(gr.number + ":  " + gr.quantity + " X " + gr.cat_item.getDisplayValue() + " at $" + nicePrice + " each \n");
     *     template.print("    Options:\n");
     *     var variables = gr.variables.getElements();    
     *     for (var index in variables) {
     *       var v = variables [key];
     *       if(v.getQuestion().getLabel() != ) {
     *          template.space(4);
     *          template.print('     ' +  v.getQuestion().getLabel() + " = " + v.getDisplayValue() + "\n");  
     *       }
     *     }
     * }
     * @returns Object's label
     */
    getLabel(): String;

    /**
     * Returns the name of the field.
     * 
     * @returns Field name
     */
    getName(): String;

    /**
     * Returns a GlideRecord object for a given reference element.
     * 
     * @example
     * 
     * var grINC = new GlideRecord('incident'); 
     * grINC.notNullQuery('caller_id'); 
     * grINC.query(); 
     * if (grINC.next()) { 
     * 
     * // Get a GlideRecord object for the referenced sys_user record 
     * var grUSER = grINC.caller_id.getRefRecord(); 
     * if (grUSER.isValidRecord()) 
     *   gs.print( grUSER.getValue('name') ); 
     * 
     * } 
     * @returns A GlideRecord object
     */
    getRefRecord(): GlideRecord;

    /**
     * Get the CSS style for the value.
     * 
     * @example
     * // Get string of style field from Field Style record
     * var cssStyle = gr.state.getStyle();
     * @returns The CSS style for the value.
     */
    getStyle(): String;

    /**
     * Returns the name of the field's table.
     * 
     * @example
     * if (current.approver.getTableName() == "sysapproval_approver") {
     *   if (current.approver == email.from_sys_id)  {
     *      current.comments = "reply from: " + email.from + "\n\n" + email.body_text;
     *  
     *    // if it's been cancelled, it's cancelled.
     *   var doit = true;
     *   if (current.state=='cancelled')
     *       doit = false;
     *  
     *   if (email.body.state != undefined)
     *      current.state= email.body.state;
     *  
     *    if (doit)
     *       current.update();
     * } else {
     *    gs.log("Approval for task ("+current.sysapproval.getDisplayValue()+") rejected because user sending 
     *            email( "+email.from+") does not match the approver ("+current.approver.getDisplayValue()+")");
     * }
     *  
     * }
     * @returns Name of the table. This may be different from the table Class that the record is in. See Tables and Classes in the product documentation.
     */
    getTableName(): String;

    /**
     * Retrieves the value and escapes the HTML.
     * 
     * @returns The escaped HTML
     */
    getTextAreaDisplayValue(): String;

    /**
     * Retrieves the XHTML value of a field.
     * 
     * @returns The XHTML value
     */
    getXHTMLValue(): String;

    /**
     * Gets the XML value of a field as a string.
     * 
     * @returns The XML value
     */
    getXMLValue(): String;

    /**
     * Determines whether a field has a particular attribute.
     * 
     * @attributeName The attribute to check for
     * @example
     * var totalCritical = 0;
     *  
     * var filledCritical = 0; var fields = current.getFields(); gs.print(fields); for (var num = 0; num &amp;lt; fields.size(); num++) { 
     *  
     *     gs.print("RUNNING ARRAY VALUE " + num);
     *    var ed = fields.get(num).getED();
     *    if(ed.hasAttribute("tiaa_critical")) {
     *        gs.print("CRITICAL FIELD FOUND");
     *        totalCritical ++;
     *        if (!fields.get(num).isNil()) {
     *            filledCritical ++;
     *        }
     *    }
     *  
     * } var answer = 0; gs.print("TOTAL - " + totalCritical); gs.print("FILLED - " + filledCritical); if (filledCritical &amp;gt; 0 &amp;amp;&amp;amp; totalCritical &amp;gt; 0){ 
     *  
     *     var pcnt = (filledCritical/totalCritical)*100;
     *    answer = pcnt.toFixed(2);;    
     *  
     * } answer;
     * @returns True if the field has the attribute, false otherwise.
     */
    hasAttribute(attributeName: String): Boolean;

    /**
     * Determines if the user has the right to perform a particular operation.
     * 
     * @operationName Name of the operation to check for
     * @returns True if the user has permission to perform the operation, false otherwise.
     */
    hasRightsTo(operationName: String): Boolean;

    /**
     * Determines if the field has a value.
     * 
     * @returns True if the field has a value, false otherwise.
     */
    hasValue(): Boolean;

    /**
     * Determines whether the field is null.
     * 
     * @example
     * if (current.start_date.changes() || current.end_date.changes() || current.assigned_to.changes()) { 
     *   if (!current.start_date.nil() &amp;&amp; !current.end_date.nil() &amp;&amp; !current.assigned_to.nil()) {
     *  gs.eventQueue("change.calendar.notify", current, current.assigned_to, previous.assigned_to);
     *  
     * }
     * @returns True if the field is null or an empty string, false otherwise.
     */
    nil(): Boolean;

    /**
     * Sets the display value of the field.
     * 
     * @displayValue Value to be displayed.
     */
    setDisplayValue(displayValue: Object);

    /**
     * Adds an error message.Can be retrieved using getError().
     * 
     * @example
     * if ((!current.u_date1.nil()) &amp;&amp; (!current.u_date2.nil())) {
     *   var start = current.u_date1.getGlideObject().getNumericValue();
     *   var end = current.u_date2.getGlideObject().getNumericValue();
     *   if (start &gt; end) {
     *     gs.addInfoMessage('start must be before end');
     *     current.u_date1.setError('start must be before end');
     *     current.setAbortAction(true);
     *   }
     * }
     */
    setError();

    /**
     * Sets the initial value of a field.
     * 
     * @value Initial value for the field.
     */
    setInitialValue(value: String);

    /**
     * Sets the journal entry.
     * 
     * @value The value to set the journal entry to.
     * @userName The user to attribute the journal entry to. Does not set the journal entry's created by field.
     */
    setJournalEntry(value: Object, userName: String);

    /**
     * Sets the value of a field.
     * 
     * @value The value the field is to be set to.
     * @example
     * // Using GlideElement.setValue (equivalent to GlideRecord.setValue)
     * gr.short_description.setValue('This is the short description.');
     *  
     * // Using GlideRecord.setValue
     * gr.setValue('short_description', 'This is the short description.');
     */
    setValue(value: Object);

    /**
     * Converts the field's value to a string.
     * 
     * @example
     * doit();
     *  
     * function doit() { 
     *  
     *   var gr = new GlideRecord('sys_user');
     *   gr.query();
     *   while (gr.next()) {
     *     if ((gr.first_name.toString().length != gr.first_name.toString().trim().length) || (gr.last_name.toString().length 
     *          != gr.last_name.toString().trim().length)) {
     *       gr.first_name = gr.first_name.toString().trim();
     *       gr.last_name = gr.last_name.toString().trim();
     *       gr.autoSysFields(false);
     *       gr.update();
     *     }
     *   }
     *  
     * }
     * @returns The field's value as a string.
     */
    toString(): String;

}

/**
 * GlideEncrypter provides methods to encrypt and decrypt strings using the Triple DES algorithm. The GlideEncrypter class is used in server scripts in the global scope. The GlideEncrypter class has two constructors: GlideEncrypter() GlideEncrypter(String key) 
 * 
 * 
 */
declare class GlideEncrypter {



    /**
     * Creates an instance of the GlideEncrypter class using a given encryption key.
     * 
     * @key Your encryption key must be exactly 24 characters. A key longer than 24 characters will be truncated.
     * @example
     * var encr = new GlideEncrypter(myKey); 
     */
    constructor(key: String);

    /**
     * Creates an instance of the GlideEncrypter class using a default (static) encryption key.
     * 
     * @example
     * var encr = new GlideEncrypter(); 
     */
    constructor();

    /**
     * Decrypts a clear string using the Triple DES algorithm.
     * 
     * @encryptedString String to be decrypted.
     * @example
     * var encr = new GlideEncrypter(); 
     * var clearString = 'abcdefg'; 
     * var encrString = encr.encrypt(clearString);
     * var decrString = encr.decrypt(encrString);  
     * gs.print("Decrypted string = " + decrString);
     * @returns Clear text string.
     */
    decrypt(encryptedString: String): String;

    /**
     * Encrypts a clear string using the Triple DES algorithm.
     * 
     * @clearString String to be encrypted.
     * @example
     * var encr = new GlideEncrypter(); 
     * var clearString = 'abcdefg'; 
     * var encrString = encr.encrypt(clearString); 
     * gs.print("Encrypted string = " + encrString); 
     * 
     * @returns Encrypted string.
     */
    encrypt(clearString: String): String;

}

/**
 * The global GlideImpersonate API enables administrators to pose as another authenticated user for testing purposes. Use the GlideImpersonate API when you need to act as another user so to test functionality within your application. When impersonating another user, the administrator has access to exactly what the impersonated user would have access to in the system, including the same menus and modules. Note: The system records anything the administrator does while impersonating another user as having been done by that user. * * 
 * 
 * 
 */
declare class GlideImpersonate {



    /**
     * Verifies whether the specified user can perform debugging on scripts.In order for a user to be able to debug scripts, they must be on a developer instance. Debugging is not allowed on production instances.
     * 
     * @userSysId sys_Id of the user to verify for debugging capability.
     * @example
     * userDebug: function(userId) {
     *   var impUser = new GlideImpersonate();
     *   impUser.canDebug(userId);
     *  }
     * @returns True: User is able to debug the application. False: User is not able to debug the application.
     */
    canDebug(userSysId: String): Boolean;

    /**
     * Verifies whether the current user can impersonate the specified user.If the current user is not assigned the admin role, the user to impersonate is inactive, or there are other issues with impersonating the specified user, the method returns "false" and the user cannot be impersonated.
     * 
     * @userSysId sys_Id of the user to impersonate
     * @example
     * function onlineImpersonate(userSysId) {
     *     if (!GlideImpersonate().canImpsersonate(userSysId)){
     *         gs.addInfoMessage("No access to impersonate " + userSysId);
     *     } else {
     *         GlideImpersonate().impersonate(userSysId);
     *     }
     *     return;
     * }
     * @returns True: Current user can impersonate the specified user.False: Current user cannot impersonate the specified user.
     */
    canImpersonate(userSysId: String): Boolean;

    /**
     * Sets the user ID for the current administrator to the passed-in user ID, enabling the administrator to act as that user.When impersonating another user, the administrator has access to exactly what the impersonated user would have access to in the system, including the same menus and modules. Only use this method when testing functionality in an application. Ensure that once you are finished impersonating a user that you call the method again with the administrator sys_Id to stop the impersonation.
     * 
     * @userSysId sys_id of the user to impersonate
     * @example
     * impersonateUser: function(userId) {
     *   var impUser = new GlideImpersonate();
     *   impUser.impersonate(userId);
     *  }
     * @returns sys_id of the user that was logged in prior to the impersonation request
     */
    impersonate(userSysId: String): String;

    /**
     * Determines whether the current user is impersonating another user.
     * 
     * @example
     * function abortOnImpersonate() {
     *     if (GlideImpersonate().isImpersonating()){
     *   current.setAbortAction(true);
     *   gs.addInfoMessage("Transaction canceled due to Impersonation");
     *     }
     *     return;
     * }
     * @returns True: User is currently impersonating another user.False: User is not currently impersonating another user.
     */
    isImpersonating(): Boolean;

}

/**
 * Create a list and set list properties. For example, define whether a list has a filter, breadcrumbs, and search. Use GlideListProperties in global server-side scripts. To use this class, instantiate a GlideListProperties object using the constructor. * * For an example of this class in the base system, configure a list and select All. The tabbed list of options uses the personalize_all UI page and personalize_all_list UI macro to set list properties such as title, context menu, and breadcrumbs.
 * 
 * 
 */
declare class GlideListProperties {



    /**
     * Instantiates a GlideListProperties object.
     * 
     * @example
     * var list = new GlideListProperties();
     * 
     */
    constructor();

    /**
     * Returns the unique ID for a list.
     * 
     * @example
     * var list = new GlideListProperties();
     * var getID = list.getListID();
     * gs.print(getID);
     * @returns Unique ID for the list
     */
    getListID(): String;

    /**
     * Returns the name of the list.
     * 
     * @example
     * var list = new GlideListProperties();
     * var setName = list.setListName("my custom list");
     * var getName = list.getListName();
     * gs.print(getName);
     * @returns Name of the list.
     */
    getListName(): String;

    /**
     * Get the title of a list.
     * 
     * @example
     * var list = new GlideListProperties();
     * var title = list.setTitle("My title");
     * var getTitle = list.getTitle();
     * gs.print(getTitle);
     * @returns The title of the list.
     */
    getTitle(): String;

    /**
     * Returns whether or not the Actions on select rows option is enabled for a list.
     * 
     * @example
     * var list = new GlideListProperties();
     * var actions = list.setHasActions(true);
     * var hasActions = list.hasActions();
     * gs.print(hasActions);
     * @returns Returns true if the actions option is enabled for a list.
     */
    hasActions(): Boolean;

    /**
     * Returns whether or not a list has navigation at the bottom.
     * 
     * @example
     * var lp = new GlideListProperties();
     * var Nav = lp.setHasBottomNav(true);
     * var hasNav = lp.hasBottomNav();
     * gs.print(hasNav);
     * @returns If returns true the list has bottom navigation.
     */
    hasBottomNav(): Boolean;

    /**
     * Returns whether or not the page navigation controls appear in the footer of a list.
     * 
     * @example
     * var list = new GlideListProperties();
     * var vcr = list.setHasBottomVCR(true);
     * var hasVCR = list.hasBottomVCR();
     * gs.print(hasVCR);
     * @returns If true the page navigation controls appear in the footer of a list.
     */
    hasBottomVCR(): Boolean;

    /**
     * Returns whether or not a list has a filter.The filter property is a parent of the breadcrumbs property. If the filter property is listed as false and the breadcrumb is listed as true, hasFilter() still returns true because the child property is marked as true.
     * 
     * @example
     * var list = new GlideListProperties();
     * var filter = list.setHasFilter(true);
     * var breadcrumbs = list.setHasBreadcrumbs(true);
     * var hasFilter = list.hasFilter();
     * gs.print(hasFilter);
     * 
     * @returns If true a filter icon appears with the list, or the breadcrumb property is listed as true. If false both the filter property and the breadcrumb property are marked as false.
     */
    hasFilter(): Boolean;

    /**
     * Returns whether or not a list has a header.
     * 
     * @example
     * var list = new GlideListProperties();
     * var header = list.setHasHeader(true);
     * var hasHeader = list.hasHeader();
     * gs.print(hasHeader);
     * @returns Returns true if a list has a header.
     */
    hasHeader(): Boolean;

    /**
     * Returns whether or not a header context menu is enabled for a list.
     * 
     * @example
     * var list = new GlideListProperties();
     * var header = list.setHasHeaderContextMenu(true);
     * var hasHeader = list.hasHeaderContextMenu();
     * gs.print(hasHeader);
     * @returns If true a context menu displays next to each column header in a list.
     */
    hasHeaderContextMenu(): Boolean;

    /**
     * Returns whether list personalization is enabled for a list.
     * 
     * @example
     * var list = new GlideListProperties();
     * var mechanic = list.setHasListMechanic(true);
     * var hasMechanic = list.hasListMechanic();
     * gs.print(hasMechanic);
     * @returns If true the list mechanic is enabled for a list and the Personalize List icon appears on the page.
     */
    hasListMechanic(): Boolean;

    /**
     * Returns whether or not a list can have popup windows.
     * 
     * @example
     * var list = new GlideListProperties();
     * var popup = list.setHasPopup(true);
     * var hasPopup = list.hasPopup();
     * gs.print(hasPopup);
     * @returns Returns true if the list allows popups.
     */
    hasPopup(): Boolean;

    /**
     * Returns whether or not rows in a list have a context menu.
     * 
     * @example
     * var list = new GlideListProperties();
     * var contextMenu = list.setHasRowContextMenu(true);
     * var hasContextMenu = list.hasRowContextMenu();
     * gs.print(hasContextMenu);
     * @returns If true a list row can have a context menu.
     */
    hasRowContextMenu(): Boolean;

    /**
     * Returns whether or not the search bar is enabled for a list.
     * 
     * @example
     * var list = new GlideListProperties();
     * var search = list.setHasSearch(true);
     * var hasSearch = list.hasSearch();
     * gs.print(hasSearch);
     * @returns If true the search bar appears in the header of a list.
     */
    hasSearch(): Boolean;

    /**
     * Returns whether or not the list title appears in the list header.The title context menu is a child property of title. If setHasTitleContextMenu is set to true, hasTitle also returns true, even if setHasTitle is set to false.
     * 
     * @example
     * var list = new GlideListProperties();
     * var title = list.setHasTitle(true);
     * var contextMenu = list.setHasTitleContextMenu(true);
     * var hasTitle = list.hasTitle();
     * gs.print(hasTitle);
     * 
     * @returns If true the list title appears in the list header.
     */
    hasTitle(): Boolean;

    /**
     * Returns whether a context menu appears in a list header.The title context menu is a child property of title. If setHasTitleContextMenu is set to true, hasTitle also returns true, even if setHasTitle is set to false.
     * 
     * @example
     * var list = new GlideListProperties();
     * var contextMenu = list.setHasTitleContextMenu(true);
     * var hasContextMenu = list.hasTitleContextMenu();
     * gs.print(hasContextMenu);
     * 
     * @returns If true the context menu appears in the list header next to the list title.
     */
    hasTitleContextMenu(): Boolean;

    /**
     * Returns whether or not the page navigation controls appear in the header of a list.
     * 
     * @example
     * var list = new GlideListProperties();
     * var vcr = list.setHasTopVCR(true);
     * var hasVCR = list.hasTopVCR();
     * gs.print(hasVCR);
     * @returns If true the page navigation controls appear in the header of a list.
     */
    hasTopVCR(): Boolean;

    /**
     * Returns whether or not the omit filter option has been selected.The ListControl omit flags take precedence in that if they are set, they negate the setting of their corresponding flag. For example, if the show filter flag has been set to true, but the ListControl omit filter is true, then checking hasFilter returns false.
     * 
     * @example
     * var lp = new GlideListProperties();
     * var omitFilter = lp.isOmitFilter();
     * gs.print(omitFilter);
     * @returns Returns true or false whether the omit filter flag has been selected.
     */
    isOmitFilter(): Boolean;

    /**
     * Returns whether the Save Filter button is hidden in the condition builder.
     * 
     * @example
     * var list = new GlideListProperties();
     * var SaveFilter = list.setSaveFilterHidden(true);
     * var hasSaveFilter = list.isSaveFilterHidden();
     * gs.print(hasSaveFilter);
     * @returns If true the Save Filter button is hidden in the condition builder.
     */
    isSaveFilterHidden(): Boolean;

    /**
     * Returns whether or not a list shows links.
     * 
     * @example
     * var list = new GlideListProperties();
     * var links = list.setShowLinks(true);
     * var hasLinks = list.isShowLinks();
     * gs.print(hasLinks);
     */
    isShowLinks();

    /**
     * Returns whether or not toggling the header columns is available for a list.
     * 
     * @example
     * var list = new GlideListProperties();
     * var toggle = list.setToggleHeader(true);
     * var hasToggle = list.isToggleHeader();
     * gs.print(hasToggle);
     * @returns If true users can show or hide the column headers for a table.
     */
    isToggleHeader(): Boolean;

    /**
     * Determine whether the user can change the view for the list.
     * 
     * @onOff If false users cannot change the list view. By default, changing views is enabled.
     * @example
     * var list = new GlideListProperties();
     * var changeView = list.setCanChangeView(true);
     */
    setCanChangeView(onOff: Boolean);

    /**
     * Determine whether users can group items in a list.
     * 
     * @onOff If false, the group by option does not appear in the column context menu. By default the group by option appears in the list context menu.
     * @example
     * var list = new GlideListProperties();
     * var canGroup = list.setCanGroup(true);
     */
    setCanGroup(onOff: Boolean);

    /**
     * Determine whether the sort option is available in a list.
     * 
     * @onOff If false, the sort option does not appear in column list context menu, and users cannot click the column title to change the order of the list.
     * @example
     * var list = new GlideListProperties();
     * var canSort = list.setCanSort(true);
     */
    setCanSort(onOff: Boolean);

    /**
     * Displays or hides all of the available context menus for a list.
     * 
     * @onOff If set to true displays the title context menu, header context menu, and list context menu for a list.
     * @example
     * var list = new GlideListProperties();
     * var context = list.setContextMenus(true);
     */
    setContextMenus(onOff: Boolean);

    /**
     * Determine whether the Actions on select rows options display at the bottom of a list.
     * 
     * @onOff If true displays action options for a list.
     * @example
     * var list = new GlideListProperties();
     * var actions = list.setHasActions(true);
     */
    setHasActions(onOff: Boolean);

    /**
     * Determine whether the navigation actions at the bottom of a list are hidden or not.
     * 
     * @onOff When true adds navigation to the bottom of a list.
     * @example
     * var lp = new GlideListProperties();
     * var bottom = lp.setHasBottomNav(true);
     */
    setHasBottomNav(onOff: Boolean);

    /**
     * Determine whether the first page, last page, next page, and previous page buttons appear at the bottom of the list.
     * 
     * @onOff If true, the first page, last page, next page, and previous page buttons appear at the bottom of the list.
     * @example
     * var list = new GlideListProperties();
     * var bottomVCR = list.setHasBottomVCR(true);
     */
    setHasBottomVCR(onOff: Boolean);

    /**
     * Determine whether or not breadcrumbs appear at the top of a list.Breadcrumbs are a child of filters. To hide breadcrumbs completely, you need to also set the filter to false.
     * 
     * @onOff If true breadcrumbs appear at the top of a list.
     * @example
     * var list = new GlideListProperties();
     * var breadcrumbs = list.setHasBreadcrumbs(true);
     */
    setHasBreadcrumbs(onOff: Boolean);

    /**
     * Determine whether or not the filter displays as part of a list.The filter is a parent of breadcrumbs. To remove the filter, you need to set both the filter and the breadcrumbs to false.
     * 
     * @onOff If true a filter icon appears at the top of the list. Users can use the filter to narrow search results.
     * @example
     * var list = new GlideListProperties();
     * var filter = list.setHasFilter(true);
     */
    setHasFilter(onOff: Boolean);

    /**
     * Determine whether or not a list displays a header.
     * 
     * @onOff If true the list displays a header.
     * @example
     * var list = new GlideListProperties();
     * var header = list.setHasHeader(true);
     */
    setHasHeader(onOff: Boolean);

    /**
     * Determine whether or not the context menu appears next to each column in a list.
     * 
     * @onOff If true the context menu appears next to each column in a list.
     * @example
     * var list = new GlideListProperties();
     * var actions = list.setHasHeaderContextMenu(true);
     */
    setHasHeaderContextMenu(onOff: Boolean);

    /**
     * Determine whether or not a list has the option for personalization.
     * 
     * @onOff If true the list mechanic is enabled and the Personalize List icon appears on the page.
     * @example
     * var list = new GlideListProperties();
     * var mechanic = list.setHasListMechanic(true);
     */
    setHasListMechanic(onOff: Boolean);

    /**
     * Determine whether the list has a popup or modal window.
     * 
     * @onOff If truethe list can have popup windows.
     * @example
     * var list = new GlideListProperties();
     * var popup = list.setHasPopup(true);
     */
    setHasPopup(onOff: Boolean);

    /**
     * Determines whether or not list rows have a context menu.
     * 
     * @onOff When true list rows can have a context menu.
     * @example
     * var list = new GlideListProperties();
     * var contextMenu = list.setHasRowContextMenu(true);
     */
    setHasRowContextMenu(onOff: Boolean);

    /**
     * Determine whether search appears for a list.
     * 
     * @onOff If true the search bar appears in the list header.
     * @example
     * var list = new GlideListProperties();
     * var search = list.setHasSearch(true);
     */
    setHasSearch(onOff: Boolean);

    /**
     * Determine whether the list title appears in the header.
     * 
     * @onOff If true the title of the list appears in the list header.
     * @example
     * var list = new GlideListProperties();
     * var title = list.setHasTitle(true);
     * 
     */
    setHasTitle(onOff: Boolean);

    /**
     * Determine whether or not a list has a context menu in the header.
     * 
     * @onOff If true the context menu appears next to the list title in the header
     * @example
     * var list = new GlideListProperties();
     * var contextMenu = list.setHasTitleContextMenu(true);
     */
    setHasTitleContextMenu(onOff: Boolean);

    /**
     * Determine whether or not a list has the page navigation controls in the list header.
     * 
     * @onOff If true the page navigation controls appear in the header of a list.
     * @example
     * var list = new GlideListProperties();
     * var vcr = list.setHasTopVCR(true);
     */
    setHasTopVCR(onOff: Boolean);

    /**
     * Determine whether rows are visible in a list.
     * 
     * @onOff If true all of the rows are hidden for a list.
     * @example
     * var list = new GlideListProperties();
     * var hideRows = list.setHideRows(true);
     */
    setHideRows(onOff: Boolean);

    /**
     * Set the unique ID for a list.
     * 
     * @UniqueID The unique ID for the list.
     * @example
     * var list = new GlideListProperties();
     * var setID = list.setListID("a9dd1483d99f5700964f387107a8a3ec");
     * var getID = list.getListID();
     * gs.print(getID);
     */
    setListID(UniqueID: String);

    /**
     * Defines a name for the list.
     * 
     * @name Name of the list.
     * @example
     * var list = new GlideListProperties();
     * var name = list.setListName("my custom list");
     * 
     */
    setListName(name: String);

    /**
     * Determine whether the Save Filter button appears in the condition builder.
     * 
     * @onOff If true the Save Filter button is hidden.
     * @example
     * var list = new GlideListProperties();
     * var saveFilter = list.setSaveFilterHidden(true);
     */
    setSaveFilterHidden(onOff: Boolean);

    /**
     * Whether or not a list includes links.
     * 
     * @onOff If true list includes related links.
     * @example
     * var list = new GlideListProperties();
     * var links = list.setShowLinks(true);
     */
    setShowLinks(onOff: Boolean);

    /**
     * Defines the list title.
     * 
     * @title Title for the list.
     * @example
     * var list = new GlideListProperties();
     * var title = list.setTitle("My title");
     */
    setTitle(title: String);

    /**
     * Determine whether users can show or hide column headers for a table.
     * 
     * @onOff If true an icon appears in the header that allows users to show or hide the column headers.
     * @example
     * var list = new GlideListProperties();
     * var toggle = list.setToggleHeader(true);
     * 
     */
    setToggleHeader(onOff: Boolean);

    /**
     * Determine whether the first page, last page, next page, and previous page buttons appear at the top and bottom of the list.
     * 
     * @onOff If false, the list does not have any of the page navigation buttons for a list.
     * @example
     * var list = new GlideListProperties();
     * var VCR = list.setVCR(true);
     */
    setVCR(onOff: Boolean);

}

/**
 * The GlideQueryCondition API provides additional AND or OR conditions that can be added to the current condition, allowing you to build complex queries. Build complex queries such as: * * In the case of addCondition(), an implied AND is added. * * This class has no constructor. A GlideQueryCondition object is returned by the following methods: addActiveQuery() addInactiveQuery() addJoinQuery() addNotNullQuery() addNullQuery() addQuery() * * If there is a complicated set of AND and OR queries, a single encoded query containing all conditions simplifies the query creation. To simplify the query creation, create a query in a list view, right-click the query, and select Copy query. It creates a single encoded query string to return your result set. Use that string as a parameter in an addEncodedQuery() call. * * Always test queries on a sub-production instance prior to deploying them on a production instance. An incorrectly constructed encoded query, such as including an invalid field name, produces an invalid query. When the invalid query is run, the invalid part of the query condition is dropped, and the results are based on the valid part of the query, which may return all records from the table. Using an insert(), update(), deleteRecord(), or deleteMultiple() method on bad query results can result in data loss. * * You can set the glide.invalid_query.returns_no_rows system property to true to have queries with invalid encoded queries return no records.
 * 
 * 
 */
declare class GlideQueryCondition {



    /**
     * Adds an AND condition to the current condition.
     * 
     * @name The name of a field.
     * @oper (Optional) The operator for the query. If you do not specify an operator, the condition uses an equals operator.
     * @value The value to query on.
     * @example
     * var gr = new GlideRecord('incident');
     * var qc = gr.addQuery('category', 'Hardware');
     * qc.addCondition('category', 'Network');
     * gr.addQuery('number','INC0000003');
     * gr.next();
     * gr.number;
     * gs.info(gr.getEncodedQuery());
     * @returns A reference to a GlideQueryConditon that was added to the GlideRecord.
     */
    addCondition(name: String, oper: String, value: Object): GlideQueryCondition;

    /**
     * Appends a 2-or-3 parameter OR condition to an existing GlideQueryCondition.addOrCondition() works in conjunction with any of the addQuery()methods to OR the specified query parameters to the query previously constructed using addQuery().addOrCondition() is typically called with three parameters; table field, operator, and comparison value. It can be called with only two parameters, table field and comparison value, such as qc.addOrCondition('category', 'software');. The operator in this case is assumed to be "equal to".
     * 
     * @name Field name
     * @oper (Optional) Query operator. The available values are dependent on the data type of the value parameter.Numbers: = != &gt; &gt;= &lt; &lt;= Strings (must be in upper case): = != IN STARTSWITH ENDSWITH CONTAINS DOESNOTCONTAIN 
     * @value Value on which to query (not case-sensitive).Note: All passed in arrays must contain a minimum of two elements. Single element arrays are not supported.
     * @example
     * var gr = new GlideRecord('incident');
     * var qc = gr.addQuery('category', 'Hardware');
     * qc.addOrCondition('category', 'Network');
     * gr.addQuery('number','INC0000003');
     * gr.next();
     * gr.number;
     * gs.info(gr.getEncodedQuery());
     * 
     * @example
     * var myObj = new GlideRecord('incident');
     * var q1 = myObj.addQuery('state', '&lt;', 3);
     * q1.addOrCondition('state', '&gt;', 5);
     * var q2 = myObj.addQuery('priority', 1);
     * q1.addOrCondition('priority', 5);
     * myObj.query();
     * @returns A reference to a GlideQueryConditon that was added to the GlideRecord.
     */
    addOrCondition(name: String, oper: String, value: Object): GlideQueryCondition;

}

/**
 * GlideRecord is used for database operations. A GlideRecord contains both records and fields. For information about GlideRecordSecure, which is a class inherited from GlideRecord that performs the same functions as GlideRecord, and also enforces ACLs, see the GlideServer APIs. * * Always test queries on a sub-production instance prior to deploying them on a production instance. An incorrectly constructed encoded query, such as including an invalid field name, produces an invalid query. When the invalid query is run, the invalid part of the query condition is dropped, and the results are based on the valid part of the query, which may return all records from the table. Using an insert(), update(), deleteRecord(), or deleteMultiple() method on bad query results can result in data loss. * * You can set the glide.invalid_query.returns_no_rows system property to true to have queries with invalid encoded queries return no records.
 * 
 * 
 */
declare class GlideRecord {



    /**
     * Creates an instance of the GlideRecord class for the specified table.
     * 
     * @tableName The table to be used.
     * @example
     * var gr = new GlideRecord('incident');
     */
    constructor(tableName: String);

    /**
     * Adds a filter to return active records.
     * 
     * @example
     * var inc = new GlideRecord('incident');
     * inc.addActiveQuery();
     * inc.query();
     * @returns Filter to return active records.
     */
    addActiveQuery(): QueryCondition;

    /**
     * Changes the domain used for the query from the user's domain to the domain of the provided GlideRecord.Always test queries on a sub-production instance prior to deploying them on a production instance. An incorrectly constructed encoded query, such as including an invalid field name, produces an invalid query. When the invalid query is run, the invalid part of the query condition is dropped, and the results are based on the valid part of the query, which may return all records from the table. Using an insert(), update(), deleteRecord(), or deleteMultiple() method on bad query results can result in data loss.You can set the glide.invalid_query.returns_no_rows system property to true to have queries with invalid encoded queries return no records.
     * 
     * @glideRecord GlideRecord from which to obtain the domain.
     * @example
     * //This example requires the Domain plugin be active, the Group table is the specified 
     * //Domain table, and the ITIL user is in the Database Atlanta domain
     * //From any domain (using queryNoDomain()) look up the incidents that an ITIL user can only see 
     * //who is in the Database Atlanta domain, should expect all incidents with the global or the
     * //Database Atlanta domain specified.
     * var domain = new GlideRecord('sys_user');
     * domain.addQuery('user_name', 'itil');
     * domain.queryNoDomain();
     * if (domain.next()) {
     *     var domainQuery = new GlideRecord('incident');
     *     domainQuery.addQuery('active', true);
     *     domainQuery.addDomainQuery(domain);
     *     domainQuery.query();
     *     gs.print('Number of Incidents for ITIL user: ' + domainQuery.getRowCount());
     *     while (domainQuery.next())
     *         gs.print(domainQuery.number);
     * }
     */
    addDomainQuery(glideRecord: Object);

    /**
     * Adds an encoded query to other queries that may have been set.Always test queries on a sub-production instance prior to deploying them on a production instance. An incorrectly constructed encoded query, such as including an invalid field name, produces an invalid query. When the invalid query is run, the invalid part of the query condition is dropped, and the results are based on the valid part of the query, which may return all records from the table. Using an insert(), update(), deleteRecord(), or deleteMultiple() method on bad query results can result in data loss.You can set the glide.invalid_query.returns_no_rows system property to true to have queries with invalid encoded queries return no records.
     * 
     * @query An encoded query string .
     * @example
     * var queryString = "priority=1^ORpriority=2";
     *  var gr = new GlideRecord('incident');
     *  
     *  gr.addEncodedQuery(queryString);
     *  gr.query();
     *  while (gr.next()) {
     *    gs.addInfoMessage(gr.number);
     *  }
     */
    addEncodedQuery(query: String);

    /**
     * Applies a pre-defined GlideDBFunctionBuilder object to a record.Use the GlideDBFunctionBuilder scoped class to define a function. After the function is defined, use the addFunction(Object function) method to apply the function to a record.
     * 
     * @func A GlideDBFunctionBuilder object that defines a SQL operation.
     * @example
     * var functionBuilder = new GlideDBFunctionBuilder();
     * var myAddingFunction = functionBuilder.add();
     * myAddingFunction = functionBuilder.field('order');
     * myAddingFunction = functionBuilder.field('priority');
     * myAddingFunction = functionBuilder.build();
     * 
     * var gr = new GlideRecord('incident');
     * gr.addFunction(myAddingFunction);
     * gr.addQuery(myAddingFunction, '&lt;', 5);
     * gr.query();
     * while(gr.next())
     * gs.log(gr.getValue(myAddingFunction));
     * 
     */
    addFunction(func: Object);

    /**
     * Adds a filter to return inactive records. Inactive records have the active flag set to false.
     * 
     * @example
     * var inc = new GlideRecord('incident');
     * inc.addInactiveQuery();
     * inc.query();
     * @returns Records where the active flag is false.
     */
    addInactiveQuery(): QueryCondition;

    /**
     * Adds a filter to return records based on a relationship in a related table.For example, find all the users that are in the database group (users via sys_user_grmember table). Another example would be find all problems that have an assigned incident (problems via the incident.problem_id relationship).This is not a true database join; rather, addJoinQuery() adds a subquery. So, while the result set is limited based on the join, the only fields that you have access to are those on the base table (those which are in the table with which the GlideRecord was initialized).Always test queries on a sub-production instance prior to deploying them on a production instance. An incorrectly constructed encoded query, such as including an invalid field name, produces an invalid query. When the invalid query is run, the invalid part of the query condition is dropped, and the results are based on the valid part of the query, which may return all records from the table. Using an insert(), update(), deleteRecord(), or deleteMultiple() method on bad query results can result in data loss.You can set the glide.invalid_query.returns_no_rows system property to true to have queries with invalid encoded queries return no records.
     * 
     * @table Table name
     * @example
     * var prob = new GlideRecord('problem');
     * prob.addJoinQuery('incident');
     * prob.query();
     * @example
     * // Look for Problem records
     * var gr = new GlideRecord('problem');
     *  
     * // That have associated Incident records
     * var grSQ = gr.addJoinQuery('incident');
     *  
     * // Where the Problem records are "active=false"
     * gr.addQuery('active', 'false');
     *  
     * // And the Incident records are "active=true"
     * grSQ.addCondition('active', 'true');
     *  
     * // Query
     * gr.query();
     *  
     * // Iterate and print results
     * while (gr.next()) {
     *     gs.print(gr.getValue('number'));
     * }
     * @returns Records where the relationships match.
     */
    addJoinQuery(table: String): QueryCondition;

    /**
     * Adds a filter to return records based on a relationship in a related table.For example, find all the users that are in the database group (users via sys_user_grmember table). Another example would be find all problems that have an assigned incident (problems via the incident.problem_id relationship).This is not a true database join; rather, addJoinQuery() adds a subquery. So, while the result set is limited based on the join, the only fields that you have access to are those on the base table (those which are in the table with which the GlideRecord was initialized).Always test queries on a sub-production instance prior to deploying them on a production instance. An incorrectly constructed encoded query, such as including an invalid field name, produces an invalid query. When the invalid query is run, the invalid part of the query condition is dropped, and the results are based on the valid part of the query, which may return all records from the table. Using an insert(), update(), deleteRecord(), or deleteMultiple() method on bad query results can result in data loss.You can set the glide.invalid_query.returns_no_rows system property to true to have queries with invalid encoded queries return no records.
     * 
     * @table Table name
     * @primaryField If other than sys_id, the primary field.
     * @returns Records where the relationships match.
     */
    addJoinQuery(table: String, primaryField: String): QueryCondition;

    /**
     * Adds a filter to return records based on a relationship in a related table.For example, find all the users that are in the database group (users via sys_user_grmember table). Another example would be find all problems that have an assigned incident (problems via the incident.problem_id relationship).This is not a true database join; rather, addJoinQuery() adds a subquery. So, while the result set is limited based on the join, the only fields that you have access to are those on the base table (those which are in the table with which the GlideRecord was initialized).Always test queries on a sub-production instance prior to deploying them on a production instance. An incorrectly constructed encoded query, such as including an invalid field name, produces an invalid query. When the invalid query is run, the invalid part of the query condition is dropped, and the results are based on the valid part of the query, which may return all records from the table. Using an insert(), update(), deleteRecord(), or deleteMultiple() method on bad query results can result in data loss.You can set the glide.invalid_query.returns_no_rows system property to true to have queries with invalid encoded queries return no records.
     * 
     * @table Table name
     * @primaryField If other than sys_id, the primary field.
     * @joinTableField If other than sys_id, the field that joins the tables
     * @example
     * var gr = new GlideRecord('problem'); 
     * gr.addJoinQuery('incident', 'opened_by', 'caller_id'); 
     * gr.query();
     * @returns Records where the relationships match.
     */
    addJoinQuery(table: String, primaryField: String, joinTableField: String): QueryCondition;

    /**
     * Adds a filter to return records where the specified field is not null.
     * 
     * @fieldName The field name.
     * @example
     * var target = new GlideRecord('incident'); 
     *   target.addNotNullQuery('short_description');
     *   target.query();   // Issue the query to the database to get all records
     *   while (target.next()) {   
     *      // add code here to process the incident record
     *   }
     * @returns QueryCondition of records where the parameter field is not null.
     */
    addNotNullQuery(fieldName: String): QueryCondition;

    /**
     * Adds a filter to return records where the specified field is null.
     * 
     * @fieldName The field name.
     * @example
     * var target = new GlideRecord('incident'); 
     *   target.addNullQuery('short_description');
     *   target.query();   // Issue the query to the database to get all records
     *   while (target.next()) {   
     *      // add code here to process the incident record
     *   }
     * @returns QueryCondition of records where the specified field is null.
     */
    addNullQuery(fieldName: String): QueryCondition;

    /**
     * Provides the ability to build a request, which when executed, returns the rows from the specified table that match the request.If you are familiar with SQL, this method is similar to the "where" clause. One or more addQuery() calls can be made in a single query; in this case the queries are AND'ed. If any of the query statements need to be OR'ed, use the class GlideQueryCondition.addQuery() is typically called with three parameters; table field, operator, and comparison value. It can be called with only two parameters, table field and comparison value, such as myObj.addQuery('category','Hardware');. The operator in this case is assumed to be "equal to".Always test queries on a sub-production instance prior to deploying them on a production instance. An incorrectly constructed encoded query, such as including an invalid field name, produces an invalid query. When the invalid query is run, the invalid part of the query condition is dropped, and the results are based on the valid part of the query, which may return all records from the table. Using an insert(), update(), deleteRecord(), or deleteMultiple() method on bad query results can result in data loss.You can set the glide.invalid_query.returns_no_rows system property to true to have queries with invalid encoded queries return no records.
     * 
     * @name Table field name
     * @operator Query operator. The available values are dependent on the data type of the value parameter.Numbers: = != &gt; &gt;= &lt; &lt;= Strings (must be in upper case): = != IN NOT IN STARTSWITH ENDSWITH CONTAINS DOES NOT CONTAIN INSTANCEOF 
     * @value Value on which to query (not case-sensitive).
     * @example
     * var rec = new GlideRecord('incident');
     * rec.addQuery('active',true);
     * rec.addQuery('sys_created_on', "&gt;", "2010-01-19 04:05:00");
     * rec.query();
     * while (rec.next()) { 
     *  rec.active = false;
     *  gs.print('Active incident ' + rec.number + ' closed');
     *  rec.update();
     * }
     * @example
     * var que = new GlideRecord('incident');
     * que.addQuery('number','IN','INC00001,INC00002');
     * que.query();
     * while(que.next()) {
     *  //do something....
     * }
     * @returns A reference to the QueryCondition that was added to the GlideRecord.
     */
    addQuery(name: String, operator: Object, value: Object): QueryCondition;

    /**
     * Apply a template record (from sys_template) to the current record. If the specified template is not found, no action is taken.
     * 
     * @template Name of a template from the sys_template table
     * @example
     * var rec1 = new GlideRecord("incident");
     * rec1.initialize();
     * rec1.applyTemplate("my_incident_template");
     * //...possibly more code here... 
     * 
     * rec1.insert();
     * 
     */
    applyTemplate(template: String);

    /**
     * Enables or disables the update to the fields sys_updated_by, sys_updated_on, sys_mod_count, sys_created_by, and sys_created_on. This is often used for manually updating field values on a record while leaving historical information unchanged.
     * 
     * @e If false disables updates to sys_updated_by, sys_updated_on, sys_mod_count, sys_created_by, and sys_created_on.
     * @example
     * var inc = new GlideRecord('incident');
     *  
     * // Change all Open(1) incidents to Active(2)
     *  
     * inc.addQuery('state', 1);
     * inc.query();
     *  
     * while (inc.next()) {
     *   inc.autoSysFields(false);  // Do not update sys_updated_by, sys_updated_on, sys_mod_count, sys_created_by, and sys_created_on
     *   inc.setWorkflow(false);    // Do not run any other business rules
     *   inc.setValue('state', 2);
     *   inc.update();
     * }
     */
    autoSysFields(e: Boolean);

    /**
     * Determines if the access control rules (which includes the user's role) permit inserting new records in this table.
     * 
     * @returns True if the user's role permits creation of new records in the table.
     */
    canCreate(): Boolean;

    /**
     * Determines if the access control rules (which includes the user's role) permit deletion of records in this table.
     * 
     * @example
     * var att = new GlideRecord('sys_attachment');
     * att.get('$[sys_attachment.sys_id]');
     * var sm = GlideSecurityManager.get();
     * var checkMe = 'record/sys_attachment/delete';
     * var canDelete = sm.hasRightsTo(checkMe, att);
     * gs.log('canDelete: ' + canDelete);
     * @returns True if the user can delete records from this table, false otherwise.
     */
    canDelete(): Boolean;

    /**
     * Determines if the access control rules (which includes the user's role) permit reading this table.
     * 
     * @returns True if the user can read from this table, false otherwise.
     */
    canRead(): Boolean;

    /**
     * Determines if the access control rules (which includes the user's role) permit updates to records in this table.
     * 
     * @returns True if the user can write to the table, false otherwise.
     */
    canWrite(): Boolean;

    /**
     * Determines whether any of the fields in the record have changed.
     * 
     * @returns True if any of the fields in the record have changed, false otherwise.
     */
    changes(): Boolean;

    /**
     * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT for a duration field. Does not require the creation of a GlideDateTime object because the duration field is already a GlideDateTime object.
     * 
     * @example
     * var inc = new GlideRecord('incident');
     * inc.get('17c90efb13418700cc36b1422244b05d');
     * gs.info(inc.calendar_duration.dateNumericValue());
     * @returns Number of milliseconds since January 1, 1970, 00:00:00 GMT.
     */
    dateNumericValue(): Number;

    /**
     * Deletes multiple records according to the current "where" clause.This method does not delete attachments.Dot-walking is not supported for this method. When using the deleteMultiple() function on referenced tables, all the records in the table are deleted. Also, when using deleteRecord() to cascade delete, prior calls to setWorkflow() on the same GlideRecord object are ignored.Do not use deleteMultiple() on tables with currency fields. Always delete each record individually. Also, do not use this method with the chooseWindow() or setLimit() methods when working with large tables.
     * 
     * @example
     * function nukeCart() {
     *       var cart = getCart();
     *       var id = cart.sys_id;
     *       var kids = new GlideRecord('sc_cart_item');
     *       kids.addQuery('cart', cart.sys_id);
     *       kids.deleteMultiple();
     */
    deleteMultiple();

    /**
     * Deletes a single record.
     * 
     * @example
     * var rec = new GlideRecord('incident');
     * rec.addQuery('active',false);
     * rec.query();
     * while (rec.next()) { 
     *  gs.print('Inactive incident ' + rec.number + ' deleted');
     *  rec.deleteRecord();
     * }
     * @returns True if the record was deleted; false if none were found to delete.
     */
    deleteRecord(): Boolean;

    /**
     * Returns true if any record has a matching value in the specified column. If found, it also moves to the first record that matches, essentially executing next() until the record is returned.
     * 
     * @columnName Specifies the field name.
     * @value Specifies the value to check for in the specified field.
     * @returns True if any record has a matching value in the specified field.
     */
    find(columnName: String, value: String): Boolean;

    /**
     * Returns the specified record in an instantiated GlideRecord object.If multiple records are found, use next() to access the additional records.
     * 
     * @name Optional. Name of the instantiated GlideRecord column to search for the specified value parameter. If only a single parameter is passed in, the method assumes that this parameter is sys_id.
     * @value Value to match.
     * @example
     * var grIncident = new GlideRecord('incident');
     * var returnValue = grIncident.get('99ebb4156fa831005be8883e6b3ee4b9');
     * gs.info(returnValue); // logs true or false
     * gs.info(grIncident.number); // logs Incident Number
     * @example
     * var grIncident = new GlideRecord('incident');
     * var returnValue = grIncident.get('caller_id.name','Sylivia Wayland');
     * gs.info(returnValue); // logs true or false
     * gs.info(grIncident.number); // logs Incident Number
     * @returns Indicates whether the requested record was located: true: record was found false: record was not found 
     */
    get(name: Object, value: Object): Boolean;

    /**
     * Returns the dictionary attributes on the specified field.
     * 
     * @fieldName Field name for which to return the dictionary attributes
     * @example
     * doit();
     * function doit() {
     *   var gr = new GlideRecord('sys_user');
     *   gr.query("user_name","admin");
     *   if (gr.next()) {
     *     gs.print("we got one");
     *     gs.print(gr.location.getAttribute("tree_picker"));
     *   }
     * }
     * @returns Dictionary attributes
     */
    getAttribute(fieldName: String): String;

    /**
     * Returns the table's label.
     * 
     * @returns The table's label
     */
    getClassDisplayValue(): String;

    /**
     * Retrieves the display value for the current record.
     * 
     * @example
     * var gr = new GlideRecord('incident');
     * gr.get('sys_id','ef43c6d40a0a0b5700c77f9bf387afe3');
     * gs.info(gr.getDisplayValue());
     * @returns Display value for the current record
     */
    getDisplayValue(): String;

    /**
     * Returns the element's descriptor.
     * 
     * @example
     * var totalCritical  = 0;
     * var filledCritical = 0;
     * var fields         = current.getFields();
     *  
     * gs.print(fields);
     *  
     * for (var num = 0; num &lt; fields.size(); num++) {
     *  
     * 	gs.print("RUNNING ARRAY VALUE " + num);
     *  
     * 	var ed = fields.get(num).getED();
     *  
     * 	if(ed.hasAttribute("tiaa_critical")) {
     * 		gs.print("CRITICAL FIELD FOUND");
     * 		totalCritical ++;
     *  
     * 		if (!fields.get(num).isNil()) {
     * 			filledCritical ++;
     * 		}
     * 	}
     *  
     * }
     *  
     * var answer = 0;
     * gs.print("TOTAL - " + totalCritical);
     * gs.print("FILLED - " + filledCritical);
     *  
     * if (filledCritical &gt; 0 &amp;&amp; totalCritical &gt; 0) {
     *  
     * 	var pcnt = (filledCritical/totalCritical)*100;
     * 	answer = pcnt.toFixed(2);;
     *  
     * }
     *  
     * answer;
     * @returns The element's descriptor
     */
    getED(): GlideElementDescriptor;

    /**
     * Retrieves the GlideElement for a specified field.
     * 
     * @fieldName A field name
     * @returns A GlideElement object
     */
    getElement(fieldName: String): GlideElement;

    /**
     * Retrieves the encoded query as a string.
     * 
     * @returns The encoded query
     */
    getEncodedQuery(): String;

    /**
     * Retrieves the field value for the display field of the current record and adds escape characters for use in Jelly scripts.
     * 
     * @returns Escaped value of display field.
     */
    getEscapedDisplayValue(): String;

    /**
     * Retrieves a Java ArrayList of fields in the current record.
     * 
     * @example
     * // This can be run in "Scripts - Background" for demonstration purposes
     *  
     * // Get a single incident record
     * var grINC = new GlideRecord('incident');
     * grINC.query();
     * grINC.next();
     * gs.print('Using ' + grINC.getValue('number'));
     * gs.print('');
     *  
     * // getFields() returns a Java ArrayList
     * var fields = grINC.getFields();
     *  
     * // Enumerate GlideElements in the GlideRecord object that have values
     * gs.print('Enumerating over all fields with values:');
     * for (var i = 0; i &lt; fields.size(); i++) {
     *   var glideElement = fields.get(i);
     *   if (glideElement.hasValue()) {
     *     gs.print('  ' + glideElement.getName() + '\t' + glideElement);
     *   }
     * }
     * gs.print('');
     *  
     * // Get a specific GlideElement: number
     * gs.print('Getting the number field:');
     * for (var i = 0; i &lt; fields.size(); i++) {
     *   var glideElement = fields.get(i);
     *   if (glideElement.hasValue() &amp;&amp; glideElement.getName() == 'number') {
     *     gs.print('  ' + glideElement.getName() + '\t' + glideElement);
     *   }
     * }
     * @returns Fields in the current record
     */
    getFields(): JavaArrayList;

    /**
     * Retrieves the field's label.
     * 
     * @example
     * template.print("Summary of Requested items:\n");  
     * var gr = new GlideRecord("sc_req_item");
     * gr.addQuery("request", current.sysapproval);
     * gr.query();
     * while(gr.next()) {
     *     var nicePrice = gr.price.toString();
     *     if (nicePrice != '') {
     *         nicePrice = parseFloat(nicePrice);
     *         nicePrice = nicePrice.toFixed(2);
     *     }
     *     template.print(gr.number + ":  " + gr.quantity + " X " + gr.cat_item.getDisplayValue() 
     *                      + " at $" + nicePrice + " each \n");
     *     template.print("    Options:\n");
     *     for (key in gr.variables) {
     *       var v = gr.variables[key];
     *       if(v.getGlideObject().getQuestion().getLabel() != '') {
     *          template.space(4);
     *          template.print('     ' +  v.getGlideObject().getQuestion().getLabel() + " = " 
     *                      + v.getDisplayValue() + "\n");  
     *       }
     *     }
     * }
     * @returns The field's label
     */
    getLabel(): String;

    /**
     * Retrieves the link for the current record.
     * 
     * @noStack If true, the link generated will not append &amp;sysparm_stack=[tablename]_list.do? sysparm_query=active=true to the end of the URL; if false, the link will. Leaving the parameter empty defaults to false.
     * @example
     * //Check for attachments and add link if there are any
     *   var attachment_link = '';
     *   var rec = new GlideRecord('sc_req_item');
     *   rec.addQuery('sys_id', current.request_item);
     *   rec.query();
     *   if(rec.next()){
     *     if(rec.hasAttachments()){
     *       attachment_link = gs.getProperty('glide.servlet.uri') + rec.getLink();
     *     }   
     *   }
     * @returns A URL
     */
    getLink(noStack: Boolean): String;

    /**
     * Retrieves the current row number.
     * 
     * @b  
     * @returns The row number of the current record
     */
    getLocation(b: Boolean): Number;

    /**
     * Retrieves the plural label of the GlideRecord table.For example, if the table name is "Change Request," this method returns "Change Requests."
     * 
     * @returns The plural label of the GlideRecord's table.
     */
    getPlural(): String;

    /**
     * Retrieves the class (table) name for the current record.
     * 
     * @example
     * function TaskAssignmentFilter() {
     *   var classname = current.getRecordClassName();
     *   var filter = "type=null";
     *   if (classname == "incident" &amp;&amp; current.category == "database") {
     *     filter = GetGroupFilter("database");
     *   }
     *   else {
     *     // append exclusion for 'catalog' to the filter
     *     var cat = new GlideRecord("sys_user_group_type");  
     *     cat.addQuery("name", "catalog");
     *     cat.query();
     *     if (cat.next()) {
     *       filter += "^ORtype!=" + cat.sys_id;
     *     }
     *   }
     *   gs.log("TaskAssignmentFilter: " + filter);
     *   return filter;
     * }
     * @returns Class or table name
     */
    getRecordClassName(): String;

    /**
     * Retrieves a list of names and display values of tables that refer to the current record.
     * 
     * @Boolean  
     * @returns Hash map with names and display values of related tables.
     */
    getRelatedLists(Boolean: b): HashMap;

    /**
     * Retrieves a list of names and display values of tables that are referred to by the current record.
     * 
     * @b  
     * @returns Hash map with names and display values of related tables.
     */
    getRelatedTables(b: Boolean): HashMap;

    /**
     * Retrieves the number of rows in the GlideRecord object.
     * 
     * @returns An integer count of the rows
     */
    getRowCount(): Number;

    /**
     * Retrieves the row number set by saveLocation() or setLocation().To get the current row number, use getLocation().
     * 
     * @returns The saved row number.
     */
    getRowNumber(): Number;

    /**
     * Retrieves the table name associated with this GlideRecord.
     * 
     * @example
     * gs.log('Table: ' + current.getTableName()); 
     * gs.log('Parent: ' + current.parent.sys_id); 
     * var item = new GlideRecord('sc_req_item'); 
     * item.addQuery('sys_id', current.parent.sys_id); 
     * item.query(); 
     * if(item.next()){ 
     *   for(var variable in item.variable_pool) { gs.log(variable); 
     *   var answer = eval ("item.variable_pool." + variable + ".getDisplayValue()");
     * gs.log(answer);}
     * }
     * @returns A table name
     */
    getTableName(): String;

    /**
     * Retrieves the string value of an underlying element in a field.
     * 
     * @fieldName Name of a field
     * @returns The string value of the underlying element. Returns null if the field is empty, or the field does not exist.
     */
    getValue(fieldName: String): String;

    /**
     * Determines if the current record has any attachments.
     * 
     * @example
     * //Check for attachments and add link if there are any
     *   var attachment_link = '';
     *   var rec = new GlideRecord('sc_req_item');
     *   rec.addQuery('sys_id', current.request_item);
     *   rec.query();
     *   if(rec.next()){
     *     if(rec.hasAttachments()){
     *       attachment_link = gs.getProperty('glide.servlet.uri') + rec.getLink();
     *     }    
     *   }
     * @returns True if the current record has attachments, false otherwise.
     */
    hasAttachments(): Boolean;

    /**
     * Determines if there are any more records in the GlideRecord.
     * 
     * @example
     * if (gr.hasNext()) {
     *   dothis(); // found it, do it
     * } else {
     *   dothat(); // didn't find it
     * }
     * ;
     * @returns True if there are more records in the query set.
     */
    hasNext(): Boolean;

    /**
     * Creates an empty record suitable for population before an insert.
     * 
     * @example
     * var gr = new GlideRecord('to_do');
     * gr.initialize(); 
     * gr.name = 'first to do item'; 
     * gr.description = 'learn about GlideRecord'; 
     * gr.insert();
     */
    initialize();

    /**
     * Inserts a new record using the field values that have been set for the current record.
     * 
     * @example
     * var gr = new GlideRecord('to_do');
     * gr.initialize(); 
     * gr.name = 'first to do item'; 
     * gr.description = 'learn about GlideRecord'; 
     * gr.insert();
     * @returns The sys_id of the inserted record, or null if the record is not inserted.
     */
    insert(): String;

    /**
     * Inserts a new record and also inserts or updates any related records with the information provided.
     * 
     * @example
     * var inc = new GlideRecord('incident');
     * inc.initialize();
     * inc.short_description = 'New incident 1';
     * inc.caller_id.first_name = 'John';
     * inc.caller_id.last_name = 'Doe';
     * inc.insertWithReferences();
     * }
     * @example
     * var inc = new GlideRecord('incident');
     * inc.initialize();
     * inc.short_description = 'New incident 1';
     * inc.caller_id.setDisplayValue('David Loo');
     * inc.caller_id.first_name = 'John';
     * inc.caller_id.last_name = 'Doe';
     * inc.insertWithReferences();
     * }
     * @returns sys_id for the record inserted, or null if the record was not inserted.
     */
    insertWithReferences(): String;

    /**
     * Checks a table for the type\class of table.
     * 
     * @className Name of a type or class of record.
     * @returns True if table is an instance of the specified class.
     */
    instanceOf(className: String): Boolean;

    /**
     * Determines whether the current record has been inserted into the database. This method returns true only if the newRecord() method has been called. This method is useful for scripted ACL, and in the condition of UI actions, but should not be used in background scripts.
     * 
     * @example
     * answer = gs.hasRole("filter_admin") || current.isNewRecord()
     * @returns True if the current record is new (has not been inserted into the database.)
     */
    isNewRecord(): Boolean;

    /**
     * Determines if the table exists.
     * 
     * @example
     * var testTable = new GlideRecord('incident');
     * gs.print(testTable.isValid());
     * @returns True if the table is valid or if the record was successfully fetched, false otherwise.
     */
    isValid(): Boolean;

    /**
     * Determines if the specified field is defined in the current table.
     * 
     * @fieldName Name of a field.
     * @returns True if the field is valid, false otherwise.
     */
    isValidField(fieldName: String): Boolean;

    /**
     * Determines if the current record is valid.
     * 
     * @returns True if the current record is valid or false if past the end of the record set.
     */
    isValidRecord(): Boolean;

    /**
     * Creates a GlideRecord, set the default values for the fields and assign a unique id to the record.
     * 
     */
    newRecord();

    /**
     * Moves to the next record in the GlideRecord.Use this method to iterate through the records returned by a GlideRecord query.
     * 
     * @example
     * var rec = new GlideRecord('incident');
     * rec.query();
     * while (rec.next()) { 
     *   gs.print(rec.number + ' exists');
     * }
     * @returns True if there are more records in the query set.
     */
    next(): Boolean;

    /**
     * Retrieves the current operation being performed, such as insert, update, delete, etc.
     * 
     * @returns The current operation
     */
    operation(): String;

    /**
     * Specifies a field name to be used to order the query set. This may be called more than once to order by multiple fields.
     * 
     * @fieldName A field name
     * @example
     * function UpdateProjectWBS(project) {
     *   var count = 0;
     *   var child = new GlideRecord('pm_project_task');
     *   child.addQuery('parent', project.sys_id);
     *   child.orderBy('order');
     *   child.orderBy('number');
     *   child.query();
     *   var len = child.getRowCount().toString().length;
     *   var seq = 0;
     *   while (child.next()) {
     *     count += UpdateProjectTaskWBS(child, 1, ++seq, len, '');
     *   }
     *   gs.addInfoMessage(count + ' Project Tasks updated');
     * }
     */
    orderBy(fieldName: String);

    /**
     * Specifies a field used to order the query set in descending order.
     * 
     * @fieldName A field name.
     */
    orderByDesc(fieldName: String);

    /**
     * Runs the query against the table based on the filters specified by addQuery() and addEncodedQuery().This will query the GlideRecord table as well as any references of the table. One argument adds a query string. Usually this is performed without arguments, but a name/value pair can be specified.
     * 
     * @name A field name
     * @value A value
     * @example
     * var rec = new GlideRecord('incident');
     * rec.query();
     * while (rec.next()) { 
     *  gs.print(rec.number + ' exists');
     * }
     */
    query(name: Object, value: Object);

    /**
     * Used in domain separated instances. Similar to query(), runs the query against the table based on the filters specified by addQuery() and addEncodedQuery(), but ignores domains.This will query the GlideRecord table as well as any references of the table. One argument adds a query string. Usually this is performed without arguments, but a name/value pair can be specified.
     * 
     * @field A field name
     * @value A value
     * @example
     * var rec = new GlideRecord('incident');
     * rec.queryNoDomain();
     * while (rec.next()) { 
     *  gs.print(rec.number + ' exists');
     * }
     */
    queryNoDomain(field: Object, value: Object);

    /**
     * Sets the current record to be the record that was saved with saveLocation(). If saveLocation() has not been called, the current record is set to be the first record of the GlideRecord.
     * 
     */
    restoreLocation();

    /**
     * Save the current row number so that we can get back to this location using the restoreLocation() method.
     * 
     */
    saveLocation();

    /**
     * Sets a flag to indicate if the next database action (insert, update, delete) is to be aborted.Use in an onBefore business rule to prevent the database action from being done. The business rule continues to run after setAbortAction() is called. Calling setAbortAction() does not stop subsequent business rules from executing. Calling this method only prevents the database action from occurring.
     * 
     * @b True to abort next action, or false to allow the next action.
     * @example
     * if ((!current.u_date1.nil()) &amp;&amp; (!current.u_date2.nil())) {
     *   var start = current.u_date1.getGlideObject().getNumericValue();
     *   var end = current.u_date2.getGlideObject().getNumericValue();
     *   if (start &gt; end) {
     *     gs.addInfoMessage('start must be before end');
     *     current.u_date1.setError('start must be before end');
     *     current.setAbortAction(true);
     *   }
     * }
     */
    setAbortAction(b: Boolean);

    /**
     * Sets the duration field to a number of milliseconds since January 1, 1970, 00:00:00 GMT for a duration field. Does not require the creation of a GlideDateTime object because the duration field is already a GlideDateTime object.
     * 
     * @milliseconds Number of milliseconds spanned by the duration.
     * @example
     * var inc = new GlideRecord('incident');
     * inc.get('17c90efb13418700cc36b1422244b05d');
     * var timems = inc.calendar_duration.dateNumericValue();
     * timems = timems + 11*1000; 
     * inc.calendar_duration.setDateNumericValue(timems)
     * gs.info(inc.calendar_duration.getValue());
     */
    setDateNumericValue(milliseconds: Number);

    /**
     * Sets the specified field to the specified display value.For a reference field this is the display value for the table. For a date/time this is the time in the caller's current timezone.
     * 
     * @name Field name
     * @value Display value for the specified field.
     * @example
     * var gr = new GlideRecord('incident');
     * gr.get('46f09e75a9fe198100f4ffd8d366d17b');
     * gr.setDisplayValue('opened_at','2011-02-13 4:30:00');
     * gr.update();
     */
    setDisplayValue(name: String, value: Object);

    /**
     * Updates the record even if fields have not changed.
     * 
     * @force True to update even if fields have not changed, otherwise false.
     */
    setForceUpdate(force: Boolean);

    /**
     * Sets the limit for how many records are in the GlideRecord.
     * 
     * @limit Limit for records to fetch.
     * @example
     * var gr = new GlideRecord('incident');
     * gr.orderByDesc('sys_created_on');
     * gr.setLimit(10);
     * gr.query();
     */
    setLimit(limit: Number);

    /**
     * Sets the current row location.
     * 
     * @rowNumber The row number to set as the current row.
     */
    setLocation(rowNumber: Number);

    /**
     * Generates a new GUID and sets it as the unique id for the current record. This function applies only to new records. The GUID for an existing record cannot be changed
     * 
     * @example
     * var tsk_id = task.setNewGuid();
     *  
     * task.description = "Request: " + current.request.number;
     * task.description = task.description + "\n" + "Requested by: " + current.request.u_requested_by.name;
     * task.description = task.description + "\n" + "Requested for: " + current.request.u_requested_for.name;
     * task.description = task.description + "\n" + "Item: " + current.cat_item.name;
     *  
     * var gr = new GlideRecord ('task_rel_task');
     * //link the incident to the request (may need to review if it needs to be the item)
     * gr.parent = current.request;
     * gr.child = tsk_id;
     * gr.insert();
     */
    setNewGuid();

    /**
     * Generates a new GUID and sets it as the unique id for the current record, when inserting a new record.
     * 
     * @guid A string value for the new GUID
     */
    setNewGuidValue (guid: String);

    /**
     * Enables or disables using the reference field's display name when querying a reference field.
     * 
     * @queryReferences If true, will generate a string of display names. If false, will generate a string of sys_ids.
     */
    setQueryReferences(queryReferences: Boolean);

    /**
     * Disable or enable the running of any engines (approval rules / assignment rules).
     * 
     * @e If true, enables engines. If false disables engines.
     */
    setUseEngines(e: Boolean);

    /**
     * Sets the specified field to the specified value.Normally a script would do a direct assignment, for example, gr.category = value. However, if in a script the element name is a variable, then gr.setValue(elementName, value) can be used. When setting a value, ensure the data type of the field matches the data type of the value you enter. This method cannot be used on journal fields.If the value parameter is null, the record is not updated, and an error is not thrown.
     * 
     * @name Field name
     * @value A value to be assigned.
     */
    setValue(name: String, value: Object);

    /**
     * Enables or disables the running of business rules that might normally be triggered by subsequent actions. If the e parameter is set to false, an insert/update will not be audited. Auditing only happens when the parameter is set to true for a GlideRecord operation.
     * 
     * @e If true (default), enables business rules. If false, disables business rules.
     * @example
     * doit('name1','name2'); 
     *  
     * function doit(username1,username2) { 
     *  
     *   var usr1 = new GlideRecord('sys_user');
     *   var usr2 = new GlideRecord('sys_user');
     *   var num = 0;
     *  
     *   if (usr1.get('user_name',username1) &amp;&amp; usr2.get('user_name',username2)) {
     *     var ref;
     *     var dict = new GlideRecord('sys_dictionary');
     *     dict.addQuery('reference','sys_user');
     *     dict.addQuery('internal_type','reference');
     *     dict.query();
     *     while (dict.next()) {
     *       num = 0;
     *       ref = new GlideRecord(dict.name.toString());
     *       ref.addQuery(dict.element,usr1.sys_id);
     *       ref.query();
     *       while (ref.next()) {
     *         ref.setValue(dict.element.toString(),usr2.sys_id); 
     *         ref.setWorkflow(false);
     *         ref.update();
     *         num++;
     *       }
     *       if (num &gt; 0) {
     *         gs.print(dict.element + ' changed from ' + usr1.user_name + 
     *           ' to ' + usr2.user_name + ' in ' + num + ' ' + dict.name + ' records');
     *       }
     *     }
     *   }
     * }
     */
    setWorkflow(e: Boolean);

    /**
     * Updates the GlideRecord with any changes that have been made. If the record does not exist, it is inserted.
     * 
     * @reason A string designating the reason for the update. The reason is displayed in the audit record.
     * @example
     *   var gr = new GlideRecord('task_ci');
     * gr.addQuery();
     * gr.query();
     * var count = gr.getRowCount();
     * if (count &gt; 0) {
     *    var allocation = parseInt(10000 / count) / 100;
     *    while (gr.next()) {
     *       gr.u_allocation = allocation;
     *       gr.update();
     *    }
     * }
     * @returns Unique id of the new or update record. Returns null if the update fails.
     */
    update(reason: Object): String;

    /**
     * Updates each GlideRecord in the list with any changes that have been made.When changing field values, use setValue() instead of directly setting the field (field = something). When using updateMultiple(), directly setting the field (gr. state = 4) results in all records in the table being updated instead of just the records returned by the query.Do not use this method with the chooseWindow() or setLimit() methods when working with large tables.This method sets new values and does not clear existing values.
     * 
     * @example
     * // update the state of all active incidents to 4 - "Awaiting User Info"
     * var gr = new GlideRecord('incident')
     * gr.addQuery('active', true);
     * gr.query();
     * gr.setValue('state',  4);
     * gr.updateMultiple();
     */
    updateMultiple();

    /**
     * Updates a record and also inserts or updates any related records with the information provided.
     * 
     * @reason A string designating the reasons for the updates. The reason is displayed in the audit record.
     * @example
     * var inc = new GlideRecord('incident');
     * inc.get(inc_sys_id);  // Looking up an existing incident record where 'inc_sys_id' represents the sys_id of a incident record
     * inc.caller_id.first_name = 'John';
     * inc.caller_id.last_name = 'Doe';
     * inc.updateWithReferences();
     * }
     * @returns The sys_id for the record being updated.
     */
    updateWithReferences(reason: Object): String;

    /**
     * Moves to the next record in the GlideRecord. Provides the same functionality as next(), intended to be used in cases where the GlideRecord has a column named next.
     * 
     * @example
     * var rec = new GlideRecord('sys_template');
     * rec.query();
     * while (rec._next()) { 
     *   gs.print(rec.number + ' exists');
     * }
     * @returns True if there are more records in the query set.
     */
    _next(): Boolean;

    /**
     * Identical to query(). This method is intended to be used on tables where there is a column named query, which would interfere with using the query() method.Runs the query against the table based on the filters specified by the addQuery() and addEncodedQuery() methods. This will query the GlideRecord table as well as any references of the table. One argument adds a query string. Usually this is performed without arguments, but a name/value pair can be specified.
     * 
     * @name A field name
     * @value A value
     * @example
     * var rec = new GlideRecord('sys_app_module');
     * rec._query();
     * while (rec.next()) { 
     *  gs.print(rec.number + ' exists');
     * }
     */
    _query(name: Object, value: Object);

}

/**
 * A utility class for working with GlideRecords The GlideRecordUtil class is available in server-side scripts.
 * 
 * 
 */
declare class GlideRecordUtil {



    /**
     * Returns a GlideRecord instance positioned to the given CI sys_id, and of the right class (table).
     * 
     * @sys_id The sys_id of the desired CI.
     * @example
     * var gr = new GlideRecordUtil().getCIGR("2dfd7c8437201000deeabfc8bcbe5d56");
     * @returns A GlideRecord instance positioned to the given CI sys_id, and of the right class (table).
     */
    getCIGR(sys_id: String): GlideRecord;

    /**
     * Returns a list of all the fields in the specified GlideRecord.
     * 
     * @gr A GlideRecord instance positioned to a valid record.
     * @example
     * var queryString = "priority=1^ORpriority=2";
     * var gr = new GlideRecord('incident');
     * gr.addEncodedQuery(queryString);
     * gr.query();
     * gr.next());
     * 
     * var gRU = new GlideRecordUtil();
     * var fieldList = gRU.getFields(gr);
     * gs.info(fieldList);
     * @returns An array of field names for the specified GlideRecord.
     */
    getFields(gr: GlideRecord): String;

    /**
     * Returns a GlideRecord instance for the given table, positioned to the given sys_id, and of the right class (table).This method is useful when you need to load a GlideRecord from a sys_id, but you don't know what the actual table is (because it may be extended from the base table). This method always returns a GlideRecord of the correct type base_table: the name of the base table that the specified sys_id is in.
     * 
     * @baseTable The name of the base table containing the sys_id.
     * @sys_id The sys_id of the desired record.
     * @example
     * var gr = new GlideRecordUtil().getGR("cmdb_ci_computer", "2dfd7c8437201000deeabfc8bcbe5d56");
     * @returns The GlideRecord for the specified sys_id.
     */
    getGR(baseTable: String, sys_id: String): GlideRecord;

    /**
     * Returns a Java ArrayList of the ancestors of the given table name.For example, given cmdb_ci_linux_server, this would return cmdb_ci, cmdb_ci_computer, cmdb_ci_server, and cmdb_ci_linux_server.
     * 
     * @tableName Name of the table
     * @example
     * var tables = new GlideRecordUtil().getTables("cmdb_ci_linux_server");
     * gs.log(tables.join(","));  
     * // The result would be "cmdb_ci, cmdb_ci_computer, cmdb_ci_server, cmdb_ci_linux_server".
     * @returns A list of ancestors of the specified table
     */
    getTables(tableName: String): ArrayList;

    /**
     * Sets the fields in the specified GlideRecord with the field values contained in the specified hashmap, unless that field name is in the ignore hashmap.
     * 
     * @hashMap An Object instance (being used as a hashmap), with properties named for fields and containing the fields' value.
     * @GlideRecord The GlideRecord instance to receive the field values.
     * @ignore An optional hashmap of field names to ignore.
     * @example
     * var gr = new GlideRecordUtil().getGR("cmdb_ci_computer", "2dfd7c8437201000deeabfc8bcbe5d56");   
     * var obj = {"name": "xyz", "os": "windows 2000", "sys_created_by", "aleck.lin"};
     * var ignore = {"sys_created_by": true};
     * new GlideRecordUtil().mergeToGR(obj, gr, ignore);
     * gr.update();
     */
    mergeToGR(hashMap: Object, GlideRecord: GR, ignore: Object);

    /**
     * Populates the given hashmap from the given GlideRecord instance. Each field in the GlideRecord becomes a property in the hashmap.
     * 
     * @hashMap An object being used as a hashmap.
     * @gr A GlideRecord instance positioned to a valid record.
     * @ignore An optional hashmap of file names not to populate.
     * @example
     * var objectToPopulate = {};
     * var gr = new GlideRecordUtil().getGR("cmdb_ci_computer", "2dfd7c8437201000deeabfc8bcbe5d56");
     * var ignore = {"sys_created_on": true, "sys_updated_by": true};
     * new GlideRecordUtil().populateFromGR(objectToPopulate, gr, ignore);
     * // Now the objectToPopulate contains field/value pairs from the computer GlideRecord
     */
    populateFromGR(hashMap: Object, gr: GlideRecord, ignore: Object);

}

/**
 * The GlideScopedEvaluator API allows you to evaluate scripts in a GlideRecord field from both scoped and global server scripts. The GlideScopedEvaluator API evaluates scripts within the script field type. The scope of the record defines the scope of the script.
 * 
 * 
 */
declare class GlideScopedEvaluator {



    /**
     * Instantiates a GlideScopedEvaluator object.
     * 
     */
    constructor();

    /**
     * Evaluates a script from a GlideRecord field.
     * 
     * @grObj The GlideRecord containing a script expression.
     * @scriptField (Optional) The name of the field containing the script expression.
     * @variables (Optional) A map of variables with name-value pairs. These variables are available to the script during execution of this method.
     * @example
     * // For this example, we created a table: "u_global_table" with two columns: "short_description", "test_script"
     * // "test_script" will store the script to be evaluated by GlideScopedEvaluator.
     * gr = new GlideRecord('u_global_table'); 
     * gr.u_short_description = 'Testing GlideScopedEvaluator';  
     * gr.u_test_script = "gs.getUser().getName() + ' says ' + greeting; "; 
     * gr.insert(); 
     *  
     * // setup variables to be used by the script
     * var vars = {'greeting' : 'hello'};
     *  
     * //Evaluate the script from the field
     * var evaluator = new GlideScopedEvaluator(); 
     * gr = new GlideRecord('u_global_table'); 
     * gr.addQuery('u_short_description','Testing GlideScopedEvaluator'); 
     * gr.query(); 
     * if (gr.next()) { 
     *     gs.info(evaluator.evaluateScript(gr, 'u_test_script', vars));
     * }
     * @returns The result of the script execution.
     */
    evaluateScript(grObj: GlideRecord, scriptField: String, variables: Object): Object;

    /**
     * Returns a variable from a GlideScopedEvaluator object.
     * 
     * @name The name of the variable.
     * @example
     * //setting up a record that contains the script to be executed.
     * gr = new GlideRecord('u_global_table'); 
     * gr.u_short_description = 'Calculate Addition';  
     * gr.u_test_script = "result = x + y"; 
     * gr.insert(); 
     *  
     * var evaluator = new GlideScopedEvaluator();
     * evaluator.putVariable('x', 100);
     * evaluator.putVariable('y', 200);
     * evaluator.putVariable('result', null);
     *  
     * // Now retrieve the result 
     * gr = new GlideRecord('u_global_table'); 
     * gr.addQuery('u_short_description','Calculate Addition'); 
     * gr.query(); 
     * if (gr.next()) { 
     *     evaluator.evaluateScript(gr, 'u_test_script', null);
     *     gs.info(evaluator.getVariable('result'));
     * }
     * @returns The value of the specified variable.
     */
    getVariable(name: String): Object;

    /**
     * Puts a variable into the GlideScopedEvaluator object. These variables are available to the script that this GlideScopedEvaluator object runs.
     * 
     * @name The name of the variable.
     * @value The value of the variable.
     * @example
     * //setting up a record that contains the script to be executed.
     * gr = new GlideRecord('u_global_table'); 
     * gr.u_short_description = 'Calculate Addition';  
     * gr.u_test_script = "result = x + y"; 
     * gr.insert(); 
     *  
     * var evaluator = new GlideScopedEvaluator();
     * evaluator.putVariable('x', 100);
     * evaluator.putVariable('y', 200);
     * evaluator.putVariable('result', null);
     *  
     * // Now retrieve the result 
     * gr = new GlideRecord('u_global_table'); 
     * gr.addQuery('u_short_description','Calculate Addition'); 
     * gr.query(); 
     * if (gr.next()) { 
     *     evaluator.evaluateScript(gr, 'u_test_script', null);
     *     gs.info(evaluator.getVariable('result'));
     * }
     */
    putVariable(name: String, value: Object);

}

/**
 * The GlideSession API allows you to find information about the current session. 
 * 
 * 
 */
declare class GlideSession {



    /**
     * Clears a session client value previously set with putClientData().This method is used in a client script to clear data values that were set by a server script using the putClientData() method.
     * 
     * @paramName Name of the client data to clear.
     * @example
     * var session = gs.getSession();
     * session.putClientData('custName', 'Harry');
     * var clientData = session.getClientData('custName');
     * gs.info(clientData);
     *  
     * session.clearClientData('custName');
     * clientData = session.getClientData('custName');
     * gs.info(clientData);
     */
    clearClientData(paramName: String);

    /**
     * Returns a session client value previously set with putClientData().This method is used in a client script to retrieve data values that were set by a server script that used the putClientData() method.
     * 
     * @paramName Name of the client data to retrieve.
     * @example
     * var session = gs.getSession();
     * session.putClientData('test1', 'Harry');
     * var clientData = session.getClientData('test1');
     * gs.info(clientData);
     * @returns The client data as a string.
     */
    getClientData(paramName: String): String;

    /**
     * Gets the session's language code.
     * 
     * @example
     * var session = gs.getSession();
     * var language = session.getLanguage();
     * gs.info(language);
     * @returns The session's language code.
     */
    getLanguage(): String;

    /**
     * Gets a list of roles for the current user.The list of roles does not reflect any changes made during the current user session. To get the updated list of roles, the user must log out and log back in.
     * 
     * @example
     * gs.info(gs.getSession().getRoles());
     * @returns A comma separated list of roles.
     */
    getRoles(): String;

    /**
     * Gets the name of the session's time zone.
     * 
     * @example
     * var session = gs.getSession();
     * var zoneName = session.getTimeZoneName();
     * gs.info(zoneName);
     * @returns The name of the session's time zone.
     */
    getTimeZoneName(): String;

    /**
     * Determines if the current session is interactive.An interactive session is one that involves an end-user interacting with a user interface that then retrieves information from a server. An example of this type of session is when a user logs in using the log-in screen or uses a form to query a data store. A non-interactive session is one that only involves programmatic interaction with a server such as a SOAP request to retrieve data.
     * 
     * @example
     * var interActive = gs.getSession().isInteractive();
     * gs.info(interActive);
     * @returns True if the session is interactive.
     */
    isInteractive(): Boolean;

    /**
     * Determines if the current user is currently logged in.
     * 
     * @example
     * var session = gs.getSession();
     * var loggedIn = session.isLoggedIn();
     * gs.info(loggedIn);
     * @returns True if the current user is logged in.
     */
    isLoggedIn(): Boolean;

    /**
     * Sets a session client value that can be retrieved with getClientData(). This method is used in a server side script that runs when a form is created.
     * 
     * @paramName Name of the client parameter to set.
     * @paramValue Parameter value.
     * @example
     * var session = gs.getSession();
     * session.putClientData('test1', 'Harry');
     * var clientData = session.getClientData('test1');
     * gs.info(clientData);
     */
    putClientData(paramName: String, paramValue: String);

}

/**
 * The GlideSystem (referred to by the variable name 'gs' in any server-side JavaScript) API provides a number of convenient methods to get information about the system, the current logged in user, etc. Many of the GlideSystem methods facilitate the easy inclusion of dates in query ranges, and are most often used in filters and reporting.
 * 
 * 
 */
declare class GlideSystem {



    /**
     * Adds an error message for the current session.Use getErrorMessages() to retrieve a list of error messages currently being shown.
     * 
     * @message The message to add.
     * @example
     * gs.include("PrototypeServer");
     *   var ValidatePasswordStronger = Class.create();
     *   ValidatePasswordStronger.prototype = {
     *        process : function() {
     *           var user_password = request.getParameter("user_password");
     *           var min_len = 8;
     *           var rules = "Password must be at least " + min_len + 
     *              " characters long and contain a digit, an uppercase letter, and a lowercase letter.";
     *           if (user_password.length() &lt; min_len) {
     *              gs.addErrorMessage("TOO SHORT: " + rules);
     *              return false;
     *           }
     *           var digit_pattern = new RegExp("[0-9]", "g");
     *           if (!digit_pattern.test(user_password)) {
     *              gs.addErrorMessage("DIGIT MISSING: " + rules);
     *              return false;
     *           }
     *           var upper_pattern = new RegExp("[A-Z]", "g");
     *           if (!upper_pattern.test(user_password)) {
     *              gs.addErrorMessage("UPPERCASE MISSING: " + rules);
     *              return false;
     *           }
     *           var lower_pattern = new RegExp("[a-z]", "g");
     *           if (!lower_pattern.test(user_password)) {
     *              gs.addErrorMessage("LOWERCASE MISSING: " + rules);
     *              return false;
     *           }
     *           return true; // password is OK
     *        }
     *   }
     * [edit]
     */
    addErrorMessage(message: Object);

    /**
     * Adds an info message for the current session.Use getInfoMessages() to retrieve the list of info messages being shown. This method is not supported for asynchronous business rules and cannot be used within transform scripts.
     * 
     * @message The message to add.
     * @example
     * if ((!current.u_date1.nil()) &amp;&amp; (!current.u_date2.nil())) {
     *   var start = current.u_date1.getGlideObject().getNumericValue();
     *   var end = current.u_date2.getGlideObject().getNumericValue();
     *   if (start &gt; end) {
     *     gs.addInfoMessage('start must be before end');
     *     current.u_date1.setError('start must be before end');
     *     current.setAbortAction(true);
     *   }
     * }
     */
    addInfoMessage(message: Object);

    /**
     * Adds a message for the current session.
     * 
     * @type Type of message
     * @message The message
     * @example
     * gs.include("FormInfoHeader");
     * var fi = new FormInfoHeader();
     * var s = 'An incident ' + current.number + ' has been opened for your request.&lt;br/&gt;';
     * s += 'The IT department will contact you when the password is reset or for further information.&lt;br/&gt;';
     * //s += 'You can track status from the &lt;a href="home.do" class="breadcrumb" &gt;Home Page&lt;/a&gt; &lt;br/&gt;';
     * fi.addMessage(s);
     * producer.redirect = 'home.do?sysparm_view=ess';
     */
    addMessage(type: String, message: Object);

    /**
     * Gets the date and time for the beginning of last month in GMT.
     * 
     * @returns The GMT beginning of last month, in the format yyyy-mm-dd hh:mm:ss.
     */
    beginningOfLastMonth(): String;

    /**
     * Returns the date and time for the beginning of last week in GMT.
     * 
     * @returns The GMT beginning of last week, in the format yyyy-mm-dd hh:mm:ss.
     */
    beginningOfLastWeek(): String;

    /**
     * Returns the date and time for the beginning of next month in GMT.
     * 
     * @returns The GMT beginning of next month, in the format yyyy-mm-dd hh:mm:ss.
     */
    beginningOfNextMonth(): String;

    /**
     * Gets the date and time for the beginning of next week in GMT.
     * 
     * @returns The GMT beginning of next week, in the format yyyy-mm-dd hh:mm:ss.
     */
    beginningOfNextWeek(): String;

    /**
     * Returns the date and time for the beginning of next year in GMT.
     * 
     * @returns The GMT beginning of next year, in the format yyyy-mm-dd hh:mm:ss.
     */
    beginningOfNextYear(): String;

    /**
     * Returns the date and time for the beginning of this month in GMT.
     * 
     * @returns The GMT beginning of this month, in the format yyyy-mm-dd hh:mm:ss.
     */
    beginningOfThisMonth(): String;

    /**
     * Returns the date and time for the beginning of this quarter in GMT.
     * 
     * @returns The GMT beginning of this quarter, in the format yyyy-mm-dd hh:mm:ss.
     */
    beginningOfThisQuarter(): String;

    /**
     * Returns the date and time for the beginning of this week in GMT.
     * 
     * @returns The GMT beginning of this week, in the format yyyy-mm-dd hh:mm:ss.
     */
    beginningOfThisWeek(): String;

    /**
     * Returns the date and time for the beginning of this year in GMT.
     * 
     * @returns GMT beginning of this year, in the format yyyy-mm-dd hh:mm:ss
     */
    beginningOfThisYear(): String;

    /**
     * Retrieves the date and time for the beginning of today in GMT.
     * 
     * @example
     * var beginToday = gs.beginningOfToday(); 
     * var endToday = gs.endOfToday(); 
     * var beginTomorrow = gs.beginningOfTomorrow(); 
     * var endTomorrow = gs.endOfTomorrow(); 
     * var beginYesterday = gs.beginningOfYesterday(); 
     * var endYesterday = gs.endOfYesterday(); 
     * 
     * gs.info('beginningOfToday: ' + beginToday); 
     * gs.info('endOfToday: ' + endToday); 
     * gs.info('-----------'); 
     * gs.info('beginningOfTomorrow: ' + beginTomorrow); 
     * gs.info('endOfTomorrow: ' + endTomorrow); 
     * gs.info('beginningOfYesterday: ' + beginYesterday); 
     * gs.info('endOfYesterday: ' + endYesterday); 
     * gs.info('-----------'); 
     * var gdt1 = new GlideDateTime(beginToday); 
     * var gdt2 = new GlideDateTime(beginTomorrow); 
     * var dur = GlideDateTime.subtract(gdt1, gdt2); //the difference between gdt1 and gdt2 
     * gs.info('BeginTomorrow: ' + dur.getDisplayValue()); 
     * 
     * var gdt1 = new GlideDateTime(endToday); 
     * var gdt2 = new GlideDateTime(endTomorrow); 
     * var dur = GlideDateTime.subtract(gdt1, gdt2); //the difference between gdt1 and gdt2 
     * gs.info('EndTomorrow: ' + dur.getDisplayValue()); 
     * 
     * var gdt1 = new GlideDateTime(beginToday); 
     * var gdt2 = new GlideDateTime(beginYesterday); 
     * var dur = GlideDateTime.subtract(gdt2, gdt1); //the difference between gdt1 and gdt2 
     * gs.info('BeginningYesterday: ' + dur.getDisplayValue()); 
     * 
     * var gdt1 = new GlideDateTime(endToday); 
     * var gdt2 = new GlideDateTime(endYesterday); 
     * var dur = GlideDateTime.subtract(gdt2, gdt1); //the difference between gdt1 and gdt2 
     * gs.info('EndYesterday: ' + dur.getDisplayValue());
     * @returns The GMT beginning of today, in the format yyyy-mm-dd hh:mm:ss.
     */
    beginningOfToday(): String;

    /**
     * Retrieves the (UTC) beginning of tomorrow adjusted for the timezone of the current session.
     * 
     * @example
     * var today = new GlideDateTime(gs.beginningOfTomorrow()).getNumericValue();
     * @returns GMT in the format yyyy-mm-dd hh:mm:ss.
     */
    beginningOfTomorrow(): String;

    /**
     * Retrieves the date and time for the beginning of yesterday in GMT.
     * 
     * @example
     * var start = new GlideDateTime();
     * start.setValue(gs.beginningOfYesterday());
     * @returns The GMT beginning of yesterday, in the format yyyy-mm-dd hh:mm:ss.
     */
    beginningOfYesterday(): String;

    /**
     * Calculate the difference between two dates using the default calendar.Calendars are now legacy. If Schedules are being used, see the topic Calculate Duration Given a Schedule.
     * 
     * @startDate The starting date to compare in the current user's date format.
     * @endDate The ending date to compare in the current user's date format.
     * @numericValue If true, the return value will be formatted in number of seconds; if false the return value will be formatted ddd hh:mm:ss.
     * @returns If the numericValue parameter is true, returns the difference between the two dates as an integer number of seconds; if false, returns the difference between the two dates in the format ddd hh:mm:ss.
     */
    calDateDiff(startDate: String, endDate: String, numericValue: Boolean): String;

    /**
     * Calculates the difference between two dates.This method expects the earlier date as the first parameter and the later date as the second parameter; otherwise, the method returns the difference as a negative value. Use getDisplayValue() to convert the strings to the expected format.This method expects parameters in the user/system date time format, which may not be the same as the internal format. Using parameters in formats other than the user/system date time format may return invalid results.If you are working with GlideDateTime objects use the GlideDateTime subtract() method instead of dateDiff().
     * 
     * @startDate The starting date to compare in the current user's date format.
     * @endDate The ending date to compare in the current user's date format.
     * @numericValue If true, the return value will be formatted in number of seconds; if false the return value will be formatted ddd hh:mm:ss.
     * @example
     * // Given two date/times as DateTime objects
     * // Set the values this way to ensure a consistent input time
     * var date1 = new GlideDateTime();
     * var date2 = new GlideDateTime();
     * date1.setDisplayValueInternal('2014-01-01 12:00:00');
     * date2.setDisplayValueInternal('2014-01-01 13:00:00');
     *  
     * // Determine the difference as number of seconds (returns a string)
     * // Use getDisplayValue() to convert the string to the format expected by dateDiff()
     * var diffSeconds = gs.dateDiff(date1.getDisplayValue(), date2.getDisplayValue(), true);
     *  
     * // JavaScript will coerce diffSeconds from a string to a number
     * // since diffSeconds is being compared to a number
     * var msg = (diffSeconds &lt;= 0) ? ' is on or after ' : ' is before ';
     * gs.print(date1.getDisplayValue() + msg + date2.getDisplayValue())
     * @returns If the numericValue parameter is true, returns the difference between the two dates as an integer number of seconds; if false, returns the difference between the two dates in the format ddd hh:mm:ss.
     */
    dateDiff(startDate: String, endDate: String, numericValue: Boolean): String;

    /**
     * Generates a date and time for the specified date in GMT.To use the dateGenerate() method in a scoped application, use the corresponding scoped method: dateGenerate().
     * 
     * @date Format: yyy-mm-dd
     * @range Start, end, or a time in the 24 hour format hh:mm:ss.
     * @returns A date and time in the format yyyy-mm-dd hh:mm:ss. If range is start, the returned value is yyyy-mm-dd 00:00:00; If range is end the return value is yyyy-mm-dd 23:59:59.
     */
    dateGenerate(date: String, range: String): String;

    /**
     * Returns a date and time for a certain number of days ago.
     * 
     * @days Number of days
     * @example
     * function contractNoticeDue() {
     *     var gr = new GlideRecord("contract");
     *     gr.addQuery("u_contract_status", "Active");
     *     gr.query();
     *     while (gr.next()) {
     *         if ((gr.u_termination_date &lt;= gs.daysAgo(-90)) &amp;&amp; (gr.u_contract_duration == "Long")) {
     *             gr.u_contract_status = "In review";
     *         } 
     *         else if ((gr.u_termination_date &lt;= gs.daysAgo(-50)) &amp;&amp; (gr.u_contract_duration == "Medium")) {
     *             gr.u_contract_status = "In review";
     *         } 
     *         else if ((gr.u_termination_date &lt;= gs.daysAgo(-10)) &amp;&amp; (gr.u_contract_duration == "Short")) {
     *             gr.u_contract_status = "In review";
     *         }
     *     }
     *     gr.update();
     * }
     * @returns The GMT in the format yyyy-mm-dd hh:mm:ss.
     */
    daysAgo(days: Number): String;

    /**
     * Returns a date and time for the end of the day a specified number of days ago.
     * 
     * @days Integer number of days
     * @returns The GMT end of the day in the format yyyy-mm-dd hh:mm:ss.
     */
    daysAgoEnd(days: Number): String;

    /**
     * Returns the date and time of the beginning of the day for the specified number of days ago. The returned date and time reflect the time zone of the current session (local time).
     * 
     * @days Number of days ago
     * @example
     * if (due_in == "1 Day") {
     *   dd = gs.daysAgoLocal(-1);
     * }
     * if (due_in == "1 Week") {
     *   dd = gs.daysAgoLocal(-7);
     * }
     * @returns Local date and time for the beginning of the day in the user-defined date time format. If the date time format is not modified from its initial value the format is yyyy-mm-dd hh:mm:ss.
     */
    daysAgoLocal(days: Number): String;

    /**
     * Returns a date and time for the beginning of the day a specified number of days ago.
     * 
     * @days Integer number of days
     * @example
     * var gr = new GlideRecord('sysapproval_approver');
     * gr.addQuery('state', 'requested');
     * gr.addQuery('sys_updated_on', '&lt;', gs.daysAgoStart(5));
     * gr.query();
     * @returns GMT start of the day in the format yyyy-mm-dd hh:mm:ss
     */
    daysAgoStart(days: String): String;

    /**
     * Returns the date and time for the end of last month in GMT.
     * 
     * @returns The GMT end of last month, in the format yyyy-mm-dd hh:mm:ss.
     */
    endOfLastMonth(): String;

    /**
     * Returns the date and time for the end of last week in GMT.
     * 
     * @returns GMT end of last week, in the format yyyy-mm-dd hh:mm:ss
     */
    endOfLastWeek(): String;

    /**
     * Returns the date and time for the end of last year in GMT.
     * 
     * @returns GMT in format yyyy-mm-dd hh:mm:ss.
     */
    endOfLastYear(): String;

    /**
     * Returns the date and time for the end of next month in GMT.
     * 
     * @returns The GMT in the format yyyy-mm-dd hh:mm:ss.
     */
    endOfNextMonth(): String;

    /**
     * Gets the date and time for the end of next week in GMT.
     * 
     * @returns The GMT in the format yyyy-mm-dd hh:mm:ss.
     */
    endOfNextWeek(): String;

    /**
     * Returns the date and time for the end of next year in GMT.
     * 
     * @returns The GMT in the format yyyy-mm-dd hh:mm:ss.
     */
    endOfNextYear(): String;

    /**
     * Returns the date and time for the end of this month in GMT.
     * 
     * @returns GMT in the format (yyyy-mm-dd huh:mm:ss)
     */
    endOfThisMonth(): String;

    /**
     * Returns the date and time for the end of this quarter in GMT.
     * 
     * @returns GMT in the format yyyy-mm-dd hh:mm:ss.
     */
    endOfThisQuarter(): String;

    /**
     * Returns the date and time for the end of this week in GMT.
     * 
     * @returns GMT in the format yyyy-mm-dd hh:mm:ss
     */
    endOfThisWeek(): String;

    /**
     * Returns the date and time for the end of this year in GMT.
     * 
     * @returns GMT in the format yyyy-mm-dd hh:mm:ss.
     */
    endOfThisYear(): String;

    /**
     * Retrieves the date and time for the end of today in GMT.
     * 
     * @example
     * var beginToday = gs.beginningOfToday(); 
     *         var endToday = gs.endOfToday(); 
     *         var beginTomorrow = gs.beginningOfTomorrow(); 
     *         var endTomorrow = gs.endOfTomorrow(); 
     *         var beginYesterday = gs.beginningOfYesterday(); 
     *         var endYesterday = gs.endOfYesterday(); 
     *         
     *         gs.info('beginningOfToday: ' + beginToday); 
     *         gs.info('endOfToday: ' + endToday); 
     *         gs.info('-----------'); 
     *         gs.info('beginningOfTomorrow: ' + beginTomorrow); 
     *         gs.info('endOfTomorrow: ' + endTomorrow); 
     *         gs.info('beginningOfYesterday: ' + beginYesterday); 
     *         gs.info('endOfYesterday: ' + endYesterday); 
     *         gs.info('-----------'); 
     *         var gdt1 = new GlideDateTime(beginToday); 
     *         var gdt2 = new GlideDateTime(beginTomorrow); 
     *         var dur = GlideDateTime.subtract(gdt1, gdt2); //the difference between gdt1 and gdt2 
     *         gs.info('BeginTomorrow: ' + dur.getDisplayValue()); 
     *         
     *         var gdt1 = new GlideDateTime(endToday); 
     *         var gdt2 = new GlideDateTime(endTomorrow); 
     *         var dur = GlideDateTime.subtract(gdt1, gdt2); //the difference between gdt1 and gdt2 
     *         gs.info('EndTomorrow: ' + dur.getDisplayValue()); 
     *         
     *         var gdt1 = new GlideDateTime(beginToday); 
     *         var gdt2 = new GlideDateTime(beginYesterday); 
     *         var dur = GlideDateTime.subtract(gdt2, gdt1); //the difference between gdt1 and gdt2 
     *         gs.info('BeginningYesterday: ' + dur.getDisplayValue()); 
     *         
     *         var gdt1 = new GlideDateTime(endToday); 
     *         var gdt2 = new GlideDateTime(endYesterday); 
     *         var dur = GlideDateTime.subtract(gdt2, gdt1); //the difference between gdt1 and gdt2 
     *         gs.info('EndYesterday: ' + dur.getDisplayValue());
     * @returns GMT in the format yyyy-mm-dd hh:mm:ss.
     */
    endOfToday(): String;

    /**
     * Retrieves the date and time for the end of tomorrow in GMT.
     * 
     * @example
     * var tomorrowEnd = new GlideDateTime();
     * tomorrowEnd.setValue(gs.endOfTomorrow());
     * @returns GMT in the format yyyy-mm-dd hh:mm:ss.
     */
    endOfTomorrow(): String;

    /**
     * Gets the date and time for the end of yesterday in GMT.
     * 
     * @example
     * var yesterdayEnd = new GlideDateTime();
     * yesterdayEnd.setValue(gs.endOfYesterday());
     * @returns GMT in the format (yyyy-mm-dd huh:mm:ss).
     */
    endOfYesterday(): String;

    /**
     * Queues an event for the event manager.
     * 
     * @name Name of the event being queued.
     * @glideRecord GlideRecord object, such as "current".
     * @parm1 (Optional) Saved with the instance if specified.
     * @parm2 (Optional) Saved with the instance if specified.
     * @queue Name of the queue.
     * @example
     * if (current.operation() != 'insert' &amp;&amp; current.comments.changes()) {
     *     gs.eventQueue("incident.commented", current, gs.getUserID(), gs.getUserName());
     * }
     */
    eventQueue(name: String, glideRecord: Object, parm1: String, parm2: String, queue: String);

    /**
     * Queues an event for the event manager at a specified date and time.
     * 
     * @name Name of the event being queued.
     * @glideRecord GlideRecord object, such as "current".
     * @parm1 (Optional) Saved with the instance if specified.
     * @parm2 (Optional) Saved with the instance if specified.
     * @expiration Date and time to process this event.
     * @example
     * if (current.operation() != 'insert' &amp;&amp; current.comments.changes()) {
     *     gs.eventQueueScheduled("incident.commented", current, gs.getUserID(), gs.getUserName(), new GlideDateTime('2018-06-02 20:00:00'));
     * }
     */
    eventQueueScheduled(name: String, glideRecord: Object, parm1: String, parm2: String, expiration: Object);

    /**
     * Clears session messages saved using addErrorMessage() or addInfoMessage().Session messages are shown at the top of the form. In client side scripts, use g_form.clearMessages() to remove session messages.
     * 
     * @example
     * gs.flushMessages();
     */
    flushMessages();

    /**
     * Returns the file path to the user's avatar.
     * 
     * @example
     * var avatarFile = gs.getUser().getAvatar();        
     * gs.addInfoMessage('User avatar ID: ' + avatarFile);
     * @returns The file path to the user's avatar.
     */
    getAvatar(): String;

    /**
     * Gets the name of the current scope.
     * 
     * @returns The current scope name
     */
    getCurrentScopeName(): String;

    /**
     * Retrieves the display column for the table.
     * 
     * @tableName Name of the table from which to get the display column name.
     * @example
     * // Return the sys_id value for a given table and its display value
     * function GetIDValue(table, displayValue) { 
     *     var rec = new GlideRecord(table);
     *     var dn = gs.getDisplayColumn(table);
     *     if (rec.get(dn, displayValue))
     *         return rec.sys_id;
     *     else
     *         return null;
     * }
     * @returns Display column name
     */
    getDisplayColumn(tableName: String): String;

    /**
     * Returns the display value for a specified field on a record.
     * 
     * @tableName Name of the table
     * @recordID sysid for the record
     * @fieldName Name of the field
     * @returns Display value for the field
     */
    getDisplayValueFor(tableName: String, recordID: String, fieldName: String): String;

    /**
     * Returns the list of error messages for the session that were added by addErrorMessage().
     * 
     * @returns List of error messages
     */
    getErrorMessages(): String;

    /**
     * Retrieves the property and escapes it for XML parsing.
     * 
     * @key Key for the property whose value should be returned.
     * @substituteObject Object to be returned if the property is not found.
     * @returns The property, or the substituteObject if the property is not found.
     */
    getEscapedProperty(key: String, substituteObject: Object): String;

    /**
     * Returns the display name of the impersonating user.
     * 
     * @returns The display name of the impersonating user
     */
    getImpersonatingUserDisplayName(): String;

    /**
     * Returns the name of the impersonating user or null if not impersonating.
     * 
     * @returns Name of impersonating user
     */
    getImpersonatingUserName(): String;

    /**
     * Retrieves the list of info messages for the session that were added by addInfoMessage().
     * 
     * @returns List of info messages
     */
    getInfoMessages(): String;

    /**
     * Returns the user's initials.
     * 
     * @example
     * var userInitials = gs.getUser().getInitials();        
     * gs.addInfoMessage('User initials: ' + userInitials);
     * @returns The user's initials.
     */
    getInitials(): String;

    /**
     * Retrieves translated messages to display in the UI.If the specified string exists in the database for the current language, then the translated message is returned. If the specified string does not exist for the current language, then the English version of the string is returned. If the string does not exist at all in the database, then the ID itself is returned.If the UI message has a tick ('), there may be issues with the message in the script; to escape the ticks ('), use getMessageS(String, Object).
     * 
     * @MessageID The ID of the message.
     * @args (Optional) a list of strings or other values defined by java.text.MessageFormat, which allows you to produce language-neutral messages for display to users.
     * @example
     * var my_message = '${gs.getMessage("This is a message.")}'; 
     * alert(my_message);
     * @example
     * gs.getMessage('"{0}" is not a Client Callable Script Include','BAR’);
     * @returns The UI message
     */
    getMessage(MessageID: String, args: Object): String;

    /**
     * Retrieves translated messages to display in the UI and escapes all ticks (').If the specified string exists in the database for the current language, then the translated message is returned. If the specified string does not exist for the current language, then the English version of the string is returned. If the string does not exist at all in the database, then the ID itself is returned. Useful if you are inserting into a JavaScript expression from Jelly.
     * 
     * @MessageID The ID of the message.
     * @args (Optional) a list of strings or other values defined by java.text.MessageFormat, which allows you to produce language-neutral messages for display to users.
     * @example
     * //
     * "I love France" translates to "J'aime la France" in French.
     * Rendering this without escaping the tick in "J'aime" would break Jelly, because 
     * the tick would prematurely end the variable assignment, and everything that 
     * follows (aime la France') would be a jelly syntax error.
     * 
     * var my_message = '${gs.getMessageS("I love France")}'; 
     * alert(my_message);
     * @returns The message with ticks escaped.
     */
    getMessageS(MessageID: String, args: Object): String;

    /**
     * Returns the list of messages of the specified type for the session that were added by addMessage().
     * 
     * @type The type of message
     */
    getMessages(type: String);

    /**
     * Returns the node name for specified index.
     * 
     * @obj Object to examine
     * @index Index from which to get the node name
     * @returns The node's name
     */
    getNodeName(obj: Object, index: Number): String;

    /**
     * Returns the node value for specified index.
     * 
     * @obj Object to examine
     * @index Index from which to get the node value
     * @returns The node's value
     */
    getNodeValue(obj: Object, index: Number): Object;

    /**
     * Returns a user preference.
     * 
     * @key The key for the preference
     * @default The default value
     * @returns The preference. If no preference, returns the specified default value.
     */
    getPreference(key: String, default: Object): String;

    /**
     * Gets the value of a Glide property. If the property is not found, returns the alternate value.
     * 
     * @key The key for the property whose value should be returned.
     * @alt (Optional) Alternate object to return if the property is not found.
     * @example
     * //Check for attachments and add link if there are any
     *   var attachment_link = '';
     *   var rec = new GlideRecord('sc_req_item');
     *   rec.addQuery('sys_id', current.request_item);
     *   rec.query();
     *   if(rec.next()){
     *     if(rec.hasAttachments()){
     *       attachment_link = gs.getProperty('glide.servlet.uri') + rec.getLink();
     *     }    
     *   }
     * @returns The value of the Glide property, or the alternate object defined above.
     */
    getProperty(key: String, alt: Object): String;

    /**
     * Returns the script error found in the specified script, if there is one.The script is not executed by this function, only checked for syntax errors.
     * 
     * @script The script to check for errors.
     * @returns The error message, or null if there is no error.
     */
    getScriptError(script: String): String;

    /**
     * Returns a GlideSession object.
     * 
     * @returns A GlideSession object for the current session
     */
    getSession(): GlideSessionObject;

    /**
     * Returns the GlideSession Session ID.
     * 
     * @returns The session ID
     */
    getSessionID(): String;

    /**
     * Returns the style defined for the table, field and value.
     * 
     * @tableName The table name
     * @fieldName The field name
     * @fieldValue The field value
     * @returns The style
     */
    getStyle(tableName: String, fieldName: String, fieldValue: String): String;

    /**
     * Returns the list of error messages for the session that were added with the trivial flag.
     * 
     * @returns List of messages
     */
    getTrivialMessages(): String;

    /**
     * Returns a reference to the user object for the current user.
     * 
     * @returns A reference to a user object for the current user
     */
    getUser(): GlideUser;

    /**
     * Returns the name field of the current user (e.g. John Smith, as opposed to smith).
     * 
     * @returns The user's display name
     */
    getUserDisplayName(): String;

    /**
     * Returns the sys_id of the current user.
     * 
     * @example
     * if (current.operation() != 'insert' &amp;&amp; current.comments.changes()) {
     *     gs.eventQueue("incident.commented", current, gs.getUserID(), gs.getUserName());
     * }
     * @returns The sys_id of the current user.
     */
    getUserID(): String;

    /**
     * Returns the username of the current user (e.g., jsmith).
     * 
     * @example
     * //Add a comment when closing
     *     current.comments = "Closed by " + gs.getUserName() + " at " + gs.nowDateTime();
     *     gs.addInfoMessage("Close comment added");
     * }
     * @returns Username of the current user
     */
    getUserName(): String;

    /**
     * Returns the username based on a user ID.
     * 
     * @sys_id A sys_id for a user
     * @returns The username
     */
    getUserNameByUserID(sys_id: String): String;

    /**
     * Constructs an Array of all the nodes and values in an XML document.
     * 
     * @xml The XML document to parse
     * @returns List of names and values
     */
    getXMLNodeList(xml: String): Arraylist;

    /**
     * Returns the XML text for the first node in the XML string that matches the XPath query.
     * 
     * @xml An XML string
     * @xpathQuery The XPath query to match
     * @returns The XML node
     */
    getXMLText(xml: String, xpathQuery: String): String;

    /**
     * Determines if the current user has at least one of the passed-in roles.
     * 
     * @roleName Comma separated list of roles
     * @example
     * if (!gs.hasRole("admin, groups_admin") &amp;&amp; gs.getSession().isInteractive()) {
     *   var qc = current.addQuery("u_hidden", "!=", "true"); //cannot see hidden groups... 
     *   qc.addOrCondition("sys_id", "javascript:getMyGroups()"); //...unless in the hidden group
     * }
     * @returns True if the user has at least one of the passed-in roles; otherwise false. Also returns true if the user has the administrator role.
     */
    hasRole(roleName: String): Boolean;

    /**
     * Determines if the current user has the specified role within a specified group.
     * 
     * @roleName Name of the role
     * @group sys_id of the group to check for the specified role
     * @example
     * var group = new GlideRecord('sys_user_group');
     * group.addQuery('name', 'GROUP_NAME');
     * group.setLimit(1);
     * group.query();
     * if (group.next()) {
     *    if (gs.hasRoleInGroup('role_name', group)) {
     *       gs.print('User has role in group');  
     *    } else {
     *       gs.print('User does NOT have role in group');
     *    }  
     * }
     * @returns Returns true when the following conditions are met, otherwise returns false. The logged-in user is assigned to the specified the role. The granted by field on the user role record is set to the specified group. The inherited field on the user role record is false. 
     */
    hasRoleInGroup(roleName: Object, group: Object): Boolean;

    /**
     * Returns a date and time for a certain number of hours ago.
     * 
     * @hours Number of hours
     * @example
     * if (current.operation() == 'insert') {
     *  // If no due date was specified, calculate a default
     *  if (current.due_date == '') {
     *  
     *   if (current.urgency == '1') {
     *    // Set due date to 4 hours ahead of current time
     *    current.due_date = gs.hoursAgo(-4);
     *   }
     *  
     *   if (current.urgency == '2') {
     *    // Set due date to 2 days ahead of current time
     *    current.due_date = gs.daysAgo(-2);
     *   }
     *  
     *   if (current.urgency == '3') {
     *    // Set due date to 7 days ahead of current time
     *    current.due_date = gs.daysAgo(-7);
     *   }
     *  }
     * }
     * @returns GMT in the format yyyy-mm-dd hh:mm:ss
     */
    hoursAgo(hours: Number): String;

    /**
     * Returns a date and time for the end of the hour a certain number of hours ago.
     * 
     * @hours An integer number of hours
     * @returns GMT in the format yyyy-mm-dd hh:mm:ss
     */
    hoursAgoEnd(hours: Number): String;

    /**
     * Returns a date and time for the start of the hour a certain number of hours ago.
     * 
     * @hours An integer number of hours
     * @returns GMT in the format yyyy-mm-dd hh:mm:ss
     */
    hoursAgoStart(hours: Number): String;

    /**
     * Checks whether the date is the first day of the month.
     * 
     * @date date object
     * @returns True if the date is the first day of the month, false otherwise.
     */
    isFirstDayOfMonth(date: Object): Boolean;

    /**
     * Checks whether the date is the first day of the week. This uses the ISO standard of Monday being the first day of the week.
     * 
     * @date date object
     * @returns True if the date is the first day of the month, false otherwise.
     */
    isFirstDayOfWeek(date: Object): Boolean;

    /**
     * Checks whether the date is the first day of the year.
     * 
     * @date date object
     * @returns True if the date is the first day of the year, false otherwise.
     */
    isFirstDayOfYear(date: Object): Boolean;

    /**
     * Checks if the current session is interactive.An example of an interactive session is when a user logs in using the log-in screen. An example of a non-interactive session is using a SOAP request to retrieve data.
     * 
     * @example
     * if (!gs.hasRole('admin') &amp;&amp; gs.isInteractive()) {
     *     var qc1 = current.addQuery('u_group', '');
     *     var gra = new GlideRecord('sys_user_grmember');
     *     gra.addQuery('user', gs.getUserID());
     *     gra.query();
     *     while (gra.next()) {
     *       qc1.addOrCondition('u_group', gra.group);
     *    }
     * }
     * @returns True if the session is interactive.
     */
    isInteractive(): Boolean;

    /**
     * Checks whether the date is the last day of the month.
     * 
     * @date date object
     * @returns True if the date is the last day of the month, false otherwise. Uses the ISO standard of Sunday being the last day of the week.
     */
    isLastDayofMonth(date: Object): Boolean;

    /**
     * Checks whether the date is the last day of the week.
     * 
     * @date date object
     * @returns True if date is the last day of the week, false otherwise.
     */
    isLastDayOfWeek(date: Object): Boolean;

    /**
     * Checks whether the date is the last day of the year.
     * 
     * @date date object
     * @returns True if date is the last day of the year, false otherwise.
     */
    isLastDayOfYear(date: Object): Boolean;

    /**
     * Determines if the current user is currently logged in.
     * 
     * @returns True if the current user is logged in, false otherwise.
     */
    isLoggedIn(): Boolean;

    /**
     * Determines whether a request comes from a mobile device.This method can be used in UI action conditions and business rules.
     * 
     * @example
     * if (gs.isMobile())
     *   gs.info("submitted from mobile UI");
     *  else 
     *    gs.info("NOT submitted from mobile UI");
     * @returns True if the request comes from a mobile device; otherwise, false.
     */
    isMobile(): Boolean;

    /**
     * Returns the date and time one week ago in GMT.
     * 
     * @returns The date and time one week ago, in the format yyyy-mm-dd hh:mm:ss.
     */
    lastWeek(): String;

    /**
     * Logs a message to the system log and saves it to the syslog table.
     * 
     * @message The message to log.
     * @source (optional) The source of the message.
     * @example
     * var count = new GlideAggregate('incident');
     * count.addQuery('active', 'true');
     * count.addAggregate('COUNT', 'category');
     * count.query();   
     * while (count.next()) {
     *    var category = count.category;
     *    var categoryCount = count.getAggregate('COUNT', 'category');
     *    gs.log("The are currently " + categoryCount + " incidents with a category of " + category, "Incident Counter");
     * }
     */
    log(message: String, source: String);

    /**
     * Logs an error to the system log and saves it to the syslog table.
     * 
     * @message The message to log.
     * @source (optional) The source of the message
     */
    logError(message: String, source: String);

    /**
     * Logs a warning to the system log and saves it to the syslog table.
     * 
     * @message The message to log.
     * @source (optional) The source of the message
     */
    logWarning(message: String, source: String);

    /**
     * Returns a date and time for a certain number of minutes ago
     * 
     * @minutes An integer number of minutes
     * @example
     * /
     * // Check to see if the user has failed to login too many times
     * // when the limit is reached, lock the user out of the system
     * //
     *   //Check failed logins in the last 15 minutes
     *   var gr = new GlideRecord('sysevent');
     *   gr.addQuery('name', 'login.failed');
     *   gr.addQuery('parm1', event.parm1.toString());
     *   gr.addQuery('sys_created_on','&gt;=', gs.minutesAgo(15));
     *   gr.query();
     *   var rowCount = gr.getRowCount();
     *   if(rowCount &gt;= 5){
     *       var gr = new GlideRecord("sys_user");
     *       gr.addQuery("user_name", event.parm1.toString());
     *       gr.query();
     *       if (gr.next()) {
     *            gr.locked_out = true;
     *            gr.update();
     *            gs.log("User " + event.parm1 + " locked out due to too many invalid login attempts");
     *       }
     *   }
     * @returns GMT in the format yyyy-mm-dd hh:mm:ss.
     */
    minutesAgo(minutes: Number): String;

    /**
     * Returns a date and time for the end of the minute a certain number of minutes ago.
     * 
     * @minutes An integer number of minutes
     * @returns GMT in the format yyyy-mm-dd hh:mm:ss
     */
    minutesAgoEnd(minutes: Number): String;

    /**
     * Returns a date and time for the start of the minute a certain number of minutes ago.
     * 
     * @minutes An integer number of minutes
     * @returns GMT in the format yyyy-mm-dd hh:mm:ss.
     */
    minutesAgoStart(minutes: Number): String;

    /**
     * Returns a date and time for a certain number of months ago.
     * 
     * @months An integer number of months
     * @returns GMT on today's date of the specified month, in the format yyyy-mm-dd hh:mm:ss.
     */
    monthsAgo(months: Number): String;

    /**
     * Returns a date and time for the last day of the month a certain number of months ago.
     * 
     * @months An integer number of months
     * @returns GMT end of the month the specified number of months ago, in the format yyyy-mm-dd hh:mm:ss.
     */
    monthsAgoEnd(months: Number): String;

    /**
     * Returns a date and time for the start of the month a certain number of months ago.
     * 
     * @months An integer number of months
     * @returns GMT start of the month the specified number of months ago, in the format yyyy-mm-dd hh:mm:ss
     */
    monthsAgoStart(months: Number): String;

    /**
     * Queries an object and returns true if the object is null or contains an empty string.
     * 
     * @obj The object to be checked.
     * @example
     * if ((!current.u_date1.nil()) &amp;&amp; (!current.u_date2.nil())) {
     *   var start = current.u_date1.getGlideObject().getNumericValue();
     *   var end = current.u_date2.getGlideObject().getNumericValue();
     *   if (start &gt; end) {
     *     gs.addInfoMessage('start must be before end');
     *     current.u_date1.setError('start must be before end');
     *     current.setAbortAction(true);
     *   }
     * }
     * @returns True if null or empty string; otherwise, false.
     */
    nil(obj: Object): Boolean;

    /**
     * Returns the current date in UTC.
     * 
     * @example
     * // When the user password changes then set the u_password_last_reset field
     * // to now so we know when to force another update
     *  
     * var gr = new GlideRecord("sys_user");
     * if (gr.get(event.parm1.toString())) {
     *     // Do something based on the Password Changing
     *     gs.log("The user password changed so do something else...");
     *     gr.u_password_last_reset = gs.now();
     *     gr.update();
     * }
     * @returns The current date in the user-defined format, in UTC.
     */
    now(): String;

    /**
     * Gets the current date and time in the user-defined format.
     * 
     * @example
     * current.u_target_date = gs.nowDateTime();
     * @example
     * current.variables.end_date.setDisplayValue(gs.nowDateTime());
     * @returns The current date and time in the user-defined format.
     */
    nowDateTime(): String;

    /**
     * Gets a GlideDateTime object with the current date and time.After you get a GlideDateTime object with the current date and time, you can use the GlideDateTime methods to perform date-time operations, such as performing date-time calculations, formatting a date-time, or converting between date-time formats.
     * 
     * @example
     * current.u_target_date = gs.nowGlideDateTime();
     * @returns GlideDateTime object with the current date and time in GMT format.
     */
    nowGlideDateTime(): Object;

    /**
     * Returns the current date and time in UTC format.
     * 
     * @example
     * // When the user password changes then set the u_password_last_reset field
     * // to now so we know when to force another update
     *  
     * var gr = new GlideRecord("sys_user");
     * if (gr.get(event.parm1.toString())) {
     *     // Do something based on the Password Changing
     *     gs.log("The user password changed so do something else...");
     *     gr.u_password_last_reset = gs.nowNoTZ();
     *     gr.update();
     * }
     * @returns The current UTC date time
     */
    nowNoTZ(): String;

    /**
     * Writes a message to the system log.This method does not write the message to the syslog table unless debug has been activated.
     * 
     * @message The message to log
     * @example
     * var rec = new GlideRecord('incident');
     * rec.addQuery('active',false);
     * rec.query();
     * while (rec.next()) { 
     *  gs.print('Inactive incident ' + rec.number + ' deleted');
     *  rec.deleteRecord();
     * }
     */
    print(message: String);

    /**
     * Returns a date and time for a certain number of quarters ago.
     * 
     * @quarters An integer number of quarters
     * @returns GMT beginning of the quarter that was the specified number of quarters ago, in the format yyyy-mm-dd hh:mm:ss.
     */
    quartersAgo(quarters: Number): String;

    /**
     * Returns a date and time for the last day of the quarter, for a specified number of quarters ago.
     * 
     * @quarters An integer number of quarters
     * @returns GMT end of the quarter that was the specified number of quarters ago, in the format yyyy-mm-dd hh:mm:ss
     */
    quartersAgoEnd(quarters: Number): String;

    /**
     * Returns a date and time for the first day of the quarter, for a specified number of quarters ago.
     * 
     * @quarters An integer number of quarters
     * @returns GMT end of the month that was the specified number of quarters ago, in the format yyyy-mm-dd hh:mm:ss
     */
    quartersAgoStart(quarters: Number): String;

    /**
     * Sets the specified key to the specified value.
     * 
     * @key The key for the property to be set.
     * @value The value of the property to be set.
     * @description A description of the property.
     * @example
     * gs.setProperty("glide.foo","bar","foo");
     * gs.info(gs.getProperty("glide.foo"));
     */
    setProperty(key: String, value: String, description: String);

    /**
     * Sets the redirect URI for this transaction, which then determines the next page the user will see.
     * 
     * @URI URI to set as the redirect
     * @example
     * gs.setRedirect("com.glideapp.servicecatalog_cat_item_view.do?sysparm_id=d41ce5bac611227a0167f4bf8109bf70&amp;sysparm_user=" 
     * + current.sys_id + "&amp;sysparm_email=" + current.email)
     */
    setRedirect(URI: Object);

    /**
     * Sets the return URI for this transaction. This determines what page the user will be directed to when they return from the next form.
     * 
     * @URI URI to set as the return location.
     * @example
     * gs.setReturn (current.getLink(true));
     */
    setReturn(URI: Object);

    /**
     * Determines if a database table exists.
     * 
     * @tableName Name of the table
     * @returns True if the table exists, false otherwise.
     */
    tableExists(tableName: String): Boolean;

    /**
     * Returns the sys_id of the user associated with this session. Use getUserID() instead.
     * 
     * @returns sys_id of the current user
     */
    userID(): String;

    /**
     * Deletes all existing workflow operations for the specified GlideRecord.
     * 
     * @glideRecord The GlideRecord
     */
    workflowFlush(glideRecord: Object);

    /**
     * Gets a date and time for a certain number of years ago.
     * 
     * @years An integer number of years
     * @returns GMT beginning of the year that is the specified number of years ago, in the format yyyy-mm-dd hh:mm:ss.
     */
    yearsAgo(years: Number): String;

    /**
     * Returns yesterday's time (24 hours ago).
     * 
     * @returns GMT for 24 hours ago, in the format yyyy-mm-dd hh:mm:ss
     */
    yesterday(): String;

}

/**
 * The GlideTimeline class provides the core implementation for configuring and displaying a Glide Windowing Toolkit Timeline. For security, the GlideTimeline has already been instantiated as a single instance variable named glideTimeline. All configurations should be made in the client script section of the corresponding schedule page that references this instance variable.
 * 
 * 
 */
declare class GlideTimeline {



    /**
     * Specifies whether or not to group timeline items by their parent. If true, this will nest all child items inside their parent. This affects the ordering of display and children will always be listed immediately after their parent. The default value for the groupByParent property is false.If true, this will nest all child items inside their parent. This affects the ordering of display and children will always be listed immediately after their parent. The default value for the groupByParent property is false.
     * 
     * @b If true, displays Timeline Items grouped by parent.
     * @example
     * glideTimeline.groupByParent(true);
     */
    groupByParent(b: Boolean);

    /**
     * Registers the specified Timeline server event. The strServerEvent must be one of the allowed events for registration to work correctly. When the event occurs, the GlideTimeline sends a request to the server and processes the event as handled inside the strScriptIncludeName class.The strServerEvent must be one of the allowed events for registration to work correctly. When the event occurs, the GlideTimeline sends a request to the server and processes the event as handled inside the strScriptIncludeName class.
     * 
     * @strServerEvent Specifies one of the following case-sensitive events: getItems elementMoveX elementMoveY elementMoveXY elementSuccessor elementTimeAdjustStart elementTimeAdjustEnd inputBox itemMove 
     * @strScriptIncludeName Specifies the name of the class to receive the strServerEvent. This class must be defined in a script include that extends AbstractTimelineSchedulePage.
     * @example
     * glideTimeline.registerEvent("getItems", "TimelineGanttSchedulePage");
     */
    registerEvent(strServerEvent: String, strScriptIncludeName: String);

    /**
     * Specifies the number of seconds to wait before performing an auto refresh of the data on the timeline. Setting the number of seconds to 0 will turn auto refresh off. By default, auto refresh is disabled. If intSeconds is greater than 0 and less than the minimum allowed time in seconds (10), it will be set to 10 seconds.Setting the number of seconds to 0 will turn auto refresh off. By default, auto refresh is disabled. If intSeconds is greater than 0 and less than the minimum allowed time in seconds (10), it will be set to 10 seconds.
     * 
     * @intSeconds An integer specifying the time in seconds between auto-refreshing.
     * @example
     * glideTimeline.setAutoRefresh(15); // Sets the interval for auto-refreshing to 15 seconds.
     */
    setAutoRefresh(intSeconds: Number);

    /**
     * Specifies the default icon class to use for Timeline Spans with zero duration if no icon class was explicitly specified in the properties of the Timeline Span returned from the server. The default value for the setDefaultPointIconClass property is milestone.The default value for the setDefaultPointIconClass property is milestone.
     * 
     * @icon_class String that specifies one of the following values: milestone blue_square sepia_square green_square red_square black_square blue_circle sepia_circle green_circle red_circle black_circle 
     * @example
     * glideTimeline.setDefaultPointIconClass('blue_circle');
     */
    setDefaultPointIconClass(icon_class: String);

    /**
     * Allows setting of additional parameters in the client script to be made available to the corresponding Script Include events by using the getParameter() method. URI parameters that are prefixed with sysparm_timeline_ will automatically be included in all server side AJAX calls.URI parameters that are prefixed with sysparm_timeline_ will automatically be included in all server side AJAX calls.
     * 
     * @strName The URI parameter name.
     * @strValue The value of strName.
     * @example
     * glideTimeline.setExtraAjaxParam("sysparm_timeline_limit", "5");
     */
    setExtraAjaxParam(strName: String, strValue: String);

    /**
     * Specifies the initial viewable range for the timeline. The default range is the range that specifies the earliest Timeline Span point to the end of the latest Timeline Span. If the initialViewRange property is specified, it will override the default range.The default range is the range that specifies the earliest Timeline Span point to the end of the latest Timeline Span. If the initialViewRange property is specified, it will override the default range.
     * 
     * @objStartDate The start time of the view range in milliseconds.
     * @objEndDate The end time in milliseconds.
     * @example
     * // Sets the initial range to begin on June 20th, 2010 at 8:00 AM and end on June 28th, 2010 at 2:00 PM UTC time.
     *       glideTimeline.setInitialViewRange(1277046000000, 1277647200000);
     */
    setInitialViewRange(objStartDate: Number, objEndDate: Number);

    /**
     * Specifies the initial viewable range for the timeline. The default range is the range that specifies the earliest Timeline Span point to the end of the latest Timeline Span. If the initialViewRange property is specified, it will override the default range.The default range is the range that specifies the earliest Timeline Span point to the end of the latest Timeline Span. If the initialViewRange property is specified, it will override the default range.
     * 
     * @objStartDate The start time of the view range in milliseconds.
     * @objEndDate The end time of the view range in format: yyyy-MM-dd HH:mm:ss .
     * @example
     * // Sets the initial range to begin on June 20th, 2010 at 8:00 AM and end on June 28th, 2010 at 2:00 PM UTC time.
     *       glideTimeline.setInitialViewRange(1277046000000, "2010-06-28 14:00:00");
     */
    setInitialViewRange(objStartDate: Number, objEndDate: String);

    /**
     * Specifies the initial viewable range for the timeline. The default range is the range that specifies the earliest Timeline Span point to the end of the latest Timeline Span. If the initialViewRange property is specified, it will override the default range.The default range is the range that specifies the earliest Timeline Span point to the end of the latest Timeline Span. If the initialViewRange property is specified, it will override the default range.
     * 
     * @objStartDate The start time of the view range in format: yyyy-MM-dd HH:mm:ss .
     * @objEndDate The end time in milliseconds.
     * @example
     * // Sets the initial range to begin on June 20th, 2010 at 8:00 AM and end on June 28th, 2010 at 2:00 PM UTC time.
     *       glideTimeline.setInitialViewRange("2010-06-20 08:00:00", 1277647200000);
     */
    setInitialViewRange(objStartDate: String, objEndDate: Number);

    /**
     * Specifies the initial viewable range for the timeline. The format of the start and end dates must be in the default timestamp format: yyyy-MM-dd HH:mm:ss. The default range is the range that specifies the earliest Timeline Span point to the end of the latest Timeline Span. If the initialViewRange property is specified, it will override the default range.The format of the start and end dates must be in the default timestamp format: yyyy-MM-dd HH:mm:ss. The default range is the range that specifies the earliest Timeline Span point to the end of the latest Timeline Span. If the initialViewRange property is specified, it will override the default range.
     * 
     * @objStartDate The start time of the view range in format: yyyy-MM-dd HH:mm:ss .
     * @objEndDate The end time of the view range in format: yyyy-MM-dd HH:mm:ss .
     * @example
     * // Sets the initial range to begin on June 20th, 2010 at 8:00 AM and end on June 28th, 2010 at 2:00 PM UTC time.
     *       glideTimeline.setInitialViewRange("2010-06-20 08:00:00", "2010-06-28 14:00:00");
     *     
     */
    setInitialViewRange(objStartDate: String, objEndDate: String);

    /**
     * Enables or disables all timeline event interaction. If enabled, event interaction is determined from the corresponding attributes specified by each Timeline Item. The default value for the readOnly property is false.If enabled, event interaction is determined from the corresponding attributes specified by each Timeline Item. The default value for the readOnly property is false.
     * 
     * @b If true, marks the entire timeline as read-only (non-interactive).
     * @example
     * glideTimeline.setReadOnly(true);
     */
    setReadOnly(b: Boolean);

    /**
     * Specifies whether or not to show dependency lines between Timeline Spans. This method applies only if the set of Timeline Items returned from the server includes dependency relationships. The default value for the showDependencyLines property is false.This method applies only if the set of Timeline Items returned from the server includes dependency relationships. The default value for the showDependencyLines property is false.
     * 
     * @b If true, displays dependency lines on the timeline; otherwise, does not.
     * @example
     * glideTimeline.showDependencyLines(true);
     */
    showDependencyLines(b: Boolean);

    /**
     * Specifies whether or not to show grid lines for each row of data on the timeline. By default, grid lines are enabled.By default, grid lines are enabled.
     * 
     * @bShowGridlines If true, timeline shows grid lines; otherwise, does not display grid lines.
     * @amount amount
     * @example
     * glideTimeline.showGridLines(false); // Disables grid lines.
     */
    showGridLines(bShowGridlines: Boolean, amount: Number);

    /**
     * Specifies whether or not to show the left hand pane in the timeline. The default value for the leftPane property is true.The default value for the leftPane property is true.
     * 
     * @b If true, the timeline shows the left pane; otherwise, the left pane is not be displayed.
     * @example
     * glideTimeline.showLeftPane(false);
     */
    showLeftPane(b: Boolean);

    /**
     * Specifies how to show child items in the left pane of the timeline. Child items are displayed either as nested, indented nodes with expand and collapse capability or on a single indent level. The default value for the showLeftPaneAsTree property is false.The default value for the showLeftPaneAsTree property is false.
     * 
     * @b If true, child item nodes are shown as indented with expand/collapse capability; otherwise, all left pane items are displayed at a single indent level.
     * @example
     * glideTimeline.showLeftPaneAsTree(true);
     */
    showLeftPaneAsTree(b: Boolean);

    /**
     * Specifies whether or not to show the text input box at the bottom of the left pane with a default value as specified by strDefaultValue. If the left pane is diabled via showLeftPane(), the input box will not be visible. The default value for the showLeftPaneInputBox property is false.If the left pane is diabled via showLeftPane(), the input box will not be visible. The default value for the showLeftPaneInputBox property is false.
     * 
     * @b If true, show the left pane input box.
     * @strDefaultValue The default value to display in the input box.
     * @example
     * glideTimeline.showLeftPaneInputBox(true, 'Add a new task ...');
     *     
     */
    showLeftPaneInputBox(b: Boolean, strDefaultValue: String);

    /**
     * Specifies whether or not to show the summary pane at the bottom of the timeline. The default value for the showSummaryPane property is true.The default value for the showSummaryPane property is true.
     * 
     * @b If true, the timeline includes the summary pane; otherwise, the summary pane is not displayed.
     * @example
     * glideTimeline.showSummaryPane(false);
     */
    showSummaryPane(b: Boolean);

    /**
     * Specifies whether or not to show the timeline text underneath each Timeline Span in the primary timeline pane. The default value for the showTimelineText property is false.The default value for the showTimelineText property is false.
     * 
     * @b If true, displays descriptive text underneath each Timeline Span; otherwise, no text is displayed underneath each Timeline Span.
     * @example
     * glideTimeline.showTimelineText(true);
     */
    showTimelineText(b: Boolean);

    /**
     * Specifies whether or not the vertical movement of timeline span objects (if appropriately registered to perform this event) should snap adjust into the closest row. By default this value is enabled.By default this value is enabled.
     * 
     * @b If true, snaps vertical movement of timeline span objects into rows; otherwise, items move exactly with respect to the mouse.
     * @example
     * glideTimeline.snapVertScrollingIntoRows(false);
     */
    snapVertScrollingIntoRows(b: Boolean);

    /**
     * Specifies whether or not to group items by their left label text. The default value for the sortByLeftLabelText property is false.The default value for the sortByLeftLabelText property is false.
     * 
     * @b If true, sort Timeline Items alphabetically by the text specified in each item's left label.
     * @example
     * glideTimeline.sortByLeftLabelText(true);
     */
    sortByLeftLabelText(b: Boolean);

    /**
     * Specifies whether or not to sort the list of Timeline Items returned by the earliest start date of an item's Timeline Span objects. If groupByParent() is set true, items are sorted after grouping has occurred. The default value for the sortByStartDate property is false.If groupByParent() is set true, items are sorted after grouping has occurred. The default value for the sortByStartDate property is false.
     * 
     * @b If true, sort Timeline Items chronologically starting with their earliest start date.
     * @example
     * glideTimeline.sortByStartDate(true);
     */
    sortByStartDate(b: Boolean);

    /**
     * Specifies whether or not to sort the list of Timeline Items returned in alphabetical order according to the text that was specified to show in the Timeline Pane.The default value for the sortByTimelineLabelText property is false.
     * 
     * @b If true, sorts Timeline Items alphabetically by the text specified in each item's timeline span text.
     * @example
     * glideTimeline.sortByTimelineLabelText(true);
     */
    sortByTimelineLabelText(b: Boolean);

}

/**
 * GlideTimelineItem extends the abstract ScheduleItem class to define additional properties that are specific to the time line. A time line item is essentially any item that is displayed in a singular row across the time line. A GlideTimelineItem has zero or more associated spans (TimelineSpan objects).
 * 
 * 
 */
declare class GlideTimelineItem {



    /**
     * Constructor that sets the required table and sys_id properties.The rest of this object's properties should be set by the caller. By default, this object instance is "droppable" since a table name is specified.
     * 
     * @tableName The name of the table associated with current object.
     * @sys_id The sys ID for the object.
     */
    constructor(tableName: String, sys_id: String);

    /**
     * Create a "dummy" GlideTimelineItem object.This is useful for creating rows that do not allow any YMoving into; however, contain nested children (e.g. The top-level "Users" row in the Group Resource Timeline). The sys_id needs to be unique for DOM level functions to parse correctly. By default this object will not be "droppable" because a table name was not specified.
     * 
     * @tableName The name of the table associated with current object.
     */
    constructor(tableName: String);

    /**
     * Creates a new TimelineSpan object associated with the current instance object.If no other TimelineSpan objects exist, the newly created object will share the same sys_id as current instance object. Otherwise, a randomly generated GUID will be used.
     * 
     * @tableName The name of the table associated with current object.
     * @returns The newly-created span object instance.
     */
    createTimelineSpan(tableName: String): Object;

    /**
     * Creates a new TimelineSpan object associated with the current instance object using the specified table and sysId.
     * 
     * @tableName The name of the table associated with current object
     * @sys_id The sys ID for the object.
     * @returns The newly-created span object instance.
     */
    createTimelineSpan(tableName: String, sys_id: String): Object;

    /**
     * Returns a string specifying the name of the image file associated with the current GlideTimelineItem.
     * 
     * @returns The name of the image file associated with the current GlideTimelineItem. If no image is associated with the current item, an empty string ("") is returned.
     */
    getImage(): String;

    /**
     * Indicates whether or not the current instance object should be allowed as a "drop zone" when moving timeline elements vertically.
     * 
     * @returns True if droppable; false otherwise.
     */
    getIsDroppable(): Boolean;

    /**
     * Returns the text to be displayed in the left pane (if enabled).
     * 
     * @returns The value of the text to be displayed in the left pane.
     */
    getLeftLabelText(): String;

    /**
     * Returns the unique sysId of the current GlideTimelineItem's parent object.
     * 
     * @returns The unique sysId of the current GlideTimelineItem's parent object. If the parent does not exist, this will return an empty string ("").
     */
    getParent(): String;

    /**
     * Returns all the TimelineSpan objects associated with the current instance in an ArrayList.
     * 
     * @returns The list of TimelineSpan objects associated with the current instance.
     */
    getTimelineSpans(): ObjectArray;

    /**
     * Indicates if the left pane text is set to be displayed using a bold style.
     * 
     * @returns True if the text should be bolded; otherwise false.
     */
    isTextBold(): Boolean;

    /**
     * Sets the name of the image file (including it's path) to use as the icon for the item in the left pane.
     * 
     * @strImageName The name of the image, including its path.
     */
    setImage(strImageName: String);

    /**
     * Sets whether or not the current instance object can be clicked and dragged into another GlideTimelineItem.
     * 
     * @b True if item should be able to be moved with click and drag. Otherwise, false.
     */
    setIsDraggable(b: Boolean);

    /**
     * Specifies the text to display in the left pane for this item.
     * 
     * @strText The text to display in the left pane for this item.
     */
    setLeftLabelText(strText: String);

    /**
     * Sets the parent of the current GlideTimelineItem.
     * 
     * @sysId The sysID of the GlideTimelineItem that should become the parent of the current GlideTimelineItem.
     */
    setParent(sysId: String);

    /**
     * Specifies whether or not to bold the text style of the item in the left pane.
     * 
     * @b True if text in left pane should be bolded; otherwise false.
     */
    setTextBold(b: Boolean);

}

/**
 * The GlideUser API provides access to information about the current user and current user roles. Using the GlideUser API avoids the need to use the slower GlideRecord queries to obtain user information.
 * 
 * 
 */
declare class GlideUser {



    /**
     * Returns the current user's company sys_id.
     * 
     * @example
     * var currentUser = gs.getUser(); 
     * gs.info(currentUser.getCompanyID());
     * @returns Company sys_id
     */
    getCompanyID(): String;

    /**
     * Returns the current user's display name.
     * 
     * @example
     * var currentUser = gs.getUser(); 
     * gs.info(currentUser.getDisplayName());
     * @returns User's display name
     */
    getDisplayName(): String;

    /**
     * Returns the display value of the user's session domain.
     * 
     * @example
     * var currentUser = gs.getUser(); 
     * gs.info(currentUser.getDomainDisplayValue());
     * @returns The display value of the user's session domain.
     */
    getDomainDisplayValue(): String;

    /**
     * Returns the user's email address.
     * 
     * @example
     * var currentUser = gs.getUser(); 
     * gs.info(currentUser.getEmail());
     * @returns User's email address
     */
    getEmail(): String;

    /**
     * Returns the user's first name.
     * 
     * @example
     * var currentUser = gs.getUser(); 
     * gs.info(currentUser.getFirstName());
     * @returns User's first name
     */
    getFirstName(): String;

    /**
     * Returns the sys_id of the current user.
     * 
     * @example
     * var currentUser = gs.getUser(); 
     * gs.info(currentUser.getID());
     * @returns User's sys_id
     */
    getID(): String;

    /**
     * Returns the user's last name.
     * 
     * @example
     * var currentUser = gs.getUser(); 
     * gs.info(currentUser.getLastName());
     * @returns User's last name
     */
    getLastName(): String;

    /**
     * Returns an iterator containing the list of all groups to which the user belongs. Only active groups are returned.
     * 
     * @example
     * var groupsArray = gs.getUser().getMyGroups().toArray();
     * gs.info(groupsArray[0]);
     * @returns A list of sys_ids for the active groups to which the user belongs.
     */
    getMyGroups(): iterator;

    /**
     * Returns the user ID, or login name, of the current user.
     * 
     * @example
     * var currentUser = gs.getUser(); 
     * gs.info(currentUser.getName());
     * @returns User ID
     */
    getName(): String;

    /**
     * Returns a list of roles that includes explicitly granted roles, inherited roles, and roles acquired by group membership.
     * 
     * @example
     * var currentUser = gs.getUser(); 
     * gs.info(currentUser.getRoles());
     * @returns List of all roles available to the user
     */
    getRoles(): Array<any>;

    /**
     * Returns the user object associated with the passed-in user ID (sys_id in sys_user) or user_name.
     * 
     * @id Unique ID (sys_id) or user_name of the desired user record.
     * @example
     * var currentUser = gs.getUser();
     * gs.info(currentUser.getFirstName()); // print the first name of the logged in user
     * var newUser = currentUser.getUserByID('abel.tuter'); // fetch a different user using the user_name field
     * gs.info(newUser.getFirstName()); // print the first name of the Abel Tuter user 
     * 
     * @example
     * var currentUser = gs.getUser();
     * gs.info(currentUser.getFirstName()); // print the first name of the logged in user
     * var newUser = currentUser.getUserByID('62826bf03710200044e0bfc8bcbe5df1'); // fetch Abel Tuter user using sys_id from sys_user record
     * gs.info(newUser.getFirstName()); // print the first name of the Abel Tuter user 
     * 
     * @returns User object associated with the specified sys_id or user_name.
     */
    getUserByID (id: String): Object;

    /**
     * Returns the list of roles explicitly granted to the user.
     * 
     * @example
     * var currentUser = gs.getUser(); 
     * gs.info(currentUser.getUserRoles());
     * @returns List of roles explicitly assigned to the user
     */
    getUserRoles(): Array<any>;

    /**
     * Determines if the current user has the specified role.
     * 
     * @role Role to check
     * @example
     * var currentUser = gs.getUser(); 
     * gs.info(currentUser.hasRole('admin'));
     * @returns True if the user has the role.
     */
    hasRole(role: String): Boolean;

    /**
     * Determines if the current user is a member of the specified group.
     * 
     * @group Group to check
     * @example
     * var currentUser = gs.getUser(); 
     * gs.info(currentUser.isMemberOf(­'Capacity Mgmt'));
     * @returns True if the user is a member of the group.
     */
    isMemberOf(group: String): Boolean;

}

/**
 * Formats host names according to property settings. Use with any server-side script when you need to format host names.
 * 
 * 
 */
declare class HostnameJS {



    /**
     * Formats the specified host name according to the property settings.
     * 
     * @hostname The host name to format
     * @source The property settings source
     * @returns The system name
     */
    format(hostname: String, source: String): String;

    /**
     * Returns the DNS domain name.
     * 
     * @example
     * var hjs = new HostnameJS();
     * hjs.getDomainName();
     * @returns The domain name
     */
    getDomainName(): String;

    /**
     * Returns the current system name.
     * 
     * @example
     * var hjs = new HostnameJS();
     * hjs.getSysName();
     * @returns The system name
     */
    getSysName(): String;

}

/**
 * The ICalUtil API is an extension of the ICalUtilSNC API. 
 * 
 * 
 */
declare class ICalUtil {



}

/**
 * The ICalUtilSNC API provides functions to generate iCalendar compliant events. 
 * 
 * 
 */
declare class ICalUtilSNC {



    /**
     * Generates a formatted VCALENDAR component.
     * 
     * @arrEvents Contains the properties that make up a VCALENDAR component.
     * @returns Contains properties needed to form a VCALENDAR.
     */
    formatICalComponent(arrEvents: Array<any>): Array<any>;

    /**
     * Generates a formatted VEVENT.
     * 
     * @arrEvent Contains the individual properties that make up a VEVENT.
     * @useAlarm If true, adds a VALARM to the VEVENT.
     * @returns The formatted VEVENT.
     */
    formatICalEvent(arrEvent: Array<any>, useAlarm: Boolean): String;

    /**
     * Formats the RRULE property for a VEVENT.
     * 
     * @ruleObj Contains the properties for the RRULE property.
     * @returns The formatted RRULE property.
     */
    formatRecurringRule (ruleObj: Object): String;

    /**
     * Returns the date from the GlideScheduleDateTime.
     * 
     * @scheduleDateTime A GlideScheduleDateTime representation of the date and time.
     * @returns Formatted date.
     */
    getDateFromScheduleDateTime (scheduleDateTime: GlideScheduleDateTime): String;

    /**
     * If provided with a formatted date time string, it returns a GlideScheduleDateTime object.
     * 
     * @sdtStr Formatted ScheduleDateTime.
     * @timeZone If provided, will be used for the generated GlideScheduleDateTime.
     * @returns A GlideScheduleDateTime representation of the sdtStr.
     */
    getSDT(sdtStr: String, timeZone: String): GlideScheduleDateTime;

    /**
     * Returns the time from the GlideScheduleDateTime.
     * 
     * @scheduleDateTime A GlideScheduleDateTime representation of the date and time.
     * @returns Formatted time.
     */
    getTimeFromScheduleDateTime (scheduleDateTime: GlideScheduleDateTime): String;

}

/**
 * The IdentificationEngineScriptableApi uses the Identification and Reconciliation framework to minimize creation of duplicate CIs and to reconcile CI attributes by only accepting information from authorized data sources when updating the CMDB. 
 * 
 * 
 */
declare class IdentificationEngineScriptableApi {



    /**
     * Insert or update configuration items in the CMDB based on identification and reconciliation rules. Use this API instead of updating the CMDB directly.
     * 
     * @source Identifies the data source of the CI information. These must be one of the choice values defined for the discovery_source field of the cmdb_ci table.
     * @input A JSON formatted string of configuration items to be added or updated. Each input string is in the format 'items: [{}], relations:[{}], related[{}]', where each item within the items, relations, and related lists contains name-value pairs. The possible name-value pairs within the items list are: className - the sys_class_name of the CI to be created or updated. values:{} - the field information for the CI as name-value pairs, where the name is the field name. When updating reference fields, the value must be the referenced sys_id. lookup:[{}] - a list of records with each item having name-value pairs like the items list. related: [{}] - a list of records with each item having name-value pairs like the items list. The possible name-value pairs within the relations list are: parent - index of the parent item in the dependency relation child - index of the child item in the dependency relation type - the relationship type. This is one of the name field values from the cmdb_rel_type table. 
     * @example
     * var payload = {items: [{className:'cmdb_ci_linux_server', 
     *                values: {name:'stry0900844 CI 2',
     *                         serial_number:'9876EFGH',
     *                         mac_address:'4653XYZ',
     *                         ip_address:'10.10.10.4',
     *                         ram:'1238'}}]
     *               };
     * 
     * var jsonUntil = new JSON();
     * var input = jsonUntil.encode(payload);
     * var output = SNC.IdentificationEngineScriptableApi.createOrUpdateCI('ServiceNow', input);
     * gs.print(output);
     * 
     * @example
     * var payload = 
     *               {items: [ 
     *                     {className:'cmdb_ci_web_server', 
     *                      values: {name:'apache linux den 200', 
     *                               running_process_command: 'xyz',  
     *                               running_process_key_parameters: 'abc', 
     *                               tcp_port:'3452'}}, 
     *                     {className:'cmdb_ci_linux_server', 
     *                      values: {name:'lnux100', ram:'2048'}}],
     *                relations:[{parent: 0, child: 1, type: 'Runs on::Runs'}]
     *               };
     * 
     * var jsonUntil = new JSON();
     * var input = jsonUntil.encode(payload);
     * var output = SNC.IdentificationEngineScriptableApi.createOrUpdateCI('ServiceWatch', input);
     * gs.print(output);
     * 
     * @example
     * var payload = {items: [
     *            {className:'cmdb_ci_netgear', 
     *                values: {name:'ny8500-nbxs08',
     *                         ports:'1200'}, 
     *                lookup: [{className:'cmdb_serial_number',
     *                             values:{serial_number:'1234ABCD', serial_number_type:'uuid',absent:'false',valid:'true'}},
     *                         {className:'cmdb_serial_number',
     *                             values:{serial_number:'3456EFGH', serial_number_type:'system',absent:'false',valid:'true'}}]}]};
     * 
     * var jsonUntil = new JSON();
     * var input = jsonUntil.encode(payload);
     * var output = SNC.IdentificationEngineScriptableApi.createOrUpdateCI('ServiceNow', input);
     * gs.print(output);
     * 
     * @returns A JSON formatted string that is a list of results for the configuration items in the input string. Each result string is in the format 'items: [{}], relations:[{}]', where each item within the items and relations lists contains name-value pairs. The possible name-value pairs within the items list are: className- the sys_class_name for the CI that was updated or created. operation, which is one of INSERT, UPDATE, UPDATE_WITH_UPGRADE, UPDATE_WITH_DOWNGRADE, UPDATE_WITH_SWITCH, DELETE, NO_CHANGE sysId - the sys_id of the CI that was updated or created. relatedSysIds - a list of sys_id values of CIs used during lookup based identification. maskedAttributes – a list of attributes whose update by a non-authoritative data source gets skipped as defined by the Reconciliation Rules. identifierEntrySysId - sys_id of identifier entry used during matching. errors - a list of errors in the format of (error, message string), where error can be ABANDONED, INVALID_INPUT_DATA, IDENTIFICATION_RULE_MISSING, IDENTIFICATION_RULE_FOR_LOOKUP_MISSING, NO_LOOKUP_RULES_FOR_DEPENDENT_CI, NO_CLASS_NAME_FOR_INDEPENDENT_CI, MISSING_DEPENDENCY, MULTIPLE_DEPENDENCIES, MULTIPLE_DUPLICATE_RECORDS, RELATION_CHAIN_ENDS_AT_QUALIFIER, QUALIFICATION_LOOP, TYPE_CONFLICT_IN_QUALIFICATION, MULTI_MATCH, REQUIRED_ATTRIBUTE_EMPTY, RECLASSIFICATION_NOT_ALLOWED duplicateIndices - a list of indexes of items that are duplicates of the current item. identificationAttempts - a list of attempts in the format of (attributes, identiferName, attemptResult, searchOnTable) where attributes - the attributes of identifier entry used during identification identiferName - the CI identifier to which this identifier entry belongs attemptResult - one of SKIPPED, NO_MATCH, MATCHED, MULTI_MATCH searchOnTable - the table searched during the identification process. The possible name-value pairs within the relations list are: className - the relationship CI's class name and is always cmdb_rel_ci operation - one of INSERT, UPDATE, NO_CHANGE sysId - the sys_id of the relationship CI inserted or updated 
     */
    createOrUpdateCI(source: String, input: String): String;

    /**
     * Determines the operation (insert/update) that will be performed with the specified payload without committing the operation in the database.This works just like createOrUpdateCI(), but does not commit the result.
     * 
     * @jsonString A JSON formatted string of configuration items to be added or updated. Each input string is in the format 'items: [{}], relations:[{}]', where each item within the items and relations lists contains name-value pairs. The possible name-value pairs within the items list are: className - the sys_class_name of the CI to be created or updated. values:{} - the field information for the CI as name-value pairs, where the name is the field name. lookup:[{}] - a list of records with each item having name-value pairs like the items list. The possible name-value pairs within the relations list are: parent - index of the parent item in the dependency relation child - index of the child item in the dependency relation type - the relationship type. This is one of the name field values from the cmdb_rel_type table. 
     * @returns A JSON formatted string that is a list of results. Each result string is in the format 'items: [{}], relations:[{}]', where each item within the items and relations lists contains name-value pairs. The possible name-value pairs within the items list are: className- the sys_class_name for the CI that was updated or created. operation, which is one of INSERT, UPDATE, UPDATE_WITH_UPGRADE, UPDATE_WITH_DOWNGRADE, UPDATE_WITH_SWITCH, DELETE, NO_CHANGE sysId - the sys_id of the CI that was updated or created. relatedSysIds - a list of sys_id values of CIs used during lookup based identification. identifierEntrySysId - sys_id of identifier entry used during matching. errors - a list of errors in the format of (error, message string), where error can be ABANDONED, INVALID_INPUT_DATA, IDENTIFICATION_RULE_MISSING, IDENTIFICATION_RULE_FOR_LOOKUP_MISSING, NO_LOOKUP_RULES_FOR_DEPENDENT_CI, NO_CLASS_NAME_FOR_INDEPENDENT_CI, MISSING_DEPENDENCY, MULTIPLE_DEPENDENCIES, MULTIPLE_DUPLICATE_RECORDS, RELATION_CHAIN_ENDS_AT_QUALIFIER, QUALIFICATION_LOOP, TYPE_CONFLICT_IN_QUALIFICATION, MULTI_MATCH, REQUIRED_ATTRIBUTE_EMPTY, RECLASSIFICATION_NOT_ALLOWED duplicateIndices - a list of indexes of items that are duplicates of the current item. identificationAttempts - a list of attempts in the format of (attributes, identiferName, attemptResult, searchOnTable) where attributes - the attributes of identifier entry used during identification identiferName - the CI identifier to which this identifier entry belongs attemptResult - one of SKIPPED, NO_MATCH, MATCHED, MULTI_MATCH searchOnTable - the table searched during the identification process. The possible name-value pairs within the relations list are: className - the relationship CI's class name and is always cmdb_rel_ci operation - one of INSERT, UPDATE, NO_CHANGE sysId - the sys_id of the relationship CI inserted or updated 
     */
    identifyCI(jsonString: String): String;

    /**
     * Run an identification audit against the specified CI to detect duplicates.If duplicates are found, duplication tasks are created. Only use this method on CI types with independent identification rules.
     * 
     * @gr The CI on which to run the audit to detect duplicates. The CI must have independent identification rules.
     */
    runIdentificationAudit(gr: GlideRecord);

}

/**
 * A container class for the result of a CI Identifier. Use with any server-side discovery script.
 * 
 * 
 */
declare class IDResult {



    /**
     * Creates an instance of the IDResult class.
     * 
     * @explore Set to true if the CI should be explored; otherwise, false.
     * @sysID An existing CI's sys_id, or null if no existing CI could be found.
     */
    constructor(explore: Boolean, sysID: String);

}

/**
 * After a device has been successfully discovered, ensures that no other device has the same IP address. If any duplicates are found, the IP address field is cleared. Use with any server-side Discovery script to validate IP addresses.
 * 
 * 
 */
declare class IPAddressFixup {



    /**
     * Removes duplicates of the specified IP address in the specified table.
     * 
     * @tableName The table to check for duplicates
     * @ip The IP address to check for
     */
    dedupe(tableName: String, ip: String);

    /**
     * Removes all duplicate IP addresses from the tables.
     * 
     */
    dedupeAll();

    /**
     * Removes all duplicate IP addresses and ensures that the parent ip_address record is set to one of the NIC's IP addresses.
     * 
     */
    fix();

    /**
     * Returns the parent IP address for the current device.
     * 
     * @returns The parent IP address
     */
    getParentIP(): String;

    /**
     * Sets the IP address field for the current CI.
     * 
     * @ip The IP address for the current CI.
     */
    setParentIP(ip: String);

    /**
     * Ensures that the parent ip_address record is set to one of the NIC's IP addresses, or leaves it alone if there were no NICs.
     * 
     */
    syncIP();

}

/**
 * Encapsulates an IP Service. Use this class during the discovery scanning phase.
 * 
 * 
 */
declare class IPService {

    /** The table where this service creates entries. */
    creates: String
    /** Description of the IPService. */
    description: String
    /** A short name or handle for the IPService. */
    name: String
    /** The TCP or UDP port used by the service. */
    port: String
    /** The protocol used by the service ("UDP", "TCP", or "TCP/UDP"). */
    protocol: String
    /** A long, descriptive English name for the IPService. */
    serviceName: String
    /** The sys_id of this record. */
    sysID: String


    /**
     * Creates an instance of the IPService class.
     * 
     * @source Either a GlideRecord instance or a sys_id string
     */
    constructor(source: Object);

    /**
     * Returns an array of IPService instances specified by a Java ArrayList of sys_ids.
     * 
     * @list List of sys_ids.
     * @returns IPService instances
     */
    getFromArrayList(list: Array<any>): Array<any>;

}

/**
 * 2JS script include allows you to convert java objects to JavaScript objects. If the given value is a Java object that can be converted to an equivalent JavaScript object, that conversion is performed and the result is returned. Otherwise the original Java object is returned. * * The j2js class is available to server-side scripts. * * The specific conversion performed in the order they are checked. Java String -&gt; JavaScript string Java Boolean -&gt; JavaScript boolean Java Integer -&gt; JavaScript number Java Long -&gt; JavaScript number Java Double -&gt; JavaScript number Java Byte -&gt; JavaScript number Java Float -&gt; JavaScript number Java Short -&gt; JavaScript number Java Character -&gt; JavaScript number Java array -&gt; JavaScript Array with order preserved Java List -&gt; JavaScript Array with order preserved Java Map -&gt; JavaScript Object with the key/value pairs translated into property/value pairs Java Set -&gt; JavaScript Array in arbitrary order * * Conversions are performed recursively on the elements of arrays, lists, or collections. For example, given a Java ArrayList of ArrayLists of Strings, this will return a JavaScript Array of Arrays of strings.
 * 
 * 
 */
declare class J2js {



    /**
     * Converts a java object from system code to a JavaScript object.
     * 
     * @javaObject A Java object from system code such as a Packages call.
     * @example
     * var tu = new TableUtils("cmdb_ci_win_server");
     * var classes = tu.getHierarchy();
     * //getHierarchy returns a Java ArrayList, which is not exactly like a JavaScript Array
     * //for example you cannot get length
     * gs.print("classes = " + classes);
     * gs.print("classes.length = " + classes.length);
     *  
     * //convert to a JavaScript Array
     * gs.include("j2js");
     * var jsClasses = j2js(classes);
     * gs.print("jsClasses = " + jsClasses);
     * gs.print("jsClasses.length = " + jsClasses.length);
     * @returns A JavaScript object if the parameter can be converted, otherwise it returns the Java object.
     */
    j2js(javaObject: Object): Object;

}

/**
 * Provides methods for using the JavascriptProbe on the MID server. Use these methods in server scripts to send a probe to the MID server from JavaScript.
 * 
 * 
 */
declare class JavascriptProbe {



    /**
     * Creates an instance of the JavascriptProbe.
     * 
     * @midServer The MID server name
     */
    constructor(midServer: String);

    /**
     * Adds a parameter with the specified value to the probe.
     * 
     * @name The parameter name
     * @value The parameter's value
     * @example
     * var jspr = new JavascriptProbe('msserv');
     * jspr.setName('jsprobe100');
     * jspr.setSource('jspr_source');
     * jspr.addParameter('support_feat', 'yes');
     */
    addParameter(name: String, value: String);

    /**
     * Creates the probe for the current MID server, puts it on the output queue, and sets its state to "ready".
     * 
     * @example
     * var jspr = new JavascriptProbe('msserv');
     * jspr.setName('jsprobe100');
     * jspr.setSource('jspr_source');
     * jspr.setJavascript('jspr_script');
     * jspr.create();
     */
    create();

    /**
     * Adds a script to the probe.
     * 
     * @script The script to add to the probe
     * @example
     * var jspr = new JavascriptProbe('msserv');
     * jspr.setName('jsprobe100');
     * jspr.setSource('jspr_source');
     * jspr.setJavascript('jspr_script');
     */
    setJavascript(script: String);

    /**
     * Sets the name of the JavascriptProbe
     * 
     * @name The name to give the JavascriptProbe.
     * @example
     * var jspr = new JavascriptProbe('msserv');
     * jspr.setName('jsprobe100');
     */
    setName(name: String);

    /**
     * Sets the source of the probe.
     * 
     * @ip The IP address of the target probe.
     * @example
     * var jspr = new JavascriptProbe('msserv');
     * jspr.setName('jsprobe100');
     * jspr.setSource('100.100.100.1');
     */
    setSource(ip: String);

}

/**
 * Provides methods to create JSON objects from a string, and to turn JSON objects into strings. The JSON API has dynamic and static methods. You access the dynamic methods by creating a JSON object. To use the dynamic methods in a scoped application, add the global prefix when calling the constructor. You access the static methods by using the static JSON object. * * The JavaScript ES5 native JSON object is used instead of the JSON static methods. If your script needs the old behavior, use the encode() and decode() methods. * * This example creates a JSON object. * * The encode() and decode() methods are deprecated. Use the JavaScript JSON object instead. * * This example creates a JSON object in a scoped script. * * This example uses the static methods.
 * 
 * 
 */
declare class JSON {



    /**
     * Creates an instance of the JSON class.This class is deprecated. Use the JavaScript JSON object instead.
     * 
     */
    constructor();

    /**
     * Creates an object or primitive type from a JSON formatted string.Note: This class is deprecated. Use the JavaScript JSON object instead.
     * 
     * @str A JSON formatted string.
     * @example
     * var str = ‘{“name":"George","lastname":"Washington”}’;
     * var parser = new JSON();
     * var obj = parser.decode(str);
     * gs.info(‘The first name is ’  + obj.name);
     * @example
     * var str = ‘{“name":"George","lastname":"Washington”}’;
     * var parser = new global.JSON();
     * var obj = parser.decode(str);
     * gs.info(‘The first name is ’  + obj.name);
     * @returns An object created from the specified string.
     */
    decode(str: String): Object;

    /**
     * Creates a string from a JSON object.Note: This class is deprecated. Use the JavaScript JSON object instead.
     * 
     * @jsonObject The JSON object to be turned into a string.
     * @example
     * var obj = {“name":"George","lastname":"Washington"};
     * var parser = new JSON();
     * var str = parser.encode(obj);
     * gs.info(‘The object ’  + str);
     * @example
     * var obj = {“name":"George","lastname":"Washington"};
     * var parser = new global.JSON();
     * var str = parser.encode(obj);
     * gs.info(‘The object ’  + str);
     * @returns A JSON formatted string.
     */
    encode(jsonObject: Object): String;

    /**
     * Creates an object or primitive type from a JSON formatted string.The JavaScript ES5 native JSON object is used instead of the JSON static methods. If your script needs the old behavior, use the encode() and decode() methods.
     * 
     * @str A JSON formatted string.
     * @example
     * var str = ‘{“name":"George","lastname":"Washington”}’;
     * var obj = JSON.parse(str);
     * gs.info(‘The first name is ’  + obj.name);
     * @returns An object created from the specified string.
     */
    parse(str: String): Object;

    /**
     * Creates a string from a JSON object.The JSON.stringify() method can only convert numbers, strings, and Java native objects to strings. It cannot convert user-defined objects to strings, unless those objects provide a toJSON() method. The call to current.sys_id() returns a GlideElement object which does not have a toJSON() method, so the return value for stringify is empty: "{}". The JavaScript ES5 native JSON object is used instead of the JSON static methods. If your script needs the old behavior, use the encode() and decode() methods.
     * 
     * @jsonObject JSON object to turn into a string.
     * @example
     * var obj = {“name":"George","lastname":"Washington"};
     * var str =  JSON.stringify(obj);
     * gs.info(‘The object ’  + str);
     * 
     * @example
     * function replacer(name, val) {
     *    // convert GlideElement to string
     *    if ( val &amp;&amp; val.constructor === GlideElement ) {
     *        return val.toString();
     *    } else {
     *        return val; // return as is
     *    }
     * };
     * 
     * var s = global.JSON.stringify(json_obj, replacer);
     * gs.info("json="+s);
     * 
     * @returns JSON formatted string.
     */
    stringify(jsonObject: Object): String;

}

/**
 * Provides a JSON parser that does not use the JavaScript eval() function. The methods of JSONParser do not validate the JSON string. * * This class cannot be used in a scoped application. Use the JavaScript JSON object instead. * * Note: This class is deprecated. Use the JavaScript JSON object instead.
 * 
 * 
 */
declare class JSONParser {



    /**
     * Creates a JSONParser object.This class cannot be used in a scoped application. Use the JavaScript JSON object instead.This class is deprecated. Use the JavaScript JSON object instead.
     * 
     */
    constructor();

}

/**
 * JSUtil is a class of shortcuts for common JavaScript routines. Script includes and business rules that are marked as Application = "global" and Accessible from = "All applications" can be used in scoped scripts. * * JSUtil is not available in scoped scripts. * * The JSUtil API is available in server-side scripts.
 * 
 * 
 */
declare class JSUtil {



    /**
     * Checks if item is null or is undefined.
     * 
     * @item The object to check
     * @example
     * var x = "the quick brown fox";
     * var y = "";
     * var z;
     *  
     * gs.print("x = '" + x + "', JSUtil.doesNotHave(x) = " + JSUtil.doesNotHave(x));
     * gs.print("y = '" + y + "', JSUtil.doesNotHave(y) = " + JSUtil.doesNotHave(y));
     * gs.print("z = '" + z + "', JSUtil.doesNotHave(z) = " + JSUtil.doesNotHave(z))
     * @returns True if the specified object is null or undefined.
     */
    doesNotHave(item: Object): Boolean;

    /**
     * Escape ampersands commonly used to define URL attributes.
     * 
     * @text The text
     * @example
     * var attr = "sysparm_query=active=true&amp;sysparm_view=special";
     *  
     * gs.print(JSUtil.escapeAttr(attr));
     * @returns The text with ampersands properly escaped.
     */
    escapeAttr(text: String): String;

    /**
     * Escapes invalid XML characters such as "< > &".
     * 
     * @text The text
     * @example
     * var html = "&lt;b&gt;This is my title&lt;/b&gt;";
     *  
     * gs.print(JSUtil.escapeText(html));
     * @returns The text with escape characters added.
     */
    escapeText(text: String): String;

    /**
     * Returns the value in a boolean GlideRecord field.
     * 
     * @gr A GlideRecord
     * @field The field from which to retrieve the boolean value.
     * @example
     * var inc = new GlideRecord("incident");
     * //get an active incident
     * inc.addActiveQuery();
     * inc.setLimit(1);
     * inc.query();
     * inc.next();
     *  
     * gs.print(JSUtil.getBooleanValue(inc, "active"));
     * @returns Returns the value in a boolean GlideRecord field, returns true if value of field is true, "true", 1, or "1".
     */
    getBooleanValue(gr: GlideRecord, field: String): Boolean;

    /**
     * Checks if item is not null and is not undefined.
     * 
     * @item The Object to check
     * @example
     * var x = "the quick brown fox";
     * var y = "";
     * var z;
     *  
     * gs.print("x = '" + x + "', JSUtil.has(x) = " + JSUtil.has(x));
     * gs.print("y = '" + y + "', JSUtil.has(y) = " + JSUtil.has(y));
     * gs.print("z = '" + z + "', JSUtil.has(z) = " + JSUtil.has(z));
     * @returns True if the specified object is not null and is not undefined.
     */
    has(item: Object): Boolean;

    /**
     * Checks to see if the specified object is a member of the specified class.For JavaScript objects, this method behaves exactly like the JavaScript operator "instanceof", but also supports Java objects.
     * 
     * @item The object to check
     * @class The class to check
     * @example
     * var a = ['a','b','c'];
     * var b = 10;
     * var c = new GlideRecord("incident");
     *  
     * gs.print("JSUtil.instance_of(a,'Array') = " + JSUtil.instance_of(a,Array));
     * gs.print("JSUtil.instance_of(a,'String') = " + JSUtil.instance_of(a,String));
     *  
     * gs.print("JSUtil.instance_of(b,'String') = " + JSUtil.instance_of(b,String));
     *  
     * gs.print("JSUtil.instance_of(c,'GlideRecord') = " + JSUtil.instance_of(c,GlideRecord));
     * @returns True if the specified object is a member of the specified class.
     */
    instance_of(item: Object, class: String): Boolean;

    /**
     * Checks if the specified object is a Java class.
     * 
     * @value The object to check
     * @example
     * var tu = new TableUtils("incident");
     * var classes = tu.getHierarchy(); //Java ArrayList
     * var tables = ["task, incident"]; //JavaScript Array
     *  
     * gs.print("JSUtil.isJavaObject(classes) = " + JSUtil.isJavaObject(classes));
     * gs.print("JSUtil.isJavaObject(tables) = " + JSUtil.isJavaObject(tables));
     * @returns True if the specified object is an instance of a Java class.
     */
    isJavaObject(value: Object): Boolean;

    /**
     * Logs all the properties in the given object: name, type, and value.Output is written to the console if you are running from a background script or have debug logging enables. The output is also written to the system log.
     * 
     * @obj The object for which to enumerate properties
     * @name Optional name for the logged object
     * @example
     * var arr = ["a","b","c"];
     *  
     * var inc = new GlideRecord("incident");
     * //get an active incident
     * inc.addActiveQuery();
     * inc.setLimit(1);
     * inc.query();
     * inc.next();
     *  
     * JSUtil.logObject(arr, "arr");
     * JSUtil.logObject(inc, "inc");
     */
    logObject(obj: Object, name: String);

    /**
     * Checks if item is null, undefined, or evaluates to the empty string.
     * 
     * @item The object to check
     * @example
     * var x = "the quick brown fox";
     * var y = "";
     * var z;
     *  
     * gs.print("x = '" + x + "', JSUtil.nil(x) = " + JSUtil.nil(x));
     * gs.print("y = '" + y + "', JSUtil.nil(y) = " + JSUtil.nil(y));
     * gs.print("z = '" + z + "', JSUtil.nil(z) = " + JSUtil.nil(z));
     * @returns True if the item is null, undefined, or evaluates to the empty string.
     */
    nil(item: Object): Boolean;

    /**
     * Checks if item is null, undefined, or evaluates to the empty string.
     * 
     * @item The object to check
     * @example
     * var x = "the quick brown fox";
     * var y = "";
     * var z;
     *  
     * gs.print("x = '" + x + "', JSUtil.notNil(x) = " + JSUtil.notNil(x));
     * gs.print("y = '" + y + "', JSUtil.notNil(y) = " + JSUtil.notNil(y));
     * gs.print("z = '" + z + "', JSUtil.notNil(z) = " + JSUtil.notNil(z));
     * @returns True if the item exists and is not empty.
     */
    notNil(item: Object): Boolean;

    /**
     * Converts the specified object to a Boolean.
     * 
     * @item The object to convert
     * @example
     * var zero = 0;
     * var one = 1;
     * var number = 12;
     * var trueBoolean = true;
     * var trueString = "true";
     * var otherString = "random text";
     *  
     * gs.print("JSUtil.toBoolean(zero) = " + JSUtil.toBoolean(zero));
     * gs.print("JSUtil.toBoolean(one) = " + JSUtil.toBoolean(one));
     * gs.print("JSUtil.toBoolean(number) = " + JSUtil.toBoolean(number));
     * gs.print("JSUtil.toBoolean(trueBoolean) = " + JSUtil.toBoolean(trueBoolean));
     * gs.print("JSUtil.toBoolean(trueString) = " + JSUtil.toBoolean(trueString));
     * gs.print("JSUtil.toBoolean(otherString) = " + JSUtil.toBoolean(otherString));
     * @returns If the specified object is a boolean, it is passed through. Non-zero numbers return true. Null or undefined return false. Strings return true only if exactly equal to 'true'.
     */
    toBoolean(item: Object): Boolean;

    /**
     * Determines the type of the specified object.
     * 
     * @value The object to check
     * @example
     * var a = ["a","b","c"];
     * var b = 10;
     * var c = new GlideRecord("incident");
     * var d = true;
     * var e;
     *  
     * gs.print("JSUtil.type_of(a) = " + JSUtil.type_of(a));
     * gs.print("JSUtil.type_of(b) = " + JSUtil.type_of(b));
     * gs.print("JSUtil.type_of(c) = " + JSUtil.type_of(c));
     * gs.print("JSUtil.type_of(d) = " + JSUtil.type_of(d));
     * gs.print("JSUtil.type_of(e) = " + JSUtil.type_of(e));
     * @returns The type of the specified object. 'null' if the given value is null or undefined 'string' if the given value is a primitive string or a String wrapper instance 'number' if the given value is a primitive number or a Number wrapper instance 'boolean' if the given value is a primitive boolean or a Boolean wrapper instance 'function' if the given value is a function 'object' otherwise 
     */
    type_of(value: Object): String;

    /**
     * Restore ampersands from escaped text.
     * 
     * @text The text
     * @example
     * var attr = "sysparm_query=active=true&amp;amp;sysparm_view=special";
     *  
     * gs.print(JSUtil.unescapeAttr(attr));
     * @returns The text with escape characters removed.
     */
    unescapeAttr(text: String): String;

    /**
     * Removes escape characters.
     * 
     * @text The text to process.
     * @example
     * var html = "&amp;lt;b&amp;gt;This is my title&amp;lt;/b&amp;gt;";
     *  
     * gs.print(JSUtil.unescapeText(html));
     * @returns The the text without escape characters.
     */
    unescapeText(text: String): String;

}

/**
 * The legacy Notify API provides functionality for sending emails, sending SMS messages, and setting up conference calls. Use this when you want to use Notify functionality with applications on your system.Note: This API is included with the legacy Notify functionality. For APIs included in the current Notify feature, see the Notify, NotifyAction, NotifyPhoneNumber, and NotifyClient APIs.
 * 
 * 
 */
declare class Legacy Notify API {



    /**
     * Adds ad-hoc users to an ongoing conference call.When the method is called with a phone number for the participant parameter and there is exactly one sys_user record that matches the phone number, that sys_user record will be related to the participant. The participant's phone number field will be left blank because the phone number is in the sys_user record. If there are several sys_user records that match the phone number, or if there are no results, the participant's phone number field will be filled in, and there will be no stored reference to sys_user because the user is not known.
     * 
     * @conferenceCall The sys_id or GlideRecord of an active conference call.
     * @participant The sys_id or GlideRecord of a user with an E.164-compliant phone number, or an E.164-compliant phone number.
     * @example
     * // add a new participant by conference call sys_id (string) and phone number (string) 
     * var nn = new SNC.NotifyNow();
     * gs.log(nn.addConferenceCallParticipant('d193b242eb020100a04d4910f206fe39', '+31612345678'));
     * @example
     * // add a new participant by conference call sys_id (string) and user record (GlideRecord)
     * var user = new GlideRecord('sys_user');
     * user.query('user_name', 'myUserName');
     * if (user.hasNext() &amp;&amp; user.next()) {
     *     var nn = new SNC.NotifyNow();
     *     gs.log(nn.addConferenceCallParticipant('d193b242eb020100a04d4910f206fe39', user));
     *  
     *     // you could have added the user by sys_id as well:
     *     // nn.addConferenceCallParticipant('d193b242eb020100a04d4910f206fe39', user.getValue('sys_id'));
     * } else {
     *     gs.log('no such user');
     * }
     * @example
     * // add a new participant by conference call record (GlideRecord) and phone number (string)
     * var conferenceCall = new GlideRecord('notifynow_conference_call');
     * conferenceCall.query('title', 'IA0001001');
     * if (conferenceCall.hasNext() &amp;&amp; conferenceCall.next()) {
     *     var nn = new SNC.NotifyNow();
     *     gs.log(nn.addConferenceCallParticipant(conferenceCall, '+31612345678'));
     * } else {
     *     gs.log('no such conference call');
     * }
     * @returns The participant record of the new participant that was added to the conference call.
     */
    addConferenceCallParticipant(conferenceCall: StringorGlideRecord, participant: StringorGlideRecord): GlideRecord;

    /**
     * Converts a local phone number to an E.164-compliant phone number based on a user's location.
     * 
     * @userID The sys_id of a sys_user record to get location information from.
     * @phoneNumber The phone number.
     * @example
     * var localPhoneNumber = '01784 221600';
     * var userName = 'Heath Vanalphen';
     *  
     * var user = new GlideRecord('sys_user');
     * user.get('name',userName);
     * var E164Number = new SNC.NotifyNow().convertLocalPhoneNumberToE164(user.getUniqueValue(), localPhoneNumber);
     * gs.log('converted: ' + localPhoneNumber + ' to ' + E164Number + ' based on ' + user.getValue('name') + 
     *      '\'s location (' + user.getValue('location') + ')');
     * @returns The E.164-compliant phone number.
     */
    convertLocalPhoneNumberToE164(userID: String, phoneNumber: String): String;

    /**
     * Returns all participants for a conference call.
     * 
     * @conferenceCallId The ID of the conference call.
     * @isCallable An optional flag to return either only the users you can call (true) or those you cannot call (false).
     * @example
     * var nn = new SNC.NotifyNow();
     * var user = nn.getConferenceCallParticipants('c2e91710eb120100f34087b9d106fe37');
     *  
     * while (user.hasNext() &amp;&amp; user.next()) {
     *     if (user.getValue('participant')) {
     *         gs.log('user: ' + user.getValue('sys_id'));
     *     } else {
     *         gs.log('phone number: ' + user.getValue('phone_number'));
     *     }
     * }
     * @example
     * var nn = new SNC.NotifyNow();
     * var user = nn.getConferenceCallParticipants('c2e91710eb120100f34087b9d106fe37', true);
     *  
     * while (user.hasNext() &amp;&amp; user.next()) {
     *     if (user.getValue('participant')) {
     *         gs.log('user: ' + user.getValue('sys_id'));
     *     } else {
     *         gs.log('phone number: ' + user.getValue('phone_number'));
     *     }
     * }
     * @example
     * var conferenceCallId = '32b11430eb1201003cf587b9d106feb8';
     *  
     * // get all participants
     * gs.log('all conference call participants:');
     * var nn = new SNC.NotifyNow();
     * var user = nn.getConferenceCallParticipants(conferenceCallId);
     * gs.log(user);
     *  
     * // get all callable participants
     * gs.log('all conference call participants we can call:');
     * user = nn.getConferenceCallParticipants(conferenceCallId, true);
     * gs.log(user);
     *  
     * // get all un callable participants
     * gs.log('all conference call participants that are already in an active session and whom we cannot call:');
     * user = nn.getConferenceCallParticipants(conferenceCallId, false);
     * gs.log(user);
     * @returns The participants
     */
    getConferenceCallParticipants(conferenceCallId: String, isCallable: Boolean): GlideRecord;

    /**
     * Returns a number of frequently-called users, up to the limit parameter, in alphabetical order.
     * 
     * @limit The maximum number of results.
     * @example
     * var nn = new SNC.NotifyNow();
     * var fc = nn.getFrequentlyCalledUsers(10);
     *  
     * while (fc.hasNext() &amp;&amp; fc.next()) {
     *     gs.log("got user " + fc.getValue('name') + ' - ' + fc.getValue('sys_id'));
     * }
     * @returns The frequently called users in alphabetical order.
     */
    getFrequentlyCalledUsers(limit: Number): GlideRecord;

    /**
     * Returns a user's preferred E.164-compliant phone number for SMS messages.
     * 
     * @user The user record or the sys_id of a user to get the E.164-compliant phone number from.
     * @example
     * var userID = "&lt;user sys_id&gt;";
     * var E164Number = new SNC.NotifyNow().getPreferredE164SMSNumber(userID);
     * gs.log('the preferred phone number for sending SMS notifications is ' + E164Number + ' for user with id: ' + userID);
     * @returns The E.164-compliant phone number or null.
     */
    getPreferredE164SMSNumber(user: GlideRecordorString): String;

    /**
     * Returns a user's preferred E.164-compliant phone number for voice calls.
     * 
     * @user The user record or the sys_id of a user to get the E.164-compliant phone number from.
     * @example
     * var userID = "&lt;user sys_id&gt;";
     * var E164Number = new SNC.NotifyNow().getPreferredE164VoiceNumber(userID);
     * gs.log('the preferred phone number for setting up voice calls is ' + E164Number + ' for user with id: ' + userID);
     * @returns The E.164-compliant phone number or null.
     */
    getPreferredE164VoiceNumber(user: GlideRecordorString): String;

    /**
     * Returns a user's preferred email address
     * 
     * @user The user record or the sys_id of a user to get the email address from.
     * @example
     * var userID = "some user sys id";
     * var email = new SNC.NotifyNow().getPreferredEmailAddress(userID);
     * gs.log('the preferred email address for sending email notifications is ' + email + ' for user with id: ' + userID);
     * @returns The email address or null.
     */
    getPreferredEmailAddress(user: GlideRecordorString): String;

    /**
     * Indicates whether Notify is set up correctly or not.This method can only be accessed by administrators or users with the notifynow_admin role. Users with all other roles get the message False when trying to run the function in a script.
     * 
     * @example
     * var nn = new SNC.NotifyNow();
     * gs.log(((nn.getReadyState()) ? "OK" :  "NOT OK"));
     * @returns True if Notify is set up correctly, otherwise false.
     */
    getReadyState(): Boolean;

    /**
     * Returns the current status of Notify configuration.This method can only be accessed by administrators or users with the notifynow_admin role. Users with all other roles get the message Unauthorized when trying to run the function in a script.
     * 
     * @example
     * var nn = new SNC.NotifyNow();
     * gs.log(nn.getStatus());
     * @returns One of the possible status messages. Status Description NO_NUMBER_MESSAGE The account does not have a telephone number set up. Ensure that you set up the telephone number for the account. NO_ENDPOINTS_MESSAGE The account does not have its endpoints set up correctly. Ensure that you set up the endpoints for the account. ACCOUNT_OK_MESSAGE The account is active and ready for use. ACCOUNT_NO_AUTH The Twilio AuthToken is not valid. ACCOUNT_NOT_CONFIGURED The Twilio AccountSID or AuthToken is not valid. 
     */
    getStatus(): String;

    /**
     * Initiate a new conference call.
     * 
     * @conferenceCallParticipants One or more users, conference call participants, identified by the sys_ids from the sys_user table or E.164-compliant phone numbers.
     * @conferenceCallTitle Title of the conference call. This parameter has a maximum length of 40 characters.
     * @example
     * var participants = ['+31205655548', '+31205655552', '+31652825393'];
     * // set up conference call
     * var nn = new SNC.NotifyNow();
     * var conferenceCall = nn.initiateConferenceCall(participants, "testing12");
     * gs.log('started conference call: ' + conferenceCall.getUniqueValue());
     * @returns The conference call record, or null if there was an error.
     */
    initiateConferenceCall(conferenceCallParticipants: String, conferenceCallTitle: String): GlideRecord;

    /**
     * Initiate a new conference call.
     * 
     * @conferenceCallParticipants One or more users, conference call participants, identified by the sys_ids from the sys_user table or E.164-compliant phone numbers.
     * @conferenceCallTitle Title of the conference call. This parameter has a maximum length of 40 characters.
     * @sourceRecord Source record to associate to the conference call such as an incident or problem number.
     * @private Value to control if a conference call is private. This value defaults to false.
     * @example
     * // define phone number participants
     * var participants = ['+31205655548', '+31205655552', '+31652825393'];
     *  
     * // we also want to add two Dutch sys_user participants
     * var user = new GlideRecord('sys_user');
     * user.addNotNullQuery('mobile_phone');
     * user.addQuery('mobile_phone', 'STARTSWITH', '+316');
     * user.setLimit(2);
     * user.query();
     *  
     * // add users to the participant array
     * while (user.hasNext() &amp;&amp; user.next()) {
     * 	gs.log('adding user ' + user.getValue('name') + ' with phone number ' + 
     *              user.getValue('mobile_phone') + ' to the participant array');
     * 	participants.push(user.getUniqueValue());
     * }
     *  
     * // define a source record to associate with the conference call
     * var source = new GlideRecord("cmdb_ci");
     * source.query("asset_tag", "P1000167");
     * if (source.hasNext() &amp;&amp; source.next()) {
     * 	// set up conference call
     * 	var nn = new SNC.NotifyNow();
     * 	var conferenceCall = nn.initiateConferenceCall(participants, "testing 1 2", source);
     *  
     * 	// check if the conference call was successfully created
     * 	if (conferenceCall != null) {
     * 		gs.log('started conference call: ' + conferenceCall.getUniqueValue());
     * 	} else {
     * 		gs.log('could not start the conference call :(');
     * 	}
     * }
     * @returns The conference call record, or null if there was an error.
     */
    initiateConferenceCall(conferenceCallParticipants: String, conferenceCallTitle: String, sourceRecord: GlideRecord, private: Boolean): GlideRecord;

    /**
     * Determines whether a user is callable or not.A user must have a valid phone number to be callable. A user who is already in an active session is not callable.
     * 
     * @participant A sys_user or notifynow_participant record, or an E.164-compliant phone number.
     * @example
     * var nn = new SNC.NotifyNow();
     * gs.log('by number: ' + nn.isCallable('+31612345678'));
     *  
     * var user = GlideRecord('sys_user');
     * user.query('sys_id', '13d39544eb5201003cf587b9d106fea9');
     * if (user.hasNext() &amp;&amp; user.next())
     *   gs.log('by user: ' + nn.isCallable(user));
     *  
     * var participant = GlideRecord('notifynow_participant');
     * participant.query('sys_id', '33b11430eb1201003cf587b9d106feb9');
     * if (participant.hasNext() &amp;&amp; participant.next())
     *   gs.log('by participant: ' + nn.isCallable(participant));
     * @returns Whether this participant can be called or not.
     */
    isCallable(participant: StringorGlideRecord): boolean;

    /**
     * Checks if the telephone number associated with the Twilio account is capable of sending SMS messages.
     * 
     * @example
     * gs.log('The twilio number is SMS capable: ' + ((new SNC.NotifyNow().isSMSCapable()) ? 'yes' : 'no'));
     * @returns Whether the telephone number associated with the Twilio account is capable of sending SMS messages.
     */
    isSMSCapable(): Boolean;

    /**
     * Checks if a user is able to send SMS messages.
     * 
     * @userID The sys_id of the user you want to check for an SMS-capable phone number.
     * @example
     * gs.log('the user is able to send SMS messages (e.g. has a SMS device): ' + ((new SNC.NotifyNow().isSMSCapable('&lt;user sys_id&gt;')) ? 
     *      'yes' : 'no'));
     * @returns If the user can send SMS messages.
     */
    isSMSCapable(userID: String): Boolean;

    /**
     * Checks if the telephone number associated with the Twilio account is capable of setting up phone calls.
     * 
     * @example
     * gs.log('the Twilio number is Voice capable: ' + ((new SNC.NotifyNow().isVoiceCapable()) ? 'yes' : 'no'));
     * @returns Whether the telephone number associated with the Twilio account is capable of setting up phone calls.
     */
    isVoiceCapable(): Boolean;

    /**
     * Checks if a user is able to make voice calls.
     * 
     * @userID The sys_id of the user you want to check for a voice-call capable phone number.
     * @example
     * gs.log('the user is able to send SMS messages (e.g. has a SMS device): ' + 
     *      ((new SNC.NotifyNow().isVoiceCapable('someuserid')) ? 'yes' : 'no'));
     * @returns Whether the user has a voice-call capable phone number.
     */
    isVoiceCapable(userID: String): boolean;

    /**
     * Removes a participant from a conference call.
     * 
     * @participant The conference call participant to remove from the call.
     * @example
     * var participantId = "&lt;participant sys_id&gt;";
     * var participant = new GlideRecord('notifynow_participant');
     * participant.get(participantId);
     * if (participant.isValid()) {
     *      // kick participant
     *      result = new SNC.NotifyNow().kick(participant);
     *      gs.log('participant kicked: ' + result);
     * }
     * @returns True if the participant was removed, otherwise false.
     */
    kick(participant: GlideRecord): Boolean;

    /**
     * Mutes a participant on a conference call.
     * 
     * @participant The conference call participant to mute.
     * @example
     * var participantId = "&lt;participant sys_id&gt;";
     * var participant = new GlideRecord('notifynow_participant');
     * participant.get(participantId);
     * if (participant.isValid()) {
     *      // mute participant
     *      result = new SNC.NotifyNow().mute(participant);
     *      gs.log('participant muted: ' + result);
     * }
     * @returns True if the participant was muted, otherwise false.
     */
    mute(participant: GlideRecord): Boolean;

    /**
     * Send an email question to an email address.The sendEmailQuestion method produces a question body and requires users to click a link to indicate their choice.
     * 
     * @emailAddress Email address to send the question to.
     * @question The question record to send or the sys_id of a question record.
     * @sourceRecord An optional source record to associate to the SMS question, such as an incident.
     * @emailSubject Optional text to override the default email subject.
     * @example
     * var user = GlideRecord("sys_user");
     * user.get("email", "someone@somedomain.com");
     *  
     * new SNC.NotifyNow().sendEmailQuestion(user.getValue('email'), "b6b34500bf3111003cf585ce2c0739ce", user);
     * @example
     * new SNC.NotifyNow().sendEmailQuestion("someone@somedomain.com", "b6071733bf1111003cf585ce2c07390f", current, 
     *         "Please answer this question");
     * @example
     * new SNC.NotifyNow().sendEmailQuestion("someone@somedomain.com", "b6071733bf1111003cf585ce2c07390f", 
     *         "Please answer this question");
     * @returns The conversation sys_id.
     */
    sendEmailQuestion(emailAddress: String, question: StringorGlideRecord, sourceRecord: GlideRecord, emailSubject: String): String;

    /**
     * Sends an SMS message to an E.164-compliant mobile phone number.Notify supports international numbers. Using this method with a number that does not support sending SMS messages results in an error being logged.
     * 
     * @phoneNumber The E.164-compliant phone number to send the message to.
     * @smsBody The message to send, maximum 1600 characters.
     * @example
     * new SNC.NotifyNow().sendSMS("+31612345678", "This is a message without source record");
     */
    sendSMS(phoneNumber: String, smsBody: String);

    /**
     * Sends an SMS message to an E.164-compliant mobile phone number.Notify supports international numbers. Using this method with a number that does not support sending SMS messages results in an error being logged.
     * 
     * @phoneNumber The E.164-compliant phone number to send the message to.
     * @smsBody The message to send, maximum 1600 characters.
     * @source The source record to associate with this SMS message.
     * @example
     * var source = new GlideRecord("my_table");
     * source.query("my_field", "my_value");
     * 
     * if (source.hasNext() &amp;&amp; source.next()) {
     *     // send a text message
     *     var nn = new SNC.NotifyNow();
     *     var message = "this is just a test";
     *     var number = "+31612345678";
     *     nn.sendSMS(number, message, source);
     * }
     * @example
     * new SNC.NotifyNow().sendSMS("+31612345678", "this is a test", current);
     */
    sendSMS(phoneNumber: String, smsBody: String, source: GlideRecord);

    /**
     * Sends an SMS question.
     * 
     * @phoneNumber An E.164-compliant phone number to send the message to.
     * @question The question record to send or the sys_id of a question record.
     * @sourceRecord An optional source record to associate to the SMS question, such as an incident.
     * @example
     * var question = new GlideRecord("notifynow_question");
     * question.query();
     *  
     * // get the first question
     * if (question.hasNext() &amp;&amp; question.next()) {
     * 	// send the sms question
     *         var number = "+31612345678";
     * 	var nn = new SNC.NotifyNow();
     * 	nn.sendSMSQuestion(number, question.getUniqueValue(), current);
     * }
     * @returns The conversation sys_id, or null if the SMS was not sent successfully.
     */
    sendSMSQuestion(phoneNumber: , question: StringorGlideRecord, sourceRecord: ): String;

    /**
     * Unmutes a participant on a conference call.
     * 
     * @participant The muted conference call participant to unmute.
     * @example
     * var participantId = "&lt;participant sys_id&gt;";
     * var participant = new GlideRecord('notifynow_participant');
     * participant.get(participantId);
     * if (participant.isValid()) {
     *      // unmute participant
     *      result = new SNC.NotifyNow().unmute(participant);
     *      gs.log('participant unmuted: ' + result);
     * }
     * @returns True if the participant was unmuted, otherwise false.
     */
    umute(participant: GlideRecord): Boolean;

}

/**
 * Inbound email actions can use this JavaScript function to append messages to the email log. The Logger class provides methods that add standard, warning, and error messages to the email log. The added message has its source set to email.&lt;Sys ID of incoming email&gt;.
 * 
 * 
 */
declare class Logger {



    /**
     * Appends the specified message to the email log.
     * logger.log("Some information");
     * 
     * 
     * @msg Text to append to the email log. These should be information type messages.
     */
    log(msg: String);

    /**
     * Appends the specified error message to the email log file.logger.logError("Some error");
     * 
     * 
     * @msg Error message to append to the email log
     */
    logError(msg: String);

    /**
     * Appends the specified warning message to the email log file.logger.logWarning("Some warning");
     * 
     * 
     * @msg Warning message to append to the email log
     */
    logWarning(msg: String);

}

/**
 * Parses the output of the lsof command: lsof -i4TCP -n -P -F pcnfT Use this API with a discovery script when you need to parse lsof output.
 * 
 * 
 */
declare class LSOFParser {



    /**
     * Generates the specified error message.
     * 
     * @msg The error message
     */
    error(msg: String);

    /**
     * Initializes the file descriptor process.
     * 
     */
    initFileDescriptor();

    /**
     * Initializes the parser process.
     * 
     */
    initProcess();

    /**
     * Sets the current command.
     * 
     * @line The command
     */
    on_c(line: String);

    /**
     * Closes the file descriptor process.
     * 
     */
    on_endFileDescriptor();

    /**
     * Closes the parser process.
     * 
     */
    on_endProcess();

    /**
     * Sets the current file descriptor.
     * 
     * @line The file descriptor
     */
    on_f(line: String);

    /**
     * Sets the current address.
     * 
     * @line The address
     */
    on_n(line: String);

    /**
     * Sets the current PID.
     * 
     * @line The PID
     */
    on_p(line: String);

    /**
     * Sets the current state.
     * 
     * @line The state
     */
    on_T(line: String);

    /**
     * Parses the specified lsof output.Results are available in connections and listeners arrays, and errors are recorded in errorString() and isValid().
     * 
     * @lsofOutput The lsof output
     */
    parse(lsofOutput: String);

}

/**
 * Encapsulates the notion of a MID server. Use these methods in server scripts to manage a MID server using Ajax.
 * 
 * 
 */
declare class MIDServer {

    /** The name of the MID server's host . */
    hostname: String
    /** The operating system of the MID server's host. */
    hostOS: String
    /** The IP address of the MID server's host . */
    ip: String
    /** Name of the MID server. */
    name: String
    /** The network containing the MID server's host. */
    network: String
    /** The IP address of the MID server host's default router. */
    routerIP: String
    /** The MID server's status ("Up" or "Down"). */
    status: String
    /** The sys_id of the MID server record. */
    sysID: String
    /** The URL the MID server uses to contact the instance. */
    url: String
    /** Version of the MID server (WAR name). */
    version: String
    /** Windows domain of the MID server's host (if it is a Windows machine). */
    windowsDomain: String


    /**
     * Returns the specified MID server.
     * 
     * @name The MID server name
     * @returns The record of the requested MID server.
     */
    getByName(name: String): GlideRecord;

    /**
     * Returns the MID server associated with the specified schedule (the MID server with the same name). If there is no associated MID server, gets the next MID server in the ecc_agent table.
     * 
     * @schedule The discovery schedule
     * @returns The MID server
     */
    getDefault(schedule: DiscoverySchedule): GlideRecord;

    /**
     * Returns the MID Server with the specified schedule and range set.
     * 
     * @schedule The discovery schedule
     * @range The discovery range set
     * @returns The MID server
     */
    getForPing(schedule: DiscoverySchedule, range: DiscoveryRange): GlideRecord;

}

/**
 * Provides AJAX functionality for sending a test probe to the MID server. Use in server scripts to test a MID server using AJAX.
 * 
 * 
 */
declare class MIDServerAjax {



    /**
     * Creates an instance of MIDServerAjax.
     * 
     */
    constructor();

    /**
     * Sends a test probe to the MID server.
     * 
     * @example
     * var msaj = new MIDServerAjax();
     * msaj.ajaxFunction_testProbe();
     * @returns Contains the agent name, test probe ID, topic, name, and source.
     */
    ajaxFunction_testProbe(): Object;

}

/**
 * Finds the MID server clusters for a given MID server and reassigns the jobs if necessary. If the MID server agent is up, this class gathers all MID servers (including the original agent) in the load balance clusters that the original agent is part of. If the MID server agent is down and the cluster is load balanced, the class gathers the other agents. If the server agent is down, and the cluster is failover, it gathers the next failover agent. The class then randomly returns the MID server in the final list of MID servers. * * Use in server scripts to get MID server cluster information.
 * 
 * 
 */
declare class MIDServerCluster {



    /**
     * Brief description of the method.
     * 
     * @agent The MID server agent
     */
    constructor(agent: GlideRecord);

    /**
     * Determines if a cluster exists.
     * 
     * @example
     * var midgr = new GlideRecord("ecc_agent");
     * midgr.addQuery("name", "al1winmid");
     * midgr.query();
     * midgr.next();
     *  
     * var mscl = new MIDServerCluster(midgr);
     * gs.print(mscl.clusterExists());
     * @returns True if a cluster exists; otherwise, false.
     */
    clusterExists(): Boolean;

    /**
     * Gets the cluster agent.
     * 
     * @example
     * // Assuming "mid1" and "mid2" are in a cluster
     * var midgr = new GlideRecord("ecc_agent");
     * midgr.addQuery("name", "mid1");
     * midgr.query();
     * midgr.next();
     *  
     * var mscl = new MIDServerCluster(midgr);
     * gs.print(mscl.getClusterAgent());
     * @returns The agent name
     */
    getClusterAgent(): String;

}

/**
 * Checks to see if there are any changes to attachments on tables that are instances of MID server synchronized files (ecc_agent_sync_file) and, if so, notifies the MID servers of a change. The tables that extend the sync tables are MID Server JAR file (ecc_agent_jar) and MID Server MIB File (ecc_agent_mib). * * Use in server scripts to notify MID servers.
 * 
 * 
 */
declare class MIDServerFileSync {



    /**
     * Creates an instance of MIDServerFileSync.
     * 
     */
    constructor();

    /**
     * Checks for any changes to attachments on the specified table that are instances of MID server synchronized files and, if so, notifies the MID servers of a change.
     * 
     * @table The table to check
     * @example
     * var msfs = new MIDServerFileSync();
     * msfs.notifyMIDServers('ex.table.name');
     */
    notifyMIDServers(table: String);

}

/**
 * Finds a list of MID servers for given IP addresses. Use in server scripts to get the server list.
 * 
 * 
 */
declare class MIDServerFinder {



    /**
     * Creates an instance of MIDServerFinder.
     * 
     */
    constructor();

    /**
     * Gets the names of MID servers available for a given range and capability.
     * 
     * @example
     * var msf = new MIDServerFinder();
     * msf.setRanges('10.10.10.1-10.10.11.254');
     * var msnames = msf.getMIDServers();
     *  
     * for(var i=0; i&lt;msnames.length; i++) {
     *   gs.print(msnames[i]);
     * };
     * @returns An array of MID server names. If no MID servers are available, returns an empty array.
     */
    getMIDServers(): Array<any>;

    /**
     * Gets the sys_ids of MID servers available for a given range and capability.
     * 
     * @example
     * var msf = new MIDServerFinder();
     * msf.setRanges('10.10.10.1-10.10.11.254');
     * var msids = msf.getMIDServersBySysId();
     *  
     * for(var i=0; i&lt;msids.length; i++) {
     *   gs.print(msids[i]);
     * };
     * @returns An array of MID server sys_ids. If no MID servers are available, returns an empty array.
     */
    getMIDServersBySysId(): Array<any>;

    /**
     * Gets the state of the finder operation.
     * 
     * @example
     * var msf = new MIDServerFinder();
     * gs.print(msf.getStatusMessage());
     * @returns The status message
     */
    getStatusMessage(): String;

    /**
     * Sets whether to look for active or inactive MID servers. By default, searches are for active MID servers unless inactive is specified by this method.
     * 
     * @flag If true, look for inactive MID servers. If false, do not look for inactive MID servers.
     * @example
     * var msf = new MIDServerFinder();
     * msf.setActive('true');
     */
    setActive(flag: Boolean);

    /**
     * Sets the technologies for which to look.
     * 
     * @capabilities Contains a list of capabilities, for example - capabilities = ["ssh","wmi","snmp",{"os_domain":"disco"},{"phase":1}];
     * @example
     * var msf = new MIDServerFinder();
     * msf.setRanges('10.10.10.1-10.10.11.254');
     * var capab = ["ssh","wmi","snmp"];
     * msf.setCapabilities(capab);
     */
    setCapabilities(capabilities: Array<any>);

    /**
     * Turns debugging on or off.
     * 
     * @onOrOff True to turn on debugging; false to turn debugging off.
     * @example
     * var msf = new MIDServerFinder();
     * msf.setDebug('true');
     */
    setDebug(onOrOff: Boolean);

    /**
     * Sets the range of IP addresses for which to look.
     * 
     * @ranges A comma-separated list in one of these formats. IP addresses (10.10.10.1, 10.10.10.2) IP networks (10.10.10.0/23) IP ranges (10.10.10.1-10.10.11.254) 
     * @example
     * var msf = new MIDServerFinder();
     * msf.setRanges('10.10.10.1-10.10.11.254');
     */
    setRanges(ranges: String);

    /**
     * Determines if the input is a single IP or a hostname, and passes the IP or multiple IPs to the setRanges() method.If the value of ipOrHostname is an IP address, it is passed into the setRanges() method. It the value is a hostname, we look up the DNS table (cmdb_ip_address_dns_name) to try resolving the hostname. The result, either an IP or multiple IPs, is then passes into the setRanges() method.
     * 
     * @ipOrHostname The IP address, IP range, or host name.
     * @example
     * var msf = new MIDServerFinder();
     * msf.setRangesByIPOrHostname('10.10.10.1-10.10.11.254');
     */
    setRangesByIPOrHostname(ipOrHostname: String);

}

/**
 * Allows you to manage a MID server, by sending messages to start, stop, upgrade, get logs, send test probes, and send system messages. Use in server scripts to send messages to a MID server.
 * 
 * 
 */
declare class MIDServerManage {



    /**
     * Creates an instance of MIDServerManage.
     * 
     */
    constructor();

    /**
     * Gets the logs for the specified MID server.
     * 
     * @agentName The MID server name
     * @logs The type of log to get (Optional)
     * @example
     * var msm = new MIDServerManage();
     * msm.grab_logs('serv1');
     * @returns The log message
     */
    grab_logs(agentName: String, logs: String): String;

    /**
     * Restarts the specified MID server.
     * 
     * @agentName The MID server name
     * @example
     * var msm = new MIDServerManage();
     * msm.restart('serv1');
     */
    restart(agentName: String);

    /**
     * Stops the specified MID server.
     * 
     * @agentName The MID server name
     * @example
     * var msm = new MIDServerManage();
     * msm.stop('serv1');
     */
    stop(agentName: String);

    /**
     * Creates a system message for the specified MID server.
     * 
     * @agentName The MID server name
     * @cmd The value of the probe source field
     * @name The name of the probe
     * @example
     * var msm = new MIDServerManage();
     * msm.test_probe('mid.server.serv1', 'command', 'probe_id');
     */
    system_msg(agentName: String, cmd: String, name: String);

    /**
     * Sends a test probe for the specified MID server.
     * 
     * @agentName The MID server name
     * @probeId The ID of the probe to send
     * @topic The information for the topic field
     * @ename The name for the probe
     * @source The information for the source field
     * @example
     * var msm = new MIDServerManage();
     * msm.test_probe('mid.server.serv1', 'probe_id', 'topic text', 'name', 'source text');
     * @returns The probe for the specified MID server
     */
    text_probe(agentName: String, probeId: String, topic: String, ename: String, source: String): Object;

    /**
     * Upgrades the specified MID server.
     * 
     * @agentName The MID server name
     * @example
     * var msm = new MIDServerManage();
     * msm.upgrade('serv1');
     */
    upgrade(agentName: String);

}

/**
 * Finds a MID server based on capabilities and target IP address. Use in server scripts to find a MID server with specific capabilities.
 * 
 * 
 */
declare class MIDServerSelector {



    /**
     * Creates an instance of MIDServerSelector.
     * 
     */
    constructor();

    /**
     * Finds the MID server based on the capabilities and target IP address.
     * 
     * @target The target IP address
     * @example
     * var mss = new MIDServerSelector();
     * var capab = ["ssh","wmi","snmp"];
     * mss.setCapabilities(capab);
     * mss.findAgent('100.101.10.10');
     */
    findAgent(target: String);

    /**
     * Gets the error messages for the current MID server.
     * 
     * @example
     * var mss = new MIDServerSelector();
     * var capab = ["ssh","wmi","snmp"];
     * mss.setCapabilities(capab);
     * mss.findAgent('100.101.10.10');
     * mss.getError();
     */
    getError();

    /**
     * Gets the warning messages for the current MID server.
     * 
     * @example
     * var mss = new MIDServerSelector();
     * var capab = ["ssh","wmi","snmp"];
     * mss.setCapabilities(capab);
     * mss.findAgent('100.101.10.10');
     * mss.getWarning();
     */
    getWarning();

    /**
     * Sets the technologies for which to look.
     * 
     * @capabilities A list of capabilities, for example - capabilities = ["ssh","wmi","snmp",{"os_domain":"disco"},{"phase":1}];
     * @example
     * var mss = new MIDServerSelector();
     * var capab = ["ssh","wmi","snmp"];
     * mss.setCapabilities(capab);
     */
    setCapabilities(capabilities: Array<any>);

}

/**
 * Provides utility methods for Agent Intelligence predictions. The MLPredictor API requires the Agent Intelligence plugin (com.glide.platform_ml) and is provided within the sn_ml namespace. * * This class contains all methods necessary to get prediction results from input data.
 * 
 * 
 */
declare class MLPredictor {



    /**
     * Instantiates a new MLPredictor object.
     * 
     * @example
     * function executeRule(current, previous //null when async) {
     * 	var predictor = new MLPredictor();
     * 	predictor.recordFinalValuesInPredictionResults(current, "On close");
     * 
     * }(current, previous);
     */
    constructor();

    /**
     * Sets predicted values from an array of specified solutions to a specified record.
     * 
     * @gr The record on which to apply the array of predicted solutions
     * @solutions Specified solution objects associated with the GlideRecord
     * @example
     * (function executeRule(current, previous //null when async) {
     *     var mlPredictor = new MLPredictor();
     *     //Get the list of active solutions for the glide record table
     *     var solutions = mlPredictor.findActiveSolutionsForRecord(current);
     *     //Run prediction and apply predicted value to the record
     *     mlPredictor.applyPrediction(current, solution);
     * 
     * })(current, previous);
     */
    applyPrediction(gr: GlideRecord, solutions: Array<any>);

    /**
     * Applies a predicted value from a specified classification solution to the specified GlideRecord.For each solution in the GlideRecord, call this method to predict the results and set the field value on the incident to those results.
     * 
     * @gr GlideRecord object containing values on which to run a prediction and apply the results
     * @solution Classification solution object to be executed
     * @example
     * 
     * (function executeRule(current, previous //null when async) {
     * 	var solutionNames = ["solution1", "solution2", ...];
     * 
     * 	// For domain separation (MSP) use case 
     * //	var solutionNames;
     * //	if (current.sys_domain == "A")
     * //		solutionNames = ["solution_A1", "solution_A2", ...];
     * //	else if (current.sys_domain == "B")
     * //		solutionNames = ["solution_B1", "solution_B2", ...];
     * //	else
     * //		...
     * 
     * 	var predictor = new MLPredictor();
     * 	var info = "";
     * 	solutionNames.forEach(function(solutionName) {
     * 		var solution = predictor.findActiveSolution(solutionName);
     * 		if (!solution)
     * 			return;
     * 
     * 		// The next line of code is doing the prediction and updating current record. 
     * 		// If no prediction is done, we don't build prediction info message. 
     * 		if (!predictor.applyPredictionForSolution(current, solution))
     * 			return;
     * 
     * 		// If user doesn't have 'itil' role, we don't build prediction info message. 
     * 		if (!gs.hasRole('itil'))
     * 			return;
     * 
     * 		// Building prediction info message 
     * 		var fieldName = solution.getPredictedField();
     * 		var fieldLabel = current.getElement(fieldName).getED().getLabel();
     * 		var predictedDisplayValue = current.getDisplayValue(fieldName);
     * 		var msg = gs.getMessage("Predicted {0} for {1}.", [predictedDisplayValue, fieldLabel]);
     * 		if (info.length &gt; 0)
     * 			info += " ";
     * 		info += msg;
     * 	});
     * 	// Print out prediction info message on screen. 
     * 	if (info.length &gt; 0) {
     * 		var incidentUrl = "&lt;a href='"+current.getLink()+"'&gt;"+current.number+":&lt;/a&gt;";
     * 		gs.addInfoMessage(incidentUrl + " " + info);
     * 	}
     * })(current, previous);
     * @returns True upon prediction success, error otherwise
     */
    applyPredictionForSolution(gr: GlideRecord, solution: Object): Boolean;

    /**
     * Gets the solution object.This method only returns the solutions if the ml_solution definition and solution are active.
     * 
     * @solutionName Name of the ml_solution record
     * @example
     * var solutionName = 'ml_incident_assignment';
     *   var shortDescriptionValue = "Unable to connect!"
     *   var input = {
     *   short_description : shortDescriptionValue
     *   };
     *   var MLP = new MLPredictor();
     *   var solution = MLP.findActiveSolution(solutionName);
     *   var predictedOutcome = solution.predictText(input);
     *   var outcome = predictedOutcome.predictedValue();
     *   var confidence = predictedOutcome.confidence();
     *   gs.info("Predicted value: " + outcome)
     *   gs.info("Confidence: " + confidence)
     *         
     * @returns Solution object for the specified solutionName if the ml_solution definition and solution is active, null otherwise
     */
    findActiveSolution(solutionName: String): Object;

    /**
     * Gets active solutions for a table in a specified GlideRecord.
     * 
     * @gr GlideRecord from which to collect active solution objects
     * @example
     * // This is only to get a hard-coded GR 
     *      var current = new GlideRecord('incident');
     *      current.get('965c9e5347c12200e0ef563dbb9a7156');
     *      var predictor = new MLPredictor();
     *      var solutions = predictor.findActiveSolutionsForRecord(current);
     *      solutions.forEach(function(solution) {
     *          var outcome = solution.predict(current);
     *          // Use this to set the field to the predicted value in the GlideRecord 
     *          var fieldName = solution.getPredictedField();
     *          current[fieldName] = outcome.predictedValue();
     *          current.update();
     * 
     *          gs.info("Predicted value: " + outcome.predictedValue())
     *          gs.info("Confidence: " + outcome.confidence())
     * });
     * @returns Array of active solution objects associated with the table that the specified record is for
     */
    findActiveSolutionsForRecord(gr: GlideRecord): Array<any>;

    /**
     * Gets the predicted value for a specified solution based on the specified prediction outcome.
     * 
     * @solution Solution from which to get the predicted value
     * @outcome Prediction outcome results for the specified solution (var outcome = solution.predict(gr))
     * @returns Predicted value for specified solution based on the specified outcome of the prediction
     */
    getPredictedValue(solution: Object, outcome: Object): String;

    /**
     * Gets predictions for a specified solution.
     * 
     * @gr GlideRecord to be predicted
     * @solution Solution object to be executed
     * @options Optional JSON object key value pair with the following properties: options.top_n: If provided, returns results up to the expected number of predictions, otherwise default is read from the glide.platform_ml.max_num_predictions system property. options.apply_threshold: Checks the threshold value (solution threshold for similarity, class level threshold for classification) for the solution and applies it to the result set. Default value is true. 
     * @example
     * function printOutcomeArr(outcomeArr) {
     * gs.print('################## Results ##################');
     * for (var i=0; i&lt;outcomeArr.length; i++) {
     *     var outcome = outcomeArr[i];
     *     gs.print((i+1) + ' : ' + outcome.predictedValue() + ', ' + outcome.predictedValueSysId() + ', ' + outcome.confidence());
     * }
     * }
     * 
     * var solutionName = 'ml_x_snc_global_prop_flip_test';
     * var predictor = new MLPredictor();
     * var solution = predictor.findActiveSolution(solutionName);
     * 
     * var gr = new GlideRecord('incident');
     * gr.get('1c741bd70b2322007518478d83673af3');
     * 
     * var options = {};
     * options.top_n = '10';            // top_n is an integer between 1 and 1000
     * options.apply_threshold = false; // Value can be set to true or false
     * 
     * printOutcomeArr(predictor.getPredictions(gr, solution, options));
     * @returns Array of predicted outcome objects
     */
    getPredictions(gr: GlideRecord, solution: Object, options: Object): Array<any>;

    /**
     * Identifies if a solution object is a classification type.
     * 
     * @solution Name of the ML solution
     * @example
     * var isClassificationSolution = this.isClassificationSolution(solution);
     * 
     * 	//classification solution each class has different threshold
     * 	//therefore needs to get all the results from ml engine
     * 	if (applyThreshold &amp;&amp; isClassificationSolution) {
     * 		var maxClassificationTopN = 50;
     * 		outcomeArr = solution.predictTopN(gr, maxClassificationTopN);
     * 	}
     * 	else  {
     * 		outcomeArr = solution.predictTopN(gr, topN);
     * 	}
     * 
     * 	if (outcomeArr === null) {
     * 		//instead of returning null returning empty array
     * 		return [];
     * 	}
     * @returns Returns true if the input solution is a classification type, false otherwise
     */
    isClassificationSolution(solution: Object): Boolean;

    /**
     * Identifies if a solution object is a similarity type.
     * 
     * @solution Name of the ML solution; for example, ml_incident_categorization
     * @returns Returns true if the input solution is a similarity type, false otherwise
     */
    isSimilaritySolution(solution: Object): Boolean;

    /**
     * Gets the confidence of the predicted value.
     * 
     * @example
     * var MLP = new MLPredictor();
     *   var solution = MLP.findActiveSolution(solutionName);
     *   var predictedOutcome = solution.predictText(input);
     *   var outcome = predictedOutcome.predictedValue();
     *   var confidence = predictedOutcome.confidence();
     *   gs.info("Predicted value: " + outcome)
     *   gs.info("Confidence: " + confidence)
     * @returns The estimated precision of the prediction as a percentage. For example, 53.84615375762915
     */
    outcome.confidence(): String;

    /**
     * Gets the predicted value from the MLPredictor outcome object.
     * 
     * @example
     * var MLP = new MLPredictor();
     *   var solution = MLP.findActiveSolution(solutionName);
     *   var predictedOutcome = solution.predictText(input);
     *   var outcome = predictedOutcome.predictedValue();
     *   var confidence = predictedOutcome.confidence();
     *   gs.info("Predicted value: " + outcome)
     *   gs.info("Confidence: " + confidence)
     * @returns Predicted value from the Outcome object
     */
    outcome.predictedValue(): String;

    /**
     * Gets the sys_id of the predicted value.
     * 
     * @example
     * function printOutcomeArr(outcomeArr) {
     * gs.print('################## Results ##################');
     * for (var i=0; i&lt;outcomeArr.length; i++) {
     *     var outcome = outcomeArr[i];
     *     gs.print((i+1) + ' : ' + outcome.predictedValue() + ', ' + outcome.predictedValueSysId() + ', ' + outcome.confidence());
     * }
     * @returns Predicted value sys_id
     */
    outcome.predictedValueSysId(): String;

    /**
     * Sets final prediction result values to a specified GlideRecord with an optionally specified reason.
     * 
     * @gr GlideRecord on which to set the final prediction result values
     * @reason Optional reason for applying results
     * @example
     * (function executeRule(current, previous //null when async) {
     * 	var predictor = new MLPredictor();
     * 	predictor.recordFinalValuesInPredictionResults(current, "On close");
     * 
     * })(current, previous);
     */
    recordFinalValuesInPredictionResults(gr: GlideRecord, reason: String);

    /**
     * Gets the capability information of a trained solution.
     * 
     * @returns Definition ID and version of the trained solution, error message otherwise
     */
    solution.getCapability(): String;

    /**
     * Gets the name of the solution used for prediction.
     * 
     * @returns The name of the solution to use for predictions; for example, ml_incident_categorization
     */
    solution.getName(): String;

    /**
     * Gets the predicted value of a solution.
     * 
     * @example
     * // Get a hard-coded GR 
     *      var current = new GlideRecord('incident');
     *      current.get('965c9e5347c12200e0ef563dbb9a7156');
     *      var predictor = new MLPredictor();
     *      var solutions = predictor.findActiveSolutionsForRecord(current);
     *      solutions.forEach(function(solution) {
     *          var outcome = solution.predict(current);
     *          // Use this to set the field to the predicted value in the GlideRecord 
     * 
     *          var fieldName = solution.getPredictedField();
     *          current[fieldName] = outcome.predictedValue();
     *          current.update();
     *          gs.info("Predicted value: " + outcome.predictedValue())
     *          gs.info("Confidence: " + outcome.confidence())
     * });
     * @returns Value of a solution's predicted output field
     */
    solution.getPredictedField(): String;

    /**
     * Gets the solution threshold.The threshold represents a percentage reflecting the minimum prediction accuracy.
     * 
     * @className A specified categorical value of the solution output field
     * @returns Value of the threshold represented as a percentage between 0 and 100
     */
    solution.getThreshold(className: String): Number;

    /**
     * Gets the version of the active solution.
     * 
     * @returns Version of the active solution
     */
    solution.getVersion(): String;

    /**
     * Determines if the specified solution is active.
     * 
     * @returns True if the solution is active, false otherwise
     */
    solution.isActive(): Boolean;

    /**
     * Gets solution prediction results as an Outcome object.
     * 
     * @gr GlideRecord of the solution input table
     * @threshold Threshold value (solution level threshold for similarity, class level threshold for classification)
     * @example
     * var predictor = new MLPredictor();
     *          var solutions = predictor.findActiveSolutionsForRecord(current);
     *          var info = "";
     * solutions.forEach(function(solution) {
     *          var outcome = solution.predict(current);
     *          // Use this to set the field to the predicted value in the GlideRecord
     *          var fieldName = solution.getPredictedField();
     *          current[fieldName] = outcome.predictedValue();
     *          current.update();
     * 
     *          gs.info("Predicted value: " + outcome.predictedValue())
     *          gs.info("Confidence: " + outcome.confidence())
     * });
     * @returns Prediction outcome result of the specified solution (var outcome = solution.predict(gr))
     */
    solution.predict(gr: GlideRecord, threshold: Object): Object;

    /**
     * Returns a list of outcome objects up to the expected number of predictions. Maximum number 1000 predictions.
     * 
     * @gr GlideRecord of the solution
     * @topN Expected number of predictions, any number over 1000 returns 1000 results
     * @example
     * var isClassificationSolution = this.isClassificationSolution(solution);
     * 
     * 	//classification solution each class has different threshold
     * 	//therefore needs to get all the results from ml engine
     * 	if (applyThreshold &amp;&amp; isClassificationSolution) {
     * 		var maxClassificationTopN = 50;
     * 		outcomeArr = solution.predictTopN(gr, maxClassificationTopN);
     * 	}
     * 	else  {
     * 		outcomeArr = solution.predictTopN(gr, topN);
     * 	}
     * 
     * 	if (outcomeArr === null) {
     * 		//instead of returning null returning empty array
     * 		return [];
     * 	}
     * @returns List of outcome objects in an array including GlideRecord, threshold, system ID, and expected number of predictions (topN object)
     */
    solution.predictTopN(gr: GlideRecord, topN: Object): Array<any>;

}

/**
 * Monitors MID servers using the heartbeat probe to check for MID servers that are down, sends heartbeat requests, and kills old heartbeat requests. Use in a server script to monitor MID servers.
 * 
 * 
 */
declare class MonitorMIDServer {



    /**
     * Creates an instance of MonitorMIDServer.
     * 
     */
    constructor();

    /**
     * If there are any heartbeat probe requests that haven't been processed, cancels them so that they don't accumulate when a MID server is down for a while.
     * 
     * @example
     * var mmsv = new MonitorMIDServer();
     * mmsv.killOldRequests();
     */
    killOldRequests();

    /**
     * Marks any non-responding MID servers as being down, by determining when the most recent heartbeat was sent and finding all non-responding servers.
     * 
     * @example
     * var mmsv = new MonitorMIDServer();
     * mmsv.markDowners();
     */
    markDowners();

    /**
     * Performs the functions required for a scheduled MID server monitor cycle, including killing old requests, marking the MID servers that are down, and sending heartbeat requests to all servers.
     * 
     * @example
     * var mmsv = new MonitorMIDServer();
     * mmsv.monitor();
     */
    monitor();

    /**
     * Sends heartbeat requests to all MID servers and notes when by updating the server status record.
     * 
     * @example
     * var mmsv = new MonitorMIDServer();
     * mmsv.sendHeartbeatRequests();
     */
    sendHeartbeatRequests();

}

/**
 * Converts between maps and strings representing the name/value pairs in the map. The string form is: = , = <value, ... where is a string name, optionally surrounded by double quotes (Microsoft-style), and is a string value, also optionally surrounded by double quotes. * * The following are all examples of valid name/value strings: name = value name = "My Value", name = value "My Name = this" = "My Value", "My Value, all the time", name = value "My Name" = "This" "name""", name = value In the third example, the quoted values contain equals and commas. In the fourth example, the quoted value contains a quote. * * Instances have the following properties initialized: map: the map (JavaScript object being used as a hashmap) form of the name/value pairs, with Microsoft-style quotes removed string: the string form of the name/value pairs, with Microsoft-style quoting. * * Use with any server-side script where you need convert name/value pairs between maps and strings.
 * 
 * 
 */
declare class NameValuePairs {



    /**
     * Creates an instance of the class initialized with the specified string.
     * 
     * @stringForm The values to use when creating the object.
     */
    constructor(stringForm: String);

    /**
     * Creates an instance of the class initialized with the specified hash map.
     * 
     * @mapForm The map to use when creating the object.
     */
    constructor(mapForm: Object);

    /**
     * Produces this.string from this.map.
     * 
     */
    mapToString();

    /**
     * If the specified value contains double quotes, equals, commas, or spaces, this method surrounds the value with double quotes and doubles up any enclosed double quotes.
     * 
     * @value The value to process
     * @returns The value with added quotes.
     */
    quotify(value: Object): String;

    /**
     * Produces this.map from this.string.
     * 
     */
    stringToMap();

}

/**
 * Implements an SNMP handler for Netware OS. This handler is designed to be invoked by Classify.java as an interim step toward completely moving the SNMP sensors into JavaScript. * * Use this API for SNMP classification.
 * 
 * 
 */
declare class NetwareHandler API {



    /**
     * Classifies and identifies the SNMP device.
     * 
     */
    classifyAndIdentify();

}

/**
 * The Notify API allows you to interact with Notify calls and SMS messages using scripts. Access the global Notify class and its associated methods in the SNC namespace.
 * 
 * 
 */
declare class Notify {



    /**
     * Calls the specified E.164-compliant telephone number.In addition, this method can automatically add the specified phone number to a specified conference call.
     * 
     * @notifyPhoneNumber Notify phone number from which to make the call. When you initiate a call, the outgoing call workflow for the number group associated with this number runs. Ensure this workflow includes a join conference call activity to connect the user to the conference call.
     * @toPhoneNumber Phone number to call. Called numbers are added to the conference call.
     * @conferenceCall Optional. If this parameter is passed in, the callers identified in the toPhoneNumber parameter are automatically joined into the conference call identified by this record. GlideRecord for the Notify Call [notify_call] table that identifies the conference call record. This record is automatically added to the outgoing call workflow scratchpad as the workflow.scratchpad.conference_call variable.
     * @userSysId Optional. Unique identifier (sys_id) of the user associated with the call.
     * @groupSysId Optional. Unique identifier (sys_id) of the group associated with the call.
     * @sourceRecord Optional. Source record that prompted this call.
     * @example
     * var from = '+14048007337';
     * var to = '+31646810495';
     * 
     * // set up call
     * new SNC.Notify().call(from, to);
     * @example
     * var notify = new SNC.Notify();
     * var from = '+14041234567';
     * var participants = ['+31612345678', '+31623456789', '+31687654321'];
     * 
     * // set up a conference call
     * var conferenceCall = notify.conferenceCall();
     * 
     * // set up the outbound calls for all conference call participants
     * for (var i in participants) {
     *     var to = participants[i];
     *     notify.call(from, to, conferenceCall);
     * }
     * @example
     * SNC.Notify.call('+15413970605', '+91406XXXXXXX', SNC.Notify.conferenceCall(), null, null, null);
     * @example
     * var sysUserGr = new GlideRecord('sys_user');
     * sysUserGr.get('active conference sys id');
     *  
     * if (conferenceGr.isValid) {
     *     SNC.Notify.call('+15413970605', '+91406XXXXXXX', SNC.Notify.conferenceCall(), sysUserGr.getUniqueValue(), null, null);
     * }
     * @example
     * var sysUserGr = new GlideRecord('sys_user');
     * sysUserGr.get('active sys user sys id');
     *  
     * var sysUserGroupGr = new GlideRecord('sys_user_group');
     * sysUserGroupGr.get('active sys user group sys id');
     *  
     * var incidentGr = new GlideRecord('incident');
     * incidentGr.get('incident sys_id');
     *  
     * if (conferenceGr.isValid) {
     *     SNC.Notify.call('+15413970605', '+91406XXXXXXX',
     *         SNC.Notify.conferenceCall(),
     *         sysUserGr.getUniqueValue(),
     *         sysUserGroupGr.getUniqueValue(),
     *         incidentGr.getUniqueValue());
     * }
     */
    call(notifyPhoneNumber: StringorNotifyPhoneNumber, toPhoneNumber: String, conferenceCall: GlideRecord, userSysId: String, groupSysId: String, sourceRecord: GlideRecord);

    /**
     * Creates a new conference call GlideRecord.
     * 
     * @sourceRecord Optional. Record that initiated the request to create the conference call. Used to populate the source and table fields on notify_conference_call record.
     * @example
     * var notify = new SNC.Notify();
     * var from = '+14041234567';
     * var participants = ['+31612345678', '+31623456789', '+31687654321'];
     * 
     * // set up a conference call
     * var conferenceCall = notify.conferenceCall();
     * 
     * // set up the outbound calls for all conference call participants
     * for (var i in participants) {
     *     var to = participants[i];
     *     notify.call(from, to, conferenceCall);
     * }
     * @returns New Notify conference call [notify_conference_call] record.
     */
    conferenceCall(sourceRecord: GlideRecord): GlideRecord;

    /**
     * Resumes a call after it was put in a queue (on hold).Use this method to resume calls that were put in a queue with the queueCall() method.
     * 
     * @callRecord A GlideRecord object on the Notify Call [notify_call] table with the held call you want to resume.
     * @example
     * var notifyCallGr = new GlideRecord('notify_call');
     * notifyCallGr.get('active participant sys id');
     *  
     * if (notifyCallGr.isValid) {
     *     SNC.Notify.dequeueCall(notifyCallGr);
     * }
     */
    dequeueCall(callRecord: GlideRecord);

    /**
     * Forwards the specified call to a different call recipient.
     * 
     * @call Notify call record or the telephony provider call ID, of the call to be forwarded.
     * @destination Notify phone number record or an E.164-compliant phone number, of the caller to which to forward the call.
     * @dtmf Dual Tone - Multi Frequency (DTMF) code to send upon call connection.
     * @example
     * var callID = 'CA92374b5aa561dab476a7001db6026edc'; // Twilio Call ID
     * var phoneNumber = '+91406xxxxxxx';
     * var dtmfTones = null;
     *  
     * var notifyCallGr = new GlideRecord('notify_call');
     * notifyCallGr.get('active participant sys id');
     *  
     * if (notifyCallGr.isValid) {
     *     SNC.Notify.forwardCall(notifyCallGr(or) callID, phoneNumber, dtmfTones)
     * }
     */
    forwardCall(call: GlideRecordorString, destination: GlideRecordorString, dtmf: String);

    /**
     * Returns a list of client sessions that are available to receive calls.
     * 
     * @notifyNumber Valid Notify phone number.
     * @example
     * var clientSessionGr = SNC.Notify.getAvailableClients('+185xxxxxxxx'); 
     * // Here clientSessionGr is of type GlideRecord on 'notify_client_session' table.
     *  
     * var isLoggedInUserAvailable = false;
     * while (clientSessionGr.next()) {
     *   if (clientSessionGr.user == gs.getUserID())
     *     isLoggedInUserAvailable = clientSessionGr.available;
     * }
     * gs.info('isLoggedInUserAvailable - ' + isLoggedInUserAvailable);
     * @returns GlideRecord from the notify_client_session table for the specified phone number. Returns "0" if there are no available client sessions.
     */
    getAvailableClients(notifyNumber: String): GlideRecord;

    /**
     * Returns the sys_id of a specified call's parent call.Any call started by forwarding another call, such as with the Forward workflow activity, is considered a child of the original call. The original call is the parent call.
     * 
     * @callRecord Record on the Notify Call [notify_call] table for which to return the call status.
     * @example
     * var callRecord = new GlideRecord('notify_call');
     * callRecord.get("0f4f5863ff13310014ecffffffffff28");
     * 
     * var notify = new SNC.Notify();
     * var parentCallID = notify.getParentCallID(callRecord);
     * @returns Unique sys_id of the parent call record.
     */
    getParentCallID(callRecord: GlideRecord): String;

    /**
     * Returns all phone numbers and short codes available to Notify.
     * 
     * @example
     * var list = SNC.Notify.getPhoneNumbers();
     * for (var i = 0; i &lt; list.size(); i++) {
     *     var num = list.get(i);
     *     gs.info(num.getNumber())
     * }
     * @returns List of NotifyPhoneNumber objects, each object representing one phone number available to Notify.
     */
    getPhoneNumbers(): List;

    /**
     * Returns client tokens for any active telephony drivers for use in WebRTC or mobile clients.
     * 
     * @record GlideRecord to use to identify the Notify client, such as a group record or a user record.
     * @example
     * // get Notify client Tokens per active Notify driver for the currently logged in user
     * var json = new SNC.Notify().getTokens();
     *  
     * // Parse the JSON that was return into a tokens object
     * var tokens = JSON.parse(json);
     * 
     * // Log line
     * gs.log('Notify client tokens for the currently logged in user');
     * 
     *  // iterate over the driver tokens
     * for (var driver in tokens) {
     *  	gs.log(driver + ' Driver token: ' + tokens[driver]);
     * }
     * @example
     * // instantiate Notify
     * var notify = new SNC.Notify();
     *  
     * // get all Notify Groups
     * var notifyGroup = new GlideRecord("notify_group");
     * notifyGroup.query();
     *  
     * // iterate over all notify groups
     * while (notifyGroup.next()) {
     *   // generate Notify Client tokens per active Notify Driver for this group
     *   var json = notify.getTokens(notifyGroup);
     *   var tokens = JSON.parse(json);
     *  
     *   for (var driver in tokens) {
     *     gs.log(gs.getMessage("Notify Client token for {0} driver and Notify Group '{1}': {2}", [driver, notifyGroup.getValue('name'), tokens[driver]]));
     *   }
     * }
     * @returns Web RTC tokens for the supported drivers, as a JSON string with the following format: {driverName1: “token1”, driverName2: “token2”}, such as "TwilioDirect":"eyJhxxxx.eyJleHAiOiIxxxx.7fejxxx_mbLxxx"
     */
    getTokens(record: GlideRecord): String;

    /**
     * Returns the maximum amount of time that a client session stays active for a specified telephony driver before automatically timing out.
     * 
     * @owner Name of the telephony driver for which to retrieve the session length. Valid values: Twilio: for the old driver TwilioDirect: for the new driver 
     * @example
     * var owner = "TwilioDirect";  // Valid driver
     * var ttl = SNC.Notify.getTokenTTL(owner);
     * gs.info("Token TTL for " + owner + " --&gt; " + ttl);
     *  
     * owner = "Abcxyz";  // Invalid driver
     * ttl = SNC.Notify.getTokenTTL(owner);
     * // For an invalid driver, we throw NoSuchNotifyDriverException saying that Abcxyzdriver is not available
     * // and return the default value of TTL
     * gs.info("Token TTL for " + owner + " --&gt; " + ttl); 
     * @returns Maximum length of the session (in seconds). Default: 1800 seconds
     */
    getTokenTTL(owner: String): Integer;

    /**
     * Determines whether the specified phone number has the specified capability.The telephony driver associated with the phone number contains a list of all of the capabilities of the phone.Note: In the base system, the Notify JS driver only has 'show_speakers' as a capability; this can be modified.
     * 
     * @notifyPhoneNumber Phone number for which to check for the specified capability.
     * @capability Capability to detect. The string text must be an exact match to what is in the phone.
     * @example
     * // Each driver has a defined set of capabilities.
     * 
     * var capability = 'show_speakers';
     * gs.info(SNC.Notify.hasCapability('+185xxxxxxxx', capability)); // true
     *  
     * capability = 'send_sms';
     * gs.info(SNC.Notify.hasCapability('+185xxxxxxxx', capability)); // false
     * @returns Flag that indicates whether the specified phone has the specified capability. true: phone has the capability false: phone does not have the capability 
     */
    hasCapability(notifyPhoneNumber: String, capability: String): Boolean;

    /**
     * Removes the specified caller from the current Notify conference call.
     * 
     * @participant GlideRecord object containing the Notify Participant [notify_participant] record of the caller to remove from the conference call.
     * @example
     * var notifyParticipantGr = new GlideRecord('notify_participant');
     * notifyParticipantGr.get('active participant sys id');
     *  
     * if (notifyParticipantGr.isValid) {
     *     SNC.Notify.kick(notifyParticipantGr);
     * }
     */
    kick(participant: GlideRecord);

    /**
     * Performs one or more actions on an active Notify phone call.Available actions that you can perform on calls include queuing or dequeueing the call, reading text, playing audio, or forwarding the call. You can also create custom actions Call the modifyCall() method after you have specified all the actions that you want to apply to the specified call. Refer to the NotifyAction API documentation for more information about available actions.
     * 
     * @callRecord Notify Call [notify_call] record of the call for which to apply the actions.
     * @notifyAction NotifyAction object describing one or more actions to perform on the call. Create this object by calling one or more of the NotifyAction() methods.
     * @example
     * // get the most recent call record
     * var callRecord = new GlideRecord('notify_call');
     * callRecord.orderByDesc('sys_created_on');
     * callRecord.query();
     *  
     * if (callRecord.next()) {
     *     // instantiate notify action container class
     *     var notifyAction = new SNC.NotifyAction();
     *     // The call is already in progress. Now, we want to modify the call behavior by putting this call in a queue.
     *     // So, we add a queue action to queue the call
     *     notifyAction.addQueue('my fancy queue');
     *    
     *     // modify the call by passing in the above action, putting the call in a queue
     *     new SNC.Notify().modifyCall(callRecord, notifyAction);
     * } else {
     *     gs.log('no such call record');
     * }
     */
    modifyCall(callRecord: GlideRecord, notifyAction: NotifyAction);

    /**
     * Mutes the specified conference call participant.
     * 
     * @participantRecord GlideRecord from the notify_participant table for the participant to mute.
     * @example
     * var notifyParticipantGr = new GlideRecord('notify_participant');
     * notifyParticipantGr.get('active participant sys id');
     *  
     * if (notifyParticipantGr.isValid) {
     *     SNC.Notify.mute(notifyParticipantGr);
     * }
     */
    mute(participantRecord: GlideRecord);

    /**
     * Puts the specified call into a queue (on hold).Resume a queued call using the dequeueCall() method.
     * 
     * @callRecord GlideRecord object of the Notify Call record (notify_call table) to put on hold.
     * @example
     * var notifyCallGr = new GlideRecord('notify_call');
     * notifyCallGr.get('active participant sys id');
     *  
     * if (notifyCallGr.isValid) {
     *     SNC.Notify.queueCall(notifyCallGr);
     * }
     */
    queueCall(callRecord: GlideRecord);

    /**
     * Sends a specified SMS message to the specified list of Notify clients (phone numbers).
     * 
     * @notifyPhoneNumber Phone number from which the SMS message is being sent.
     * @toPhoneNumbers Comma separated list of E.164-compliant phone numbers to which to send the SMS message.
     * @messageBody SMS text to send.
     * @source Source record that prompted this SMS message, such as an incident.
     * @example
     * var incidentGr = new GlideRecord('incident');
     * incidentGr.get(active incident sys_id');
     * if (incidentGr.isValid()) {
     *     SNC.Notify.sendBulkSMS('+15413970605', ['+919885XXXXXX', '+919775XXXXXX'], 'Test automation message', incidentGr);
     * }
     * @returns Unique sys_id of the Notify Message [notify_message] record created by this function.
     */
    sendBulkSMS(notifyPhoneNumber: NotifyPhoneNumber, toPhoneNumbers: String, messageBody: String, source: GlideRecord): String;

    /**
     * Sends an SMS text message to an E.164-compliant phone number.This method creates a new record on the Notify Message [notify_message] table and associates it with the source record.
     * 
     * @notifyPhoneNumber Notify phone number or short code to which to send this SMS message.
     * @toPhoneNumber E.164-compliant phone number to which to send the SMS message.
     * @messageBody Body of the SMS text message.
     * @source Source record that prompted this SMS message, such as an incident.
     * @example
     * var incidentGr = new GlideRecord('incident');
     * incidentGr.get(active incident sys_id');
     * if (incidentGr.isValid()) {
     *     SNC.Notify.sendSMS('+15413970605', '+919885XXXXXX', 'Test automation message', incidentGr);
     * }
     * @returns Unique message SID; stored in the Notify Message [notify_message] record as message_id.
     */
    sendSMS(notifyPhoneNumber: NotifyPhoneNumber, toPhoneNumber: String, messageBody: String, source: GlideRecord): String;

    /**
     * Unmutes the specified conference call participant.
     * 
     * @participantRecord GlideRecord from the notify_participant table for the participant to unmute.
     * @example
     * var notifyParticipantGr = new GlideRecord('notify_participant');
     * notifyParticipantGr.get('active participant sys id');
     *  
     * if (notifyParticipantGr.isValid) {
     *     SNC.Notify.unmute(notifyParticipantGr);
     * }
     */
    unmute(participantRecord: GlideRecord);

}

/**
 * The NotifyAction API allows you to define actions to send to a telephony provider. You add actions to a NotifyAction object by calling the respective add function for each type of action. Each add function returns an Action object, such as a SayAction object for the addSay() function. Refer to each method example for information about returned objects. * * Note: The NotifyAction API is only valid within global applications. To utilize this type of functionality within scoped applications, you must create custom Notify workflow activities. For additional information on creating these activities, see Notify workflow activities.
 * 
 * 
 */
declare class NotifyAction {



    /**
     * Adds a conference action to move the current call into the current conference call.
     * 
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // add a conference call action and set its name
     * var conference = notifyAction.addConference();
     * conference.setName('Brown Bag: Week 3');
     * @returns Action added to the NotifyAction object. Use the ConferenceAction object to define the conference call name, and the behavior of the conference call when a participant joins or leaves.
     */
    addConference(): ConferenceAction;

    /**
     * Defines whether the conference call should end when a specified caller exits the conference call.
     * 
     * @endOnExit Flag that indicates whether the conference call should end when the specified caller exits the current conference call. true: end the conference call when the specified caller exits the conference call false: Default. End the conference call once all participants exit 
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // add a conference call action and set the caller that starts the meeting
     * var conference = notifyAction.addConference();
     * 
     * // retrieve the participant for which the conference call should exit when they leave
     * var notifyParticipantGr = new GlideRecord('notify_participant');
     * notifyParticipantGr.get('active participant sys id');
     *  
     * if (notifyParticipantGr.isValid) {
     * conference.setEndOnExit(true);
     * }
     */
    addConference.setEndOnExit(endOnExit: Boolean);

    /**
     * Defines whether the conference call should end when a participant presses the star (*) key.
     * 
     * @hangupOnStart Flag that indicates whether the conference call should end when a participant presses the star (*) key.Valid values: true: end the conference call false: Default. Don't end the conference call 
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // add a conference call action and set the hang up action
     * var conference = notifyAction.addConference();
     * conference.setHangupOnStar(true);
     */
    addConference.setHangupOnStar(hangupOnStart: Boolean);

    /**
     * Defines whether the specified caller should be muted in the current conference call.
     * 
     * @muted Flag that indicates whether the specified caller should be muted in the current conference call. true: caller should be muted false: Default. Caller should not be muted 
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // add a conference call action and set it to mute the specified participant
     * var conference = notifyAction.addConference();
     * 
     * var notifyParticipantGr = new GlideRecord('notify_participant');
     * notifyParticipantGr.get('active participant sys id');
     *  
     * if (notifyParticipantGr.isValid) {
     * conference.setMuted(true);
     * }
     */
    addConference.setMuted(muted: Boolean);

    /**
     * Sets the name of the current conference call to the specified name.
     * 
     * @name Name to associate with the current conference call.
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // add a conference call action and set its name
     * var conference = notifyAction.addConference();
     * 
     * conference.setName('Brown Bag: Week 3');
     */
    addConference.setName(name: String);

    /**
     * Defines whether the associated conference call should be recorded.
     * 
     * @record Flag that indicates whether the current conference call should be recorded. true: start recording the conference call false: Default. Conference call is not recorded. Recording is stopped if it is currently being recorded. 
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // add a conference call action and set it to be recorded
     * var conference = notifyAction.addConference();
     * conference.setRecord(true);
     */
    addConference.setRecord(record: Boolean);

    /**
     * Defines whether the conference call should start when the specified caller joins the conference call.
     * 
     * @startOnEnter Flag that indicates whether the conference call should start when the selected caller joins the current conference call. true: Default. Start the conference call when the specified caller joins the conference call. false: start the conference call once it is added 
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // add a conference call action and set the caller that starts the meeting
     * var conference = notifyAction.addConference();
     * 
     * // retrieve the participant for which the conference call should start when they arrive
     * var notifyParticipantGr = new GlideRecord('notify_participant');
     * notifyParticipantGr.get('active participant sys id');
     *  
     * if (notifyParticipantGr.isValid) {
     * conference.setStartOnEnter(true);
     * }
     */
    addConference.setStartOnEnter(startOnEnter: Boolean);

    /**
     * Forwards a call to a specified phone number or Notify Client.
     * 
     * @example
     * // Initialize NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     *  
     * // Call addDial() to connect to another party – this returns an object of type DialAction
     * var dialAction = notifyAction.addDial();
     *  
     * // Call setPhoneNumber(String phoneNumber)in DialAction.java to specify the phone number to dial
     * dialAction.setPhoneNumber('+919765xxxxxxx');
     *  
     * // Invoke setRecord(Boolean record) to record the call to this new number +919765xxxxxxx
     * dialAction.setRecord(true);
     * @returns Action added to the NotifyAction object.
     */
    addDial(): DialAction;

    /**
     * Defines the caller ID for the outgoing call.
     * 
     * @callerID Caller identifier to set for the outgoing call.
     * @example
     * // Initialize NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     *  
     * // Call addDial() to connect to another party – this returns an object of type DialAction
     * var dialAction = notifyAction.addDial();
     *  
     * // Call setPhoneNumber(String phoneNumber)in DialAction.java to specify the phone number to dial
     * dialAction.setPhoneNumber('+919765xxxxxxx');
     *  
     * // Set the caller ID
     * dialAction.setCallerID('Planning Conf Call');
     */
    addDial.setCallerID(callerID: String);

    /**
     * Sets the current caller to a Notify caller by specifying the table in which to find the Notify caller record and the caller's unique identifier.
     * 
     * @tableName Name of the table that contains the desired caller's information.
     * @sysID Unique identifier (sys_id) of the desired Notify caller.
     * @example
     * // set up a dial action to forward the
     * // call to the specified client
     * var action = new SNC.NotifyAction();
     * var dial = action.addDial();
     * dial.setClientRecord(notifyClientRecord.getTableName(), notifyClientRecord.getUniqueValue());
     * dial.setTimeout(activity.vars.timeout);
     * dial.setRecord(activity.vars.record);
     */
    addDial.setClientRecord(tableName: String, sysID: String);

    /**
     * Defines the DTMF tones to play when the call connects.
     * 
     * @value Valid DTMF digits to play when the call connects.
     * @example
     * // Initialize NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     *  
     * // Call addDial() to connect to another party - this returns an object of type DialAction
     * var dialAction = notifyAction.addDial();
     *  
     * // Call setPhoneNumber(String phoneNumber)in DialAction.java to specify the phone number to dial
     * dialAction.setPhoneNumber('+919765xxxxxxx');
     *  
     * // DTMF tones to play when call connects
     * dialAction.setDTMF("1246AF");
     */
    addDial.setDTMF(value: String);

    /**
     * Defines whether the call should end when the star (*) key is pressed.
     * 
     * @hangupOnStar Flag that indicates whether the call should end when the star (*) key is pressed. true: end the call false: don't end the call 
     * @example
     * // Initialize NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     *  
     * // Call addDial() to connect to another party – this returns an object of type DialAction
     * var dialAction = notifyAction.addDial();
     *  
     * // Call setPhoneNumber(String phoneNumber)in DialAction.java to specify the phone number to dial
     * dialAction.setPhoneNumber('+919765xxxxxxx');
     *  
     * // End call by pressing star
     * dialAction.setHangupOnStar(true);
     */
    addDial.setHangupOnStar(hangupOnStar: Boolean);

    /**
     * Defines the phone number to call.
     * 
     * @phoneNumber E.164-compliant phone number to call.
     * @example
     * // Initialize NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     *  
     * // Call addDial() to connect to another party – this returns an object of type DialAction
     * var dialAction = notifyAction.addDial();
     *  
     * // Call setPhoneNumber(String phoneNumber)in DialAction.java to specify the phone number to dial
     * dialAction.setPhoneNumber('+919765xxxxxxx');
     * 
     */
    addDial.setPhoneNumber(phoneNumber: String);

    /**
     * Defines whether the outgoing call should be recorded.
     * 
     * @record Flag that indicates whether the outgoing call should be recorded.Valid values: true: record the outgoing call false: do not record the outgoing call 
     * @example
     * // Initialize NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     *  
     * // Call addDial() to connect to another party – this returns an object of type DialAction
     * var dialAction = notifyAction.addDial();
     *  
     * // Call setPhoneNumber(String phoneNumber)in DialAction.java to specify the phone number to dial
     * dialAction.setPhoneNumber('+919765xxxxxxx');
     *  
     * // Record the call
     * dialAction.setRecord(true);
     */
    addDial.setRecord(record: );

    /**
     * Sets the number of seconds after which the outgoing call times out.
     * 
     * @timeout Number of seconds after which the outgoing call times out. Default: 30
     * @example
     * // Initialize NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     *  
     * // Call addDial() to connect to another party – this returns an object of type DialAction
     * var dialAction = notifyAction.addDial();
     *  
     * // Call setPhoneNumber(String phoneNumber)in DialAction.java to specify the phone number to dial
     * dialAction.setPhoneNumber('+919765xxxxxxx');
     *  
     * // Set the number of seconds to wait before timing out
     * dialAction.setTimeout(45);
     */
    addDial.setTimeout(timeout: Integer);

    /**
     * Presents a specified interactive phone menu to the caller.
     * 
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // present the user with a menu
     * var gather = notifyAction.addGather();
     * gather.setNumberOfDigits(1);    // the user can type 1 digit
     * gather.setFinishKey('#');       // # or *, useful for &gt; 1 digit
     * gather.setTimeout(10);          // time to enter answer, in seconds
     * 
     * // add first menu item
     * var usSay = gather.addSay();
     * usSay.setText('Press 1 for english');
     * usSay.setLanguage('en-US');
     * 
     * // add second menu item
     * var nlSay = gather.addSay();
     * nlSay.setText('Kies 2 voor Nederlands');
     * nlSay.setLanguage('nl-NL');
     * 
     * // add third menu item
     * var frSay = gather.addSay();
     * frSay.setText('Choisissez 3 pour le français.');
     * frSay.setLanguage('fr-FR');
     * 
     * // and finish off with an applause
     * var play = gather.addPlay();
     * play.setURL('http://www.wavsource.com/snds_2015-04-12_5971820382841326/sfx/applause_y.wav');
     * @returns Action added to the NotifyAction object. Use the GatherAction object to define the menu settings and options to present to the user.
     */
    addGather(): GatherAction;

    /**
     * Plays an audio file on the call.
     * 
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // Create the gather action object
     * var gather = notifyAction.addGather();
     * 
     * // Play an audio file
     * var play = gather.addPlay();
     * play.setURL('http://www.wavsource.com/snds_2015-04-12_5971820382841326/sfx/applause_y.wav');
     * @returns Action added to the NotifyAction object. Use the PlayAction object to define the audio file URL and the number of times to loop the audio.
     */
    addGather.addPlay(): PlayAction;

    /**
     * Defines the text-to-speech to read on the call.
     * 
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // present the user with a menu
     * var gather = notifyAction.addGather();
     * gather.setNumberOfDigits(1);    // the user can type 1 digit
     * gather.setTimeout(20);          // time to enter answer, in seconds
     * 
     * // add first menu item
     * var gatherSay = gather.addSay();
     * gatherSay.setText('Press 1 for english');
     * gatherSay.setLanguage('en-US');
     * 
     * @returns Action added to the NotifyAction object. Use the SayAction object to define the text and language to read.
     */
    addGather.addSay(): SayAction;

    /**
     * Defines the key that the caller inputs to denote the end of their input.
     * 
     * @finishKey Key that denotes the end of caller input.Valid values: 0-9 # (default) * 
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * var gather = notifyAction.addGather();
     * gather.setNumberOfDigits(4);    // the user can type four digit
     * gather.setFinishKey('#');       // # or *, useful for &gt; 1 digit
     */
    addGather.setFinishKey(finishKey: String);

    /**
     * Defines the number of digits to collect.
     * 
     * @numberOfDigits Number of digits to collect. Zero is an invalid value.
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // present the user with a menu
     * var gather = notifyAction.addGather();
     * gather.setNumberOfDigits(4);    // the user can type four digit
     * gather.setFinishKey('#');       // # or *, useful for &gt; 1 digits
     * gather.setTimeout(20);          // time to enter answer, in seconds
     * 
     */
    addGather.setNumberOfDigits(numberOfDigits: Integer);

    /**
     * Defines the amount of time after which gathering of input will timeout.
     * 
     * @timeout Number of seconds to wait for caller input before timing out. Default: 10
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // present the user with a menu
     * var gather = notifyAction.addGather();
     * gather.setNumberOfDigits(4);    // the user can type 1 digit
     * gather.setFinishKey('#');       // # or *, useful for &gt; 1 digits
     * gather.setTimeout(20);          // time to enter answer, in seconds
     * 
     */
    addGather.setTimeout(timeout: Integer);

    /**
     * Ends an active phone call.
     * 
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // hang up
     * notifyAction.addHangUp();
     * @returns Action added to the NotifyAction object.
     */
    addHangUp(): HangUpAction;

    /**
     * Plays an audio file on the call.
     * 
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // add a play action
     * var play = notifyAction.addPlay();
     * play.setURL('http://www.moviesounds.com/2001/imsorry.wav');
     * play.setLoop(1);
     * @returns Action added to the NotifyAction object. Use the PlayAction object to define the audio file URL and number of times to loop the audio.
     */
    addPlay(): PlayAction;

    /**
     * Defines the number of times to play (loop through) the audio file.
     * 
     * @loop Number of times to play the audio file.
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // add a play action
     * var play = notifyAction.addPlay();
     * play.setURL('http://www.moviesounds.com/2001/imsorry.wav');
     * play.setLoop(2);
     */
    addPlay.setLoop(loop: Integer);

    /**
     * Defines the URL where to obtain the audio file to play.
     * 
     * @url URL of the audio file to play.
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // add a play action
     * var play = notifyAction.addPlay();
     * play.setURL('http://www.moviesounds.com/2001/imsorry.wav');
     * play.setLoop(1);
     */
    addPlay.setURL(url: String);

    /**
     * Queues the call, which puts the call on hold.
     * 
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // queue the call
     * var queue = notifyAction.addQueue();
     * queue.setName('my queue');
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // dequeue the call
     * var queue = notifyAction.addQueue();
     * queue.setDequeue(true);
     * @returns Action added to the NotifyAction object. Use the QueueAction object to define the queue name, and queueing or dequeueing behavior.
     */
    addQueue(): QueueAction;

    /**
     * Removes the call from the current call queue (takes it off of "hold").
     * 
     * @dequeue Flag that indicates whether to remove the current call from the queue. true: remove the call from the queue false: call is put in the queue 
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // dequeue the call
     * var queue = notifyAction.addQueue();
     * queue.setDequeue(true);
     */
    addQueue.setDequeue(dequeue: Boolean);

    /**
     * Defines the name associated with a queue.
     * 
     * @name Name to associate with the queue.
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // queue the call
     * var queue = notifyAction.addQueue();
     * queue.setName('my queue');
     */
    addQueue.setName(name: String);

    /**
     * Adds an action to record the call to the current NotifyAction object.
     * 
     * @example
     * // First we initialize NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     *  
     * // Call addRecord() of NotifyAction – This returns an object of type RecordAction
     * var recordAction = notifyAction.addRecord();
     *  
     * // Optional. Define the key that callers use to stop the recording
     * recordAction.setFinishKey('#'); // Stop the call recording when caller presses the '#' key.
     */
    addRecord();

    /**
     * Defines the key that terminates the recording.
     * 
     * @finishKey Key that terminates the recording.Valid values: 0-9 # (default) * 
     * @example
     * // First we initialize NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     *  
     * // Then we call addRecord() of NotifyAction 
     * var recordAction = notifyAction.addRecord();
     *  
     * // Set the key that terminates the recording
     * recordAction.setFinishKey('#'); // This means that we stop the call recording when user presses the '#' key.
     */
    addRecord.setFinishKey(finishKey: String);

    /**
     * Defines the maximum length of the recording.
     * 
     * @seconds Maximum length of the recording in seconds. Default: 3600
     * @example
     * // First we initialize NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     *  
     * // Then we call addRecord() of NotifyAction 
     * var recordAction = notifyAction.addRecord();
     *  
     * // Set the maximum length of the recording
     * recordAction.setMaxDuration(4800); 
     */
    addRecord.setMaxDuration(seconds: Integer);

    /**
     * Sets the number of seconds of silence, after which, the recording ends.
     * 
     * @timeout Number of seconds of silence on the call, after which the recording ends. Default: 10
     * @example
     * // First we initialize NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     *  
     * // Then we call addRecord() of NotifyAction 
     * var recordAction = notifyAction.addRecord();
     *  
     * // Set the recoding timeout value
     * recordAction.setTimeout(360); 
     */
    addRecord.setTimeout(timeout: Integer);

    /**
     * Rejects an incoming call.
     * 
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // reject the call
     * var rejectAction = notifyAction.addReject();
     * rejectAction.setReason('busy'); // 'busy' or 'rejected'
     * @returns Action added to the NotifyAction object. Use the RejectAction object to define the reason for rejecting the call.
     */
    addReject(): RejectAction;

    /**
     * Defines the text-to-speech to read on the call.Multiple languages are supported with text-to-speech. Available languages depend on the telephony provider.
     * 
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // add a say action to say something in US English
     * var usSay = notifyAction.addSay();
     * usSay.setText('Welcome. I can speak english');
     * usSay.setLanguage('en-US');
     * 
     * // add a say action to say something in Dutch
     * var nlSay = notifyAction.addSay();
     * nlSay.setText('Ik spreek ook vloeiend nederlands');
     * nlSay.setLanguage('nl-NL');
     * 
     * // and german
     * var deSay = notifyAction.addSay();
     * deSay.setText('Und ich kan auch deutsch sprechen');
     * deSay.setLanguage('de-DE');
     * @returns Action added to the NotifyAction object. Use the SayAction object to define the text and language to read.
     */
    addSay(): SayAction;

    /**
     * Defines the language in which to speak the text.
     * 
     * @language ISO 3166 language code that defines the language in which to speak the associated text. For example, "en-US" or "nl-NL".
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // add a say action to say something in US English
     * var usSay = notifyAction.addSay();
     * usSay.setText('Welcome. I can speak english');
     * usSay.setLanguage('en-US');
     * 
     * // add a say action to say something in Dutch
     * var nlSay = notifyAction.addSay();
     * nlSay.setText('Ik spreek ook vloeiend nederlands');
     * nlSay.setLanguage('nl-NL');
     * 
     * // and german
     * var deSay = notifyAction.addSay();
     * deSay.setText('Und ich kan auch deutsch sprechen');
     * deSay.setLanguage('de-DE');
     */
    addSay.setLanguage(language: String);

    /**
     * Defines the text to be read within the current call.
     * 
     * @text Text to read aloud within the current call.
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // add a say action to say something in US English
     * var usSay = notifyAction.addSay();
     * usSay.setText('Welcome. I can speak english');
     * usSay.setLanguage('en-US');
     * 
     * // add a say action to say something in Dutch
     * var nlSay = notifyAction.addSay();
     * nlSay.setText('Ik spreek ook vloeiend nederlands');
     * nlSay.setLanguage('nl-NL');
     * 
     * // and german
     * var deSay = notifyAction.addSay();
     * deSay.setText('Und ich kan auch deutsch sprechen');
     * deSay.setLanguage('de-DE');
     */
    addSay.setText(text: String);

    /**
     * Sends an SMS message.
     * 
     * @example
     * // Instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // Define where to send the SMS to
     * var number = new GlideElementPhoneNumber();
     * number.setPhoneNumber('+31612345678', true);
     * 
     * // Add an SMS action
     * var sms = notifyAction.addSMS();
     * sms.setMessage('Lorem ipsum dolor sit amet, consectetur adipiscing elit.');
     * sms.setTo(number);
     * @returns Action added to the NotifyAction object. Use the SMSAction object to define the message text and the phone number to which to send the message.
     */
    addSMS(): SMSAction;

    /**
     * Defines the text of the SMS message to send.
     * 
     * @message Text of the SMS message to send.
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // define where to send the sms to
     * var number = new GlideElementPhoneNumber();
     * number.setPhoneNumber('+31612345678', true);
     * 
     * // add a SMS action
     * var sms = notifyAction.addSMS();
     * sms.setMessage('Lorem ipsum dolor sit amet, consectetur adipiscing elit.');
     * sms.setTo(number);
     */
    addSMS.setMessage(message: String);

    /**
     * Sets the phone number to which to sent the SMS message.
     * 
     * @to E.164-compliant phone number to which to send the SMS message.
     * @example
     * // instantiate NotifyAction
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // define where to send the sms to
     * var number = new GlideElementPhoneNumber();
     * number.setPhoneNumber('+31612345678', true);
     * 
     * // add a SMS action
     * var sms = notifyAction.addSMS();
     * sms.setMessage('Lorem ipsum dolor sit amet, consectetur adipiscing elit.');
     * sms.setTo(number);
     */
    addSMS.setTo(to: String);

    /**
     * Appends the specified NotifyAction object to the current client's NotifyAction object.
     * 
     * @action NotifyAction object to append to the NotifyAction object of the current caller.
     */
    append(action: NotifyAction);

    /**
     * Deserialize a NotifyAction object from a JSON string.
     * 
     * @json A JSON string representation of a NotifyAction object.
     * @example
     * var json = ".... some json obtained from toJson ....";
     * 
     * // instantiate notify action
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // deserialize and reconstruct the notify action instance
     * notifyAction.fromJson(json);
     * @example
     * // instantiate notify action
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // add a queue
     * var queue = notifyAction.addQueue();
     * queue.setName('myQueueName');
     * queue.setDequeue(false);
     * 
     * // serialize to json
     * var json = notifyAction.toJson();
     * gs.log('serialization result: ' + json);
     * 
     * // instantiate a new notify action
     * var newAction = new SNC.NotifyAction();
     * 
     * // deserialize the json generated above
     * newAction.fromJson(json);
     * 
     * // serialize the new object and log the result
     * newJson = newAction.toJson();
     * gs.log('new serialization result: ' + newJson);
     * gs.log('the same: ' + (json == newJson));
     */
    fromJson(json: String);

    /**
     * Defines the Notify call record in which to add subsequent actions.
     * 
     * @callRecord GlideRecord containing the record of the caller (within the notify_call table) for which to add actions. This caller stays in affect until this method is called again with a different caller.
     * @example
     * public NotifyAction runIncomingCallWorkflow(NotifyPhoneNumber notifyPhoneNumber, GlideRecord callRecord) throws NoWorkflowConfiguredException, NoSuchNotifyGroupRecordException {
     *    NotifyAction notifyAction = runWorkflow(notifyPhoneNumber, COL_INCOMING_CALL_WF, callRecord);
     *    notifyAction.setCallRecord(callRecord);
     *    return notifyAction;
     * }
     */
    setCallRecord(callRecord: GlideRecord);

    /**
     * Serialize the NotifyAction object to a JSON string.
     * 
     * @example
     * // instantiate notify action
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // add one or more notify actions
     * // ...
     * 
     * // and serialize to json
     * var json = notifyAction.toJson();
     * @example
     * // instantiate notify action
     * var notifyAction = new SNC.NotifyAction();
     * 
     * // add a queue
     * var queue = notifyAction.addQueue();
     * queue.setName('myQueueName');
     * queue.setDequeue(false);
     * 
     * // serialize to json
     * var json = notifyAction.toJson();
     * gs.log('serialization result: ' + json);
     * 
     * // instantiate a new notify action
     * var newAction = new SNC.NotifyAction();
     * 
     * // deserialize the json generated above
     * newAction.fromJson(json);
     * 
     * // serialize the new object and log the result
     * newJson = newAction.toJson();
     * gs.log('new serialization result: ' + newJson);
     * gs.log('the same: ' + (json == newJson));
     * @returns JSON representation of this NotifyAction object.
     */
    toJson(): String;

}

/**
 * The NotifyPhoneNumber API allows you to query information about a Notify phone number. Access the global NotifyPhoneNumber class and its associated methods in the SNC namespace.
 * 
 * 
 */
declare class NotifyPhoneNumber {



    /**
     * Returns the international dialing code for a Notify phone number.
     * 
     * @example
     * var numbers = SNC.Notify.getPhoneNumbers();
     *  
     * // Here numbers is of type List
     * if (numbers.size() &gt; 0) {
     *    var number = numbers.get(0);
     *  
     *    // Here number is of type NotifyPhoneNumber
     *   gs.info(number.getDialCode());
     * }
     * @returns International phone code for a country.
     */
    getDialCode(): String;

    /**
     * Returns the ID of this phone number as defined by the telephony provider.
     * 
     * @example
     * var numbers = SNC.NotifyScoped.getPhoneNumbers();
     *  
     * // Here numbers is of type List
     * if (numbers.size() &gt; 0) {
     *    var number = numbers.get(0);
     *  
     *    // Here number is of type NotifyPhoneNumber
     *   gs.info(number.getID());
     * }
     * @returns Identifier of the number within the telephony provider.
     */
    getID(): String;

    /**
     * Returns the numerical phone number for the current Notify caller.
     * 
     * @example
     * var numbers = SNC.Notify.getPhoneNumbers();
     *  
     * // Here numbers is of type List
     * if (numbers.size() &gt; 0) {
     *    var number = numbers.get(0);
     *  
     *    // Here number is of type NotifyPhoneNumber
     *   gs.info(number.getNumber());
     * }
     * @returns E.164-compliant phone number.
     */
    getNumber(): String;

    /**
     * Returns the telephony provider associated with this phone number.
     * 
     * @example
     * var numbers = SNC.Notify.getPhoneNumbers();
     *  
     * // Here numbers is of type List
     * if (numbers.size() &gt; 0) {
     *    var number = numbers.get(0);
     *  
     *    // Here number is of type NotifyPhoneNumber
     *   gs.info(number.getOwner());
     * }
     * @returns Telephony provider associated with the number: Twilio.
     */
    getOwner(): String;

    /**
     * Returns the country associated with the phone number.
     * 
     * @example
     * var numbers = SNC.Notify.getPhoneNumbers();
     *  
     * // Here numbers is of type List
     * if (numbers.size() &gt; 0) {
     *    var number = numbers.get(0);
     *  
     *    // Here number is of type NotifyPhoneNumber
     *   gs.info(number.getTerritory());
     * }
     * @returns Name of the country to which the phone number belongs.
     */
    getTerritory(): String;

    /**
     * Determines whether the current Notify phone number is a short code.
     * 
     * @example
     * GlideRecord notifyNumber = new GlideRecord(TABLE_NOTIFY_NUMBER);
     * notifyNumber.query(COL_NUMBER, notifyPhoneNumber.getNumber());
     * 
     * if (!notifyNumber.next()) {
     *   notifyNumber.initialize();
     *   notifyNumber.setValue(COL_OWNER, notifyPhoneNumber.getOwner());
     *   if (notifyPhoneNumber.isShortCode()) {
     *     notifyNumber.setValue(COL_SHORT_CODE, notifyPhoneNumber.getNumber());
     *   } else {
     *     notifyNumber.setValue(COL_PHONE_NUMBER, notifyPhoneNumber.getNumber());
     *   }
     * @returns Flag that indicates whether the current Notify phone number is a short code. true: phone number is a short code. false: phone number is not a short code. 
     */
    isShortCode(): Boolean;

    /**
     * Determines if the Notify phone number supports conference calling.
     * 
     * @example
     * var numbers = SNC.Notify.getPhoneNumbers();
     *  
     * // Here numbers is of type List
     * if (numbers.size() &gt; 0) {
     *    var number = numbers.get(0);
     *  
     *    // Here number is of type NotifyPhoneNumber
     *   gs.info(number.supportsConferenceCall());
     * }
     * @returns Value that indicates whether the Notify phone number supports conference calling. true: phone number does support conference calling false: phone number does not support conference calling 
     */
    supportsConferenceCall(): Boolean;

    /**
     * Determines if the Notify phone number supports receiving phone calls.
     * 
     * @example
     * var numbers = SNC.Notify.getPhoneNumbers();
     *  
     * // Here numbers is of type List
     * if (numbers.size() &gt; 0) {
     *    var number = numbers.get(0);
     *  
     *    // Here number is of type NotifyPhoneNumber
     *   gs.info(number.supportsIncomingPhoneCall());
     * }
     * @returns Value that indicates whether the Notify phone number supports incoming phone calls. true: phone number does support incoming phone calls false: phone number does not support incoming phone calls 
     */
    supportsIncomingPhoneCall(): Boolean;

    /**
     * Determines if the Notify phone number supports receiving SMS messages.
     * 
     * @example
     * var numbers = SNC.Notify.getPhoneNumbers();
     *  
     * // Here numbers is of type List
     * if (numbers.size() &gt; 0) {
     *    var number = numbers.get(0);
     *  
     *    // Here number is of type NotifyPhoneNumber
     *   gs.info(number.supportsIncomingSMS());
     * }
     * @returns Value that indicates whether the Notify phone number supports receiving incoming MMS messages. true: phone number does support receiving incoming MMS messages false: phone number does not support receiving incoming MMS messages 
     */
    supportsIncomingSMS(): Boolean;

    /**
     * Determines if the Notify phone number supports initiating phone calls.
     * 
     * @example
     * var numbers = SNC.Notify.getPhoneNumbers();
     *  
     * // Here numbers is of type List
     * if (numbers.size() &gt; 0) {
     *    var number = numbers.get(0);
     *  
     *    // Here number is of type NotifyPhoneNumber
     *   gs.info(number.supportsOutgoingPhoneCall());
     * }
     * @returns Value that indicates whether the Notify phone number supports initiating outgoing phone calls. true: phone number does support initiating outgoing phone calls false: phone number does not support initiating outgoing phone calls 
     */
    supportsOutgoingPhoneCall(): Boolean;

    /**
     * Determines if the Notify phone number supports sending SMS messages.
     * 
     * @example
     * var numbers = SNC.Notify.getPhoneNumbers();
     *  
     * // Here numbers is of type List
     * if (numbers.size() &gt; 0) {
     *    var number = numbers.get(0);
     *  
     *    // Here number is of type NotifyPhoneNumber
     *   gs.info(number.supportsOutgoingSMS());
     * }
     * @returns Value that indicates whether the Notify phone number supports sending SMS messages. true: phone number does support sending SMS messages false: phone number does not support sending SMS messages 
     */
    supportsOutgoingSMS(): Boolean;

    /**
     * Determines if the Notify phone number supports recording phone calls.
     * 
     * @example
     * var numbers = SNC.Notify.getPhoneNumbers();
     *  
     * // Here numbers is of type List
     * if (numbers.size() &gt; 0) {
     *    var number = numbers.get(0);
     *  
     *    // Here number is of type NotifyPhoneNumber
     *   gs.info(number.supportsRecording());
     * }
     * @returns Value that indicates whether the Notify phone number supports recording phone calls. true: phone number does support recording phone calls false: phone number does not support recording phone calls 
     */
    supportsRecording(): Boolean;

    /**
     * Determines if the Notify phone number supports calls to a browser, such as in a WebRTC implementation.
     * 
     * @example
     * var numbers = SNC.Notify.getPhoneNumbers();
     *  
     * // Here numbers is of type List
     * if (numbers.size() &gt; 0) {
     *    var number = numbers.get(0);
     *  
     *    // Here number is of type NotifyPhoneNumber
     *   gs.info(number.supportsWebRTC());
     * }
     * @returns Value that indicates whether the Notify phone number supports calls to a browser. true: phone number does support calls to a browser false: phone number does not support calls to a browser 
     */
    supportsWebRTC(): Boolean;

}

/**
 * This script include modifies request parameters and parses the token response during runtime. If the external OAuth provider returns a response other than an application/JSON type response, you can customize your own version of this script include to parse responses that are in different format. Extend or copy this script include, and then reference your version from the OAuth API Script field on the Application Registry form for third-party OAuth providers. The custom script include name must start with OAuth.
 * 
 * 
 */
declare class OAuthUtil {



    /**
     * Adds a name:value pair to the request parameters.
     * 
     * @requestParamMap The name:value pair you want to add.
     */
    interceptRequestParameters(requestParamMap: String);

    /**
     * Parses the token received into a parameter map.
     * 
     * @accessTokenResponse The access token response that you want to parse.
     */
    parseTokenResponse(accessTokenResponse: String);

}

/**
 * The OCRosterSpanApprovalUtil API for the PTO approval feature. 
 * 
 * 
 */
declare class OCRosterSpanApprovalUtil {



    /**
     * Changes the type of the roster_schedule_span to time-off from approval.
     * 
     * @rosterSpanGr A roster_schedule_span_proposal record.
     */
    approvePTOSpan (rosterSpanGr: GlideRecord);

    /**
     * Returns a URL to the on-call calendar based on the rosterSpanProposalGr.
     * 
     * @rosterSpanProposalGr A roster_schedule_span_proposal record.
     * @returns A URL to the on-call calendar based on the rosterSpanProposalGr.
     */
    getContextualCalUrlPerSpanProposal (rosterSpanProposalGr: GlideRecord): String;

    /**
     * Returns a formatted GlideScheduleDateTime string based on the start date of the rosterSpanProposalGr.
     * 
     * @rosterSpanProposalGr A roster_schedule_span_proposal record.
     * @returns A formatted GlideScheduleDateTime string based on the start date of the rosterSpanProposalGr.
     */
    getFromDateDisplayValuePerSpanProposal (rosterSpanProposalGr: GlideRecord): String;

    /**
     * Returns an array of group managers based on the user's rota groups.
     * 
     * @rosterSpanProposalGr A roster_schedule_span_proposal record.
     * @returns An array of group managers based on the user's rota groups.
     */
    getPTOApproversList (rosterSpanProposalGr: GlideRecord): Array<any>;

    /**
     * Returns a formatted GlideScheduleDateTime string based on the end date of the rosterSpanProposalGr.
     * 
     * @rosterSpanProposalGr A roster_schedule_span_proposal record.
     * @returns A formatted GlideScheduleDateTime string based on the end date of the rosterSpanProposalGr.
     */
    getToDateDisplayValuePerSpanProposal (rosterSpanProposalGr: GlideRecord): String;

    /**
     * Returns the user's name based on rosterSpanProposalGr.
     * 
     * @rosterSpanProposalGr A roster_schedule_span_proposal record.
     * @returns The user's name based on rosterSpanProposalGr.
     */
    getUserNamePerSpanProposal (rosterSpanProposalGr: GlideRecord): String;

    /**
     * Checks whether the system property com.snc.on_call_rotation.pto.approval.required is true.
     * 
     * @returns Returns true if the system property com.snc.on_call_rotation.pto.approval.required is true..
     */
    isPTOApprovalRequired (): Boolean;

    /**
     * Changes the type of the roster_schedule_span to rejected from approval.
     * 
     * @rosterSpanGr A roster_schedule_span_proposal record.
     */
    rejectPTOSpan (rosterSpanGr: GlideRecord);

}

/**
 * The OCRotaICalendar API is an extension of the OCRotaICalendarSNC API. 
 * 
 * 
 */
declare class OCRotaICalendar {



}

/**
 * The OCRotaICalendarSNC API provides iCal formatted events for the a specific user's rotation. 
 * 
 * 
 */
declare class OCRotaICalendarSNC {



    /**
     * Records in the cmn_rota_resp_cache table that have a From date prior to today.
     * 
     */
    cleanExpiredCache ();

    /**
     * Returns list of AJAXScheduleItems for the user's on-call.
     * 
     * @groupId The group sys id.
     * @rotaId The rota sys id.
     * @userId The user sys id.
     * @dateRangeObj Contains the from and to dates for the data set.
     * @returns Java list of AJAXScheduleItems.
     */
    createCalendarEvents (groupId: String, rotaId: String, userId: String, dateRangeObj: Object): AJAXScheduleItem;

    /**
     * Creates a VEVENT based on the scheduleItemSpan provided.
     * 
     * @groupName Name of the on-call group.
     * @scheduleItemSpan Span of time for the on-call period.
     * @calendarLink A link back to the on-call calendar in the instance.
     * @returns A VEVENT based on the scheduleItemSpan provided.
     */
    createCustomEvent (groupName: String, scheduleItemSpan: Object, calendarLink: String): String;

    /**
     * Creates a formatted iCalendar if the user has no upcoming on-call.
     * 
     * @rotaGR The cmn_rota glide record.
     * @dateRangeObj Contains the from and to dates for the data set.
     * @calendarLink A link to the on-call calendar for this user.
     * @returns Formatted iCalendar with a placeholder VEVENT.
     */
    createPlaceholderCalendar (rotaGR: GlideRecord, dateRangeObj: Object, calendarLink: String): String;

    /**
     * Returns the formatted iCalendar for the user's rotation.
     * 
     * @groupId The group sys id.
     * @rotaId The rota sys id.
     * @userId The user sys id.
     * @dateRangeObj Contains the from and to dates for the data set.
     * @useCache If true, makes use of the cache table cmn_rota_resp_cache.
     * @returns Formatted iCalendar for the user's rotation.
     */
    getCalendarEvents (groupId: String, rotaId: String, userId: String, dateRangeObj: Object, useCache: Boolean): String;

    /**
     * Returns the formatted iCalendar for the user's rotation if found in the cmn_rota_resp_cache table.
     * 
     * @groupId The group sys id.
     * @rotaId The rota sys id.
     * @userId The user sys id.
     * @dateRangeObj Contains the from and to dates for the data set.
     * @returns Formatted iCalendar for the user's rotation if found in the cmn_rota_resp_cache table.
     */
    getEventsFromTable (groupId: String, rotaId: String, userId: String, dateRangeObj: Object): String;

    /**
     * Checks whether the provided timeSpan intersects with one of the rota span items.
     * 
     * @timeSpan A single span for the user's on-call.
     * @rotaSpanItems Contains the user's standard on-call spans.
     * @returns If the timeSpan intersects with one of the rota span items, returns an object containing the rota span item and the span that it intersects with.
     */
    getIntersectRotaSpanItem (timeSpan: ScheduleTimeSpan, rotaSpanItems: Array<any>): Object;

    /**
     * Creates the subscribable URL for the user's iCalendar.
     * 
     * @groupId The group sys id.
     * @rotaId The rota sys id.
     * @userId The user sys id.
     * @returns The subscribable URL for the user's iCalendar.
     */
    getMemberCalendarURL (groupId: String, rotaId: Object, userId: String): String;

    /**
     * Returns a URL to the on-call calendar based on the rota record.
     * 
     * @rotaGR A cmn_rota record.
     * @returns URL to the on-call calendar based on the rota record.
     */
    getOnCallCalendarURL (rotaGR: GlideRecord): String;

    /**
     * Returns an array of the user's overrides (extra coverage).
     * 
     * @scheduleItem A list of AJAXScheduleItems.
     * @returns An array of the user's overrides (extra coverage).
     */
    handleOverrideMember (scheduleItem: AJAXScheduleItem): Array<any>;

    /**
     * Returns an object containing the user's override (extra coverage) and excluded spans.
     * 
     * @scheduleItem A list of AJAXScheduleItems.
     * @rotaSpanItems Contains the user's standard on-call spans.
     * @definitionItems Contains the rota's standard on-call spans.
     * @repeatRotaSpanIdArr An array of rota span sys ids.
     * @returns Contains the user's override (extra coverage) and excluded spans.
     */
    handleRotaMember (scheduleItem: AJAXSchedueItem, rotaSpanItems: Object, definitionItems: Object, repeatRotaSpanIdArr: Array<any>): Object;

    /**
     * Used by business rules on the cmn_rota_member, cmn_schedule_span, and roster_schedule_span tables tp update the cmn_rota_resp_cache table.
     * 
     * @rotaRespCacheGR Record that has been updated.
     */
    invalRotaRespCache (rotaRespCacheGR: GlideRecord);

    /**
     * Checks whether the provided timeSpan matches one of the rotaSpanItems.
     * 
     * @timeSpan A single span for the user's on-call.
     * @rotaSpanItems Contains the user's standard on-call spans.
     * @repeatRotaSpanIdArr An array of rota span sys ids.
     * @seriesStartTimes Start time of the rota spans.
     * @returns Returns true if the timeSpan matches one of the rotaSpanItems.
     */
    matchRotaSpanRule(timeSpan: ScheduleTimeSpan, rotaSpanItems: Array<any>, repeatRotaSpanIdArr: Array<any>, seriesStartTimes: Object): Boolean;

    /**
     * Used by fixed job to populate the calendar subscription fields on the cmn_rota form
     * 
     */
    populateCalendarSubscriptionSettings ();

    /**
     * Returns an object containing the user's rotations.
     * 
     * @scheduleItems The user's on-call rotation as an AJAXScheduleItem list.
     * @repeatRotaSpanIdArr An array of the cmn_rota schedule span record sys_ids.
     * @userId The user sys id.
     * @returns Contains the user's rotations.
     */
    processSeriesEvent (scheduleItems: List, repeatRotaSpanIdArr: Array<any>, userId: String): Object;

    /**
     * Inserts the user's iCalendar into the cmn_rota_resp_cache table.
     * 
     * @groupId The group sys id.
     * @rotaId The rota sys id.
     * @userId The user sys id.
     * @dateRangeObj Contains the from and to dates for the data set.
     * @result The user's iCalendar.
     */
    saveCalendarEvents (groupId: String, rotaId: String, userId: String, dateRangeObj: Object, result: String);

    /**
     * Queues events to send an email to all members of the rotation.
     * 
     * @rotaGR A cmn_rota record.
     */
    sendCalendarURL (rotaGR: GlideRecord);

    /**
     * Returns an object that contains all of the timeSpans that need to be excluded from the user's iCalendar.
     * 
     * @scheduleItem One AJAXScheduleItem.
     * @timeSpan A single user's standard on-call span.
     * @rotaSpanItems Contains the user's standard on-call spans.
     * @returns Object that contains all of the timeSpans that need to be excluded from the user's iCalendar.
     */
    updateExceptionList (scheduleItem: AJAXScheduleItem, timeSpan: ScheduleTimeSpan, rotaSpanItems: Array<any>): Object;

}

/**
 * The OCRotaMember API performs maintenance operations on the cmn_rota_member table. 
 * 
 * 
 */
declare class OCRotaMember {



    /**
     * Deactivates the user's rota member records according to the deactivate date.
     * 
     * @userId The sys id of the user.
     * @deactivateDate The date from which the user's rotation is deactivated.
     */
    deactivateUser (userId: String, deactivateDate: GlideDateTime);

    /**
     * Checks whether the cmn_rota_member record has changed. Checks the Member, From, To, and Order fields have changed.
     * 
     * @current The latest changes made to the cmn_rota_member record.
     * @previous The original state of the cmn_rota_member record.
     */
    hasChanged (current: GlideRecord, previous: GlideRecord);

    /**
     * On update of a cmn_rota_member record, checks whether the order of the record has changed.
     * 
     * @current The latest changes made to the cmn_rota_member record.
     * @previous The original state of the cmn_rota_member record.
     * @returns Returns true if the order has changed.
     */
    hasOrderChanged (current: GlideRecord, previous: GlideRecord): Boolean;

    /**
     * Recalculates the schedule for the cmn_rota_member record.
     * 
     * @current The latest changes made to the cmn_rota_member record.
     * @previous The original state of the cmn_rota_member record.
     */
    recalculate (current: GlideRecord, previous: GlideRecord);

    /**
     * Ensures that the From date occurs before or on the same date as the To date.
     * 
     * @from Formatted date/
     * @to Formatted date/
     * @returns Returns true if the From date is before or on same date as To date.
     */
    validateDates (from: String, to: String): Boolean;

}

/**
 * The core OCRotation builds a data structure that is used to display the calendar. The code builds up the GlideAJAXSchedulePage object which stores a list of span items. You can use this type for the Gwt (legacy) calendar. See the OCRotationV2 API for other calender types. This is part of On-Call Scheduling.
 * 
 * 
 */
declare class OCRotation {



    /**
     * Builds the on-call coverage based on your groups, rotas, and rosters. This is used by the OCRotationV2 - getSpans method.
     * 
     * @returns  
     */
    buildRotas(): Void;

    /**
     * Returns the end date for the time period for which you want to retrieve on-call coverage.
     * 
     * @returns End date for the time period for which you want to retrieve on-call coverage.
     */
    getEndDate(): String;

    /**
     * Returns a comma separated list of group sys_id (sys_user_group) values for an on-call schedule.
     * 
     * @returns Comma separated list of group sys_id (sys_user_group) values for an on-call schedule.
     */
    getGroupIds(): String;

    /**
     * Returns the rosters according to the selected rotas.
     * 
     * @returns Rosters according to the selected rotas.
     */
    getRosterIds(): String;

    /**
     * Returns a GlideRecord for the cmn_rota table filtered by groups, rota, users, and roster.
     * 
     * @rotaIds Comma separated list of rota sys_id (cmn_rota) values for an on-call schedule.
     * @groupIds Comma separated list of group sys_id (sys_user_group) values for an on-call schedule.
     * @rosterIds Comma separated list of roster sys_id (cmn_rota_roster) values for an on-call schedule.
     * @userIds Comma separated list of user sys_id (sys_user) values for an on-call schedule.
     * @returns A GlideRecord for the cmn_rota table filtered by groups, rota, users, and roster.
     */
    getRotaGr(rotaIds: String, groupIds: String, rosterIds: String, userIds: String): GlideRecord;

    /**
     * Returns the rotas for the groups on your calendar.
     * 
     * @returns Rotas for the groups on your calendar.
     */
    getRotaIds(): String;

    /**
     * Returns the start date for the time period for which you want to retrieve on-call coverage.
     * 
     * @returns Start date for the time period for which you want to retrieve on-call coverage.
     */
    getStartDate(): String;

    /**
     * Returns the timezone that your on-call calendar will use.
     * 
     * @returns Timezone that your on-call calendar will use. For example, Europe/Madrid and US/Pacific.
     */
    getTimezone(): String;

    /**
     * This will filter the schedules return by users. Get comma separated list of user sys_id (sys_user) values used to filter on-call schedules.
     * 
     * @returns Comma separated list of user sys_id (sys_user) values used to filter on-call schedules.
     */
    getUserIDs(): String;

    /**
     * Set the end date for the time period for which you want to retrieve on-call coverage. If the end date is not set, then the last day of the next month is applied by default. Use in conjunction with OCRotationV2 - getSpans.
     * 
     * @endDate [Optional] End date of the on-call schedule.
     * @inclusive [Optional] When true, the end date is included in the time span. If not specified, this value defaults to true.
     * @returns  
     */
    setEndDate(endDate: String, inclusive: Boolean): Void;

    /**
     * Filters the schedules return by groups. Set comma separated list of group sys_id (sys_user_group) values for an on-call schedule. Use in conjunction with OCRotationV2 - getSpans.
     * 
     * @groupIds Comma separated list of group sys_id (sys_user_group) values for an on-call schedule.
     * @returns  
     */
    setGroupIds(groupIds: String): Void;

    /**
     * Sets the rosters according to the selected rotas. Use in conjunction with OCRotationV2 - getSpans.
     * 
     * @RosterIds Rosters according to the selected rotas.
     */
    setRosterIds(RosterIds: String);

    /**
     * Sets the rotas for the groups on your calendar. Use in conjunction with OCRotationV2 - getSpans.
     * 
     * @RotaIds Rotas for the groups on your calendar.
     * @returns  
     */
    setRotaIds(RotaIds: String): Void;

    /**
     * Sets the start date for the time period for which you want to retrieve on-call coverage. If the start date is not set, then the first day of the previous month is applied by default. Use in conjunction with OCRotationV2 - getSpans.
     * 
     * @startDate [Optional] Start date for the time period for which you want to retrieve on-call coverage.
     */
    setStartDate(startDate: String);

    /**
     * Sets the timezone that your on-call calendar will use. Use in conjunction with OCRotationV2 - getSpans.
     * 
     * @Timezone Timezone that your on-call calendar will use. For example, Europe/Madrid and US/Pacific.
     * @returns  
     */
    setTimezone(Timezone: String): Void;

    /**
     * Sets comma separated list of user sys_id (sys_user) values used to filter on-call schedules. Use in conjunction with OCRotationV2 - getSpans.
     * 
     * @UserIds Comma separated list of user sys_id (sys_user) values used to filter on-call schedules.
     * @returns  
     */
    setUserIds(UserIds: String): Void;

}

/**
 * OCRotationV2 is an extension of OCRotation, which is used by Fullcalendar.io and the DHTMLX On-Call Calendar. OCRotationV2 is used to get the schedule time span between two dates that are further filtered by groups, rotas, rosters, and users. You can also extend OCRotationV2 to add or modify behavior. This is part of On-Call Scheduling.
 * 
 * 
 */
declare class OCRotationV2 {



    /**
     * Returns an array of groups that have active rotas.
     * 
     * @returns An array of group objects. Each contains the following attributes: sys_id of the sys_user_group record name of the sys_user_group record 
     */
    getGroups(): Array<any>;

    /**
     * Returns an array of active rosters for a given rota ID.
     * 
     * @rotaSysIds Comma separated list of rota sys_id (cmn_rota) values.
     * @returns An array of rota objects. Each contains the following attributes: sys_id of the cmn_rota_roster record name of the cmn_rota_roster record rota sys_id of the cmn_rota record 
     */
    getRostersByRotas(rotaSysIds: String): Array<any>;

    /**
     * Returns an array of active rotas for a given group ID.
     * 
     * @groupSysIds Comma separated list of group sys_id (sys_user_group) values.
     * @returns An array of rota objects. Each contains the following attributes: sys_id of the cmn_rota record name of the cmn_rota record group sys_id of the sys_user_group record 
     */
    getRotasByGroup(groupSysIds: String): Array<any>;

    /**
     * Get the spans from the specified start date to the specified end date. If no start and end dates are provided, the start date defaults to a month before and the end date defaults to a month after the current time. You can also use the groups IDs, rota IDs, roster IDs, user IDs to further filter the spans.
     * 
     * @returns An array of spans. Each contains the following attributes: id, sys_id, table, rota_id, roster_id, user_id, text, description, color, textColor, start_date, end_date.
     */
    getSpans(): Array<any>;

}

/**
 * The OCSeriesEventGenerator API generates the repeating VEVENTS for a user's iCalendar. 
 * 
 * 
 */
declare class OCSeriesEventGenerator {



    /**
     * Returns an array of the repeating on-call events.
     * 
     * @groupId The group sys id.
     * @rotaId The rota sys id.
     * @userId The user sys id.
     * @dateRangeObj Contains the from and to dates for the data set.
     * @memberSchedules The user's schedule.
     * @calendarLink A link back to the on-call calendar in the instance.
     * @returns Array of the repeating on-call events.
     */
    getMemberCalendar (groupId: String, rotaId: String, userId: String, dateRangeObj: Object, memberSchedules: Object, calendarLink: String): Array<any>;

    /**
     * Returns an array of VEVENTs that represent the on-call for the provided rotaScheduleSpanGR and the memberScheduleSpanGR.
     * 
     * @rotaScheduleSpanGR A cmn_schedule_span glide record for a rota.
     * @memberScheduleSpanGR A cmn_schedule_span glide record for a rota member.
     * @seriesStartTimes An array of the repeating rota span start times.
     * @excludeItems The schedule items that need to be excluded.
     * @repeatUntil A formatted ScheduleDateTime string.
     * @timeZone Time zone for the on-call rota.
     * @calendarLink A link to the on-call calendar for this user.
     * @returns An array of VEVENTs that represent the on-call for the provided rotaScheduleSpanGR and the memberScheduleSpanGR.
     */
    getRosterICalEvents (rotaScheduleSpanGR: GlideRecord, memberScheduleSpanGR: GlideRecord, seriesStartTimes: Array<any>, excludeItems: Object, repeatUntil: String, timeZone: String, calendarLink: String): Array<any>;

    /**
     * Returns an array of the repeating on-call VEVENTS.
     * 
     * @rotaMemberGR A cmn_rota_member record.
     * @seriesStartTimes An array of the repeating rota span start times.
     * @excludeItems The schedule items that need to be excluded.
     * @repeatUntil A formatted ScheduleDateTime string.
     * @calendarLink A link to the on-call calendar for this user.
     * @returns An array of the repeating on-call VEVENTS
     */
    getRosterMemberEvents (rotaMemberGR: GlideRecord, seriesStartTimes: Array<any>, excludeItems: Object, repeatUntil: String, calendarLink: String): Array<any>;

}

/**
 * The OCTimer API provides the ability to track the length of time it takes for a function to complete. 
 * 
 * 
 */
declare class OCTimer {



    /**
     * Logs the entry based on the function name.
     * 
     * @name Function name.
     * @entry Text that will be part of the output in the log.
     */
    log (name: String, entry: String);

    /**
     * Takes a millisecond value and returns a formatted duration.
     * 
     * @millis Duration in miliseconds.
     * @returns A formatted duration.
     */
    millisToTime (millis: Integer): String;

    /**
     * Calculates the time taken for each function registered.
     * 
     * @returns Time taken for each function registered.
     */
    result (): String;

    /**
     * Initializes a timer based on the name provided.
     * 
     * @name Function name.
     */
    start (name: String);

    /**
     * Registers the end of the timer for the provided name.
     * 
     * @name Function name.
     */
    stop (name: String);

}

/**
 * Use to manage on-call schedules. 
 * 
 * 
 */
declare class OnCallRotation {



    /**
     * Creates an instance of the OnCallRotation class.
     * 
     * @example
     * var oncall = new OnCallRotation();
     */
    constructor();

    /**
     * Add the current escalation member to the list of notified users so that the API knows who has been contacted. This API is applicable for a single shift, overlapping shifts, and custom escalation.
     * 
     */
    addCurrentToNotified();

    /**
     * Cancels any escalations for the GlideRecord that were started with the startEscalations API. This API is applicable for a single shift, overlapping shifts, and custom escalation.
     * 
     * @escalationGr GlideRecord of Rotation escalation(cmn_rota_escalation
     */
    cancelEscalations(escalationGr: GlideRecord);

    /**
     * Continue the escalations for a document(incident gr) and group. This API is applicable for a single shift, overlapping shifts, and custom escalation.
     * 
     * @escalationGr GlideRecord of Rotation escalation(cmn_rota_escalation
     */
    continueEscalations(escalationGr: GlideRecord);

    /**
     * Gets the sys_id of the catch all person. Use together with the getCatchAllType() method to determine the source of the returned id. This API is applicable for a single shift, overlapping shifts, and custom escalation.
     * 
     * @rotaID The sys_id of the rota.
     * @example
     * 
     * var rotaSysId = '349f399173062300e7af6238edf6a75e';
     * var onCallRotation = new OnCallRotation();
     * var catchAll = onCallRotation.getCatchAll(rotaSysId);
     * gs.log(catchAll);
     * 
     * @returns The sys_id of a sys_user, a cmn_rota_roster, or null.
     */
    getCatchAll(rotaID: String): String;

    /**
     * Gets the type of _catch all_ that lives at the end of the escalation chain. When the escalation chain finishes without assigning an on-call person, if configured, the incident is assigned to the _catch all_. This API is applicable for a single shift, overlapping shifts, and custom escalation.
     * 
     * @rotaID The sys_id of the rota.
     * @example
     * var rotaSysId = '349f399173062300e7af6238edf6a75e';
     * var onCallRotation = new OnCallRotation();
     * var catchAllType = onCallRotation.getCatchAllType(rotaSysId);
     * gs.log(catchAllType);
     * 
     * @returns  Null: invalid rota id or catch all is not available. Group_manager: the manager of the group linked to the rota is the catch all person. Individual: a configured user is the catch all person. All: all members of the configured roster are the catch all person. 
     */
    getCatchAllType(rotaID: String): String;

    /**
     * Gets an item to escalate to, either a user [sys_user], group, or notification device [cmn_notif_device], for a group's shift at the specified date and time and at a certain position in the escalation lineup. This API is applicable for a single shift.The method returns null if an invalid position or group is passed as an argument.You can use the getTableName() method to check whether the returning GlideRecord comes from the sys_user or cmn_notif_device table.
     * 
     * @groupID The sys_id for the group from which to get the item to escalate.
     * @dateTime The date and time when the escalation lineup should begin.
     * @position The position in the lineup to determine the item to escalate to (1-based, which means the count starts with 1).
     * @example
     * 
     * var groupSysId = '096fb59173062300e7af6238edf6a783';
     * var currentTime = new GlideDateTime();
     * var onCallRotation = new OnCallRotation();
     * var escalatee = onCallRotation.getEscalateeAt(groupSysId, currentTime, 1);
     * gs.log(escalatee.name);
     * 
     * @returns The item to escalate to,that is, escalatees (either a user, group, or device records depending on the notification rules) at a specific time and position. Returns null if nothing is found.
     */
    getEscalateeAt(groupID: String, dateTime: GlideDateTime, position: Number): GlideRecord;

    /**
     * Gets a list of escalatees that are on-call for a given time. If no time is specified, then the current time is used. If no groupSysIds are provided, empty list is returned. This API is applicable for a single shift, overlapping shifts, and custom escalation.
     * 
     * @groupSysIds Comma-separated list of sys_ids of the sys_user_group, to filter the records by.
     * @rotaSysIds Comma-separated list of cmn_rota sys_ids to filter the records by.
     * @rosterSysIds Comma-separated list of cmn_rota_roster sys_ids to filter the records by.
     * @gdt Date in the UTC timezone
     * @example
     * 
     * var groupSysId = '096fb59173062300e7af6238edf6a783';
     * var currentTime = new GlideDateTime();
     * var onCallRotation = new OnCallRotation();
     * var result = onCallRotation.getEscalatees(groupSysId, "", "", currentTime);
     * gs.log(JSON.stringify(result));
     * 
     * @returns Escalatee information such as userIds, deviceIds, and escalationGroups.
     */
    getEscalatees(groupSysIds: String, rotaSysIds: String, rosterSysIds: String, gdt: GlideDateTime): Object;

    /**
     * Gets the escalatees (either a user, group, or device records depending on the notification rules) at a specific time and position. This API is applicable for a single shift, overlapping shifts and custom escalation.
     * 
     * @groupSysId ys_id of the group.
     * @gdt yyyy-MM-dd HH:mm:ss format in the UTC timezone. Default is now.
     * @position Position of the escalation step.
     * @example
     * var groupSysId = '096fb59173062300e7af6238edf6a783';
     * var currentTime = new GlideDateTime();
     * var onCallRotation = new OnCallRotation();
     * var escalatees = onCallRotation.getEscalateesAt(groupSysId, currentTime, 1);
     * for (var i = 0; i &lt; escalatees.length; i++) {
     * gs.log(escalatees[i].name);
     * }
     * 
     * @returns Array of escalatees (either a user, group, or device records depending on the notification rules) at a specific time and position.
     */
    getEscalateesAt(groupSysId: String, gdt: GlideDateTime, position: Number): GlideRecord;

    /**
     * Gets a list of objects to escalate to, escalation plans that consist of either a user [sys_user] or notification device [cmn_notif_device], for a group's shift at the specified date and time. This API is applicable for a single shift, overlapping shifts, and custom escalation.The Escalation object contains the following fields: Number order: the escalation order within the lineup String userId: sys_id of the sys_user record or null String deviceId: sys_id of the cmn_notif_device record or null Boolean isDevice: true or false depending on whether the item to escalate to is a device or user GlideDuration timeBetweenReminders: the time between reminders being sent Number reminderNum: number of reminders to be sent for each item to escalate to 
     * 
     * @groupID sys_id for the group for which you need the escalation plan.
     * @gdt Date and time when the escalation lineup should begin. Default is now. yyyy-MM-dd HH:mm:ss is the format in UTC timezone.
     * @rotaSysIds Comma-separated list of cmn_rota sys_ids to filter the records by.
     * @example
     * var groupSysId = '096fb59173062300e7af6238edf6a783';
     * var currentTime = new GlideDateTime();
     * var onCallRotation = new OnCallRotation();
     * var result = onCallRotation.getEscalationPlan(groupSysId, currentTime);
     * gs.log(JSON.stringify(result));
     * 
     * @returns A list of escalation objects to escalate to.
     */
    getEscalationPlan(groupID: String, gdt: GlideDateTime, rotaSysIds: String): Object;

    /**
     * Gets the type of escalation based on a simple calculation. If there is one active roster in the rota, rotate through members. If there is more than one active roster in the rota, rotate through rosters. This API is applicable for a single shift, overlapping shifts, and custom escalation.
     * 
     * @rotaID The sys_id for the rota to check for rosters.
     * @example
     * var rotaSysId = '349f399173062300e7af6238edf6a75e';
     * var onCallRotation = new OnCallRotation();
     * var escalationType = onCallRotation.getEscalationType(rotaSysId);
     * gs.log(escalationType);
     * 
     * @returns  Member: if there is one roster in the rota. Roster: if there is more than one roster in the rota. No rosters in this rota: if none of the above. Custom: If the custom escalation is applicable. 
     */
    getEscalationType(rotaID: String): String;

    /**
     * Gets the sys_id of the current primary contact when there is a single shift.
     * 
     * @example
     * 
     * var groupSysId = '096fb59173062300e7af6238edf6a783';
     * var currentTime = new GlideDateTime();
     * var onCallRotation = new OnCallRotation();
     * var result = onCallRotation.who(groupSysId, currentTime);
     * var primaryUser = onCallRotation.getPrimaryUser();
     * 
     * @returns sys_id of the current primary contact.
     */
    getPrimaryUser(): String;

    /**
     * Gets the sys_id of the current primary user of the specified shift. This API is applicable for a single shift and overlapping shifts.
     * 
     * @rotaId sys_id of the cmn_rota.
     * @example
     * 
     * var groupSysId = '096fb59173062300e7af6238edf6a783';
     * var rotaId = '349f399173062300e7af6238edf6a75e';
     * var currentTime = new GlideDateTime();
     * var onCallRotation = new OnCallRotation();
     * var result = onCallRotation.who(groupSysId, currentTime);
     * var primaryUser = onCallRotation.getPrimaryUserByRota(rotaId);
     * gs.log(primaryUser);
     * 
     * @returns sys_id of the current primary user of the specified shift.
     */
    getPrimaryUserByRota(rotaId: String): String;

    /**
     * Gets the name of the current primary contact. This API is applicable for a single shift.
     * 
     * @example
     * 
     * var groupSysId = '096fb59173062300e7af6238edf6a783';
     * var currentTime = new GlideDateTime();
     * var onCallRotation = new OnCallRotation();
     * var result = onCallRotation.who(groupSysId, currentTime);
     * var primaryUser = onCallRotation.getPrimaryUserName();
     * gs.log(primaryUser);
     * 
     * @returns Name of the current primary contact.
     */
    getPrimaryUserName(): String;

    /**
     * Gets the name of the current primary user of the specified shift. This API is applicable for a single shift and overlapping shifts.
     * 
     * @rotaId sys_id of the cmn_rota.
     * @example
     * 
     * var groupSysId = '096fb59173062300e7af6238edf6a783';
     * var rotaId = '349f399173062300e7af6238edf6a75e';
     * var currentTime = new GlideDateTime();
     * var onCallRotation = new OnCallRotation();
     * var result = onCallRotation.who(groupSysId, currentTime);
     * var primaryUser = onCallRotation.getPrimaryUserNameByRota(rotaId);
     * gs.log(primaryUser);
     * 
     * @returns Name of the current primary user of the specified shift.
     */
    getPrimaryUserNameByRota(rotaId: String): String;

    /**
     * Gets the list of primary contacts for a shift. This API is applicable for a single shift, overlapping shifts, and custom escalation.
     * 
     * @example
     * 
     * var groupSysId = '096fb59173062300e7af6238edf6a783';
     * var currentTime = new GlideDateTime();
     * var onCallRotation = new OnCallRotation();
     * var result = onCallRotation.who(groupSysId, currentTime);
     * var primaryUser = onCallRotation.getPrimaryUser();
     * gs.log(JSON.stringify(primaryUser));
     * 
     * @returns List of primary contacts.
     */
    getPrimaryUsers(): Object;

    /**
     * Checks if the parent span and child spans overlap.
     * 
     * @parent The parent spans to compare.
     * @child The child spans to compare.
     * @timeZone The name of the time zone.
     * @example
     * var onCall = new OnCallRotation();
     *  
     * // get a time range we are interested in
     * var timeZone = gs.getSession().getTimeZoneName();
     * var dateStart = new GlideDateTime();
     * var dateEnd = new GlideDateTime().addMonths(1);
     *  
     * // convert glidedatime to scheduledatetime because it is required
     * // by the function being called below
     * var scheduleStart = new GlideScheduleDateTime(dateStart);
     * var scheduleEnd =  new GlideScheduleDateTime(dateEnd);
     * scheduleStart.setTimeZone(timeZone);
     * scheduleEnd.setTimeZone(timeZone);
     *  
     * // calculate rotation items based on the date and time given
     * // for all the groups the currently logged in user is a member of
     * gs.include("OnCallRotationPersonal");
     * var rotation = new OnCallRotationPersonal();
     * var myGroups = gs.getUser().getMyGroups();
     * var groupIter = myGroups.iterator();
     *  
     * while(groupIter.hasNext()){
     * 	var rotaItems = rotation.onCallDuringPeriod(groupIter.next(), scheduleStart, scheduleEnd);
     *  
     * 	// loop through rotation schedules
     * 	for (var i = 0; i &lt; rotaItems.length - 1; i++) {
     * 		var parentItem = rotaItems[i];
     * 		var nextItem = rotaItems[i + 1];
     *  
     * 		// check if previous and next time spans overlap
     * 		var overlaps = onCall.spansOverlap(parentItem.getTimeSpans(), nextItem.getTimeSpans(), 
     * 			gs.getSession().getTimeZoneName());
     * 	}
     * }
     * @returns Returns true if the parent and child spans overlap.
     */
    spansOverlap(parent: ArrayList, child: ArrayList, timeZone: String): Boolean;

    /**
     * Start the escalations for a document(incident gr) and group, and specify the event name for the escalation notifications. In addition, specify the name of the business rule to call when an escalation occurs. This method should be used after a succesful call to who or whoAt methods. This API is applicable for a single shift, overlapping shifts, and custom escalation.
     * 
     * @gr Document glide record. For example, Incident gr.
     * @eventName Event name for the escalation notifications.
     * @escalationScriptName Business rule to call when escalation occurs
     */
    startEscalations(gr: GlideRecord, eventName: String, escalationScriptName: String);

    /**
     * Specifies if there is an on-call user, group, or device. This API is applicable for a single shift, overlapping shifts, and custom escalation.
     * 
     * @groupSysId sys_id of the group to check for.
     * @gdt yyyy-MM-dd HH:mm:ss format in the UTC timezone. Default is now.
     * @nullifyOverrideRoster Used to control whether rosterId should be returned in output for coverage entries. (In the legacy behaviour, null was returned.)
     * @rotaSysIds comma-seperated list of cmn_rota sys_ids to filter the records by.
     * @example
     * 
     * var groupSysId = '096fb59173062300e7af6238edf6a783';
     * var currentTime = new GlideDateTime();
     * var onCallRotation = new OnCallRotation();
     * var result = onCallRotation.who(groupSysId, currentTime);
     * gs.log(result);
     * 
     * @returns Returns true if at least one match s found, else returns false.
     */
    whoAt(groupSysId: String, gdt: GlideDateTime, nullifyOverrideRoster: Boolean, rotaSysIds: String): Boolean;

    /**
     * Specifies if there is an on-call user, group, or device. This API is applicable for a single shift, overlapping shifts, and custom escalation.
     * 
     * @groupSysId sys_id of the group.
     * @gdt yyyy-MM-dd HH:mm:ss format in the UTC timezone. Default is now.
     * @rotaSysIds comma-seperated list of cmn_rota sys_ids to filter the records by.
     * @example
     * 
     * var groupSysId = '096fb59173062300e7af6238edf6a783';
     * var currentTime = new GlideDateTime();
     * var onCallRotation = new OnCallRotation();
     * var result = onCallRotation.whoAt(groupSysId, currentTime);
     * gs.log(result);
     * 
     * @returns Returns true if there is at least one on-call user, group, or device. Else returns false.
     */
    whoAt(groupSysId: String, gdt: GlideDateTime, rotaSysIds: String): Boolean;

    /**
     * Escalation business rules determine who in the shift should be contacted next. The escalation record passed to the method tracks the escalation between invocations of the business rule. This API is applicable for a single shift, overlapping shifts, and custom escalation.
     * 
     * @escalationGr GlideRecord of Rotation escalation(cmn_rota_escalation)
     */
    whoIsNext(escalationGr: GlideRecord);

    /**
     * Gets the list of users that are on-call at a given time. If no time is specified, then current time is used. This API is applicable for a single shift and overlapping shifts.
     * 
     * @groupSysIds Comma-separated list of sys_ids of the sys_user_group, to filter the records by.
     * @rotaSysIds Comma-separated list of cmn_rota sys_ids to filter the records by.
     * @rosterSysIds Comma-separated list of cmn_rota_roster sys_ids to filter the records by.
     * @gdt Date in the UTC timezone
     * @example
     * var groupSysId = '096fb59173062300e7af6238edf6a783';
     * var currentTime = new GlideDateTime();
     * var onCallRotation = new OnCallRotation();
     * var escalatees = onCallRotation. whoIsOnCall(groupSysId, "", "", currentTime);
     * gs.log(JSON.stringify(escalatees));
     * 
     * @returns List of users, groups, or devices that are on-call at a given time. For example, information about userIds, deviceIds, and escalationGroups.
     */
    whoIsOnCall(groupSysIds: String, rotaSysIds: String, rosterSysIds: String, gdt: GlideDateTime): Object;

}

/**
 * OpenFrame is an omni-present frame that communication partners can use to integrate their systems into the ServiceNow platform. One of the core requirements is the ability to connect and serve code from different domains that can connect seamlessly with partner subsystems. This cross domain connection is required to keep connections and callbacks registered into communication systems without any cross domain issues. * * OpenFrame has two significant parts: one that lives in the ServiceNow application (referred to as TopFrame) and this API that is sourced from the partner application. This API has the necessary methods to communicate with TopFrame and control the visual features of the OpenFrame.
 * 
 * 
 */
declare class openFrameAPI {



    /**
     * Hides the OpenFrame in the TopFrame.
     * 
     * @example
     * openFrameAPI.hide()
     */
    hide();

    /**
     * Initialize OpenFrame, must be the first method called.This method initializes communication to TopFrame and initializes any visual elements passed in the config parameter.
     * 
     * @config An object of key value pairs. The possible keys are height, width, title, subTitle, and titleIcon. All keys are optional.
     * @successCallback The callback function used if the init method succeeds. The openframe configuration stored in the system is passed as a parameter to the callback function.
     * @failureCallback The callback function used if the init method fails.
     * @example
     * var config = {
     * height: 300,
     * width: 200
     * }
     * function handleCommunicationEvent(context) {
     * console.log("Communication from Topframe", context);
     * }
     * function initSuccess(snConfig) {
     * console.log("openframe configuration",snConfig);
     * //register for communication event from TopFrame
     * openFrameAPI.subscribe(openFrameAPI.EVENTS.COMMUNICATION_EVENT,
     * handleCommunicationEvent);
     * }
     * function initFailure(error) {
     * console.log("OpenFrame init failed..", error);
     * }
     * openFrameAPI.init(config, initSuccess, initFailure);
     */
    init(config: Object, successCallback: function, failureCallback: function);

    /**
     * Checks to see if the OpenFrame is visible in the TopFrame.
     * 
     * @callback The callback function receives a parameter with a value of true or false. True if OpenFrame is visible and false if not visible.
     * @example
     * function callback(isVisible) {
     * console.log(isVisible)
     * }
     * openFrameAPI.isVisible(callback)
     */
    isVisible(callback: function);

    /**
     * Opens a form URL in TopFrame.
     * 
     * @details An object of key value pairs. The possible keys are entity, the table name query, an encoded query string 
     * @example
     * openFrameAPI.openServiceNowForm({entity:'case', query:'sys_id=1234567'});
     */
    openServiceNowForm(details: Object);

    /**
     * Opens a list URL in TopFrame.
     * 
     * @details An object of key value pairs. The possible keys are entity, the table name query, an encoded query string 
     * @example
     * openFrameAPI.openServiceNowList({entity:'case', query:'active=true'});
     */
    openServiceNowList(details: Object);

    /**
     * The OpenFrame header can include icons that are placed next to the close icon.
     * 
     * @icons A list of icon configurations, where each icon configuration is an object with key values imageURL, imageTitle, and any other needed context.
     * @example
     * openFrameAPI.setIcons([{imageURL:'https://mydomian.com/image/mute.png',
     * imageTitle:'mute', id:101}, {imageURL:'https://mydomian.com/image/hold.png',
     * imageTitle:'hold', id:102}]);
     */
    setIcons(icons: Array<any>);

    /**
     * Sets the OpenFrame size.
     * 
     * @width Should be greater than zero.
     * @height Should be greater than zero.
     * @example
     * openFrameAPI.setSize(300, 370);
     */
    setSize(width: Number, height: Number);

    /**
     * Sets the OpenFrame subtitle.
     * 
     * @subTitle A string of 256 or fewer characters.
     * @example
     * openFrameAPI.setSubtitle('+18888888888');
     */
    setSubtitle(subTitle: String);

    /**
     * Sets the OpenFrame title.
     * 
     * @title A string of 256 or fewer characters.
     * @example
     * openFrameAPI.setTitle('Incoming Call');
     */
    setTitle(title: String);

    /**
     * Sets the OpenFrame's title icon.
     * 
     * @icon Object of key value pairs. Keys include imageURL, imageTitle, and any other context needed.
     * @example
     * openFrameAPI.setTitleIcon({imageURL:'/my/image/path.png', imageTitle:'mute', id:101});
     * @example
     * openFrameAPI.setTitleIcon({imageURL:'https://mydomian.com/image/path.png',
     * imageTitle:'mute', id:101});
     */
    setTitleIcon(icon: Object);

    /**
     * Makes the OpenFrame visible in the TopFrame.
     * 
     * @example
     * openFrameAPI.show()
     */
    show();

    /**
     * Subscribes to the event.These events are available. openframe_icon_clicked -- this event occurs when any icon other than the close icon is clicked on the OpenFrame footer. The callback receives the icon object as a parameter. This event replaces openframe_header_icon_clicked. openframe_header_icon_clicked -- this event occurs when any icon other than the close icon is clicked on the OpenFrame header. The callback receives the icon object as a parameter. This event works but should be replaced with openframe_icon_clicked. openframe_shown -- this event occurs when the OpenFrame is shown. openframe_hidden -- this event occurs when the OpenFrame is hidden. openframe_before_destroy -- this event occurs before the TopFrame is unloaded. openframe_communication -- this event is application specific and can be customized. openframe_communication_failure -- this event occurs when communication to TopFrame fails. openframe_collapse -- this event occurs when the collapse icon is clicked on the OpenFrame header. openframe_expand -- this event occurs when the expand icon is clicked on the OpenFrame header. 
     * 
     * @event One of the available events.
     * @eventCallback The method called when the specified event occurs.
     * @example
     * function handleIconClick(context) {
     * console.log("Icon was clicked", context);
     * }
     * openFrameAPI.subscribe(openFrameAPI.EVENTS.ICON_CLICKED, handleIconClick);
     */
    subscribe(event: openFrameAPIEVENT, eventCallback: function);

    /**
     * Returns the OpenFrame API version.
     * 
     * @example
     * var version = openFrameAPI.version();
     * 
     * console.log("API version " + version);
     * @returns The OpenFrame API version
     */
    version(): String;

}

/**
 * The PADomainUtils API enables you to copy Performance Analytics configurations between different domains on the same instance. Use this API in server scripts to copy Performance Analytics configuration records, such as indicators, breakdowns, and dashboards, to different domains. This API enables you to create a Performance Analytics configuration in one domain and copy that configuration to any number of additional domains.Note: This API cannot copy records into the Global domain. * * To use PADomainUtils, you must satisfy these requirements: Performance Analytics must be enabled. The user running the script must have the admin role. The instance must use domain separation. The script must be run from the global domain. When moving or copying records, the source and target domains must be different. 
 * 
 * 
 */
declare class PADomainUtils {



    /**
     * Instantiates a new PADomainUtils object to move or copy Performance Analytics configuration records from the specified domain.Use the PADomainUtils() constructor instead when moving or copying from the global domain.
     * 
     * @domainFrom The domain to copy records from.
     * @example
     * // c90d4b084a362312013398f051272c0d is the sys id of the ACME domain
     * var acmeUtils = new SNC.PADomainUtils('c90d4b084a362312013398f051272c0d');
     */
    constructor(domainFrom: String);

    /**
     * Instantiates a new PADomainUtils object to move or copy Performance Analytics configuration records from the global domain.Use the PADomainUtils(String domainFrom) constructor instead when moving or copying records from a domain other than the global domain.
     * 
     * @example
     * // PADomainUtils initialized with the global domain
     * var globalUtils = new SNC.PADomainUtils();
     */
    constructor();

    /**
     * Copies Performance Analytics configuration records to a different domain.To copy dashboards or scheduled jobs, see copyDashboard and copyJob.
     * 
     * @runAs The user whose domain you want to copy records to.
     * @example
     * // copy all the Performance Analytics records from global to user's domain
     * var pa = new SNC.PADomainUtils();
     * pa.copy('09ff3d105f231000b12e3572f2b4775d');
     */
    copy(runAs: String);

    /**
     * Copy a dashboard to another domain.
     * 
     * @dashboardId The sys_id of the dashboard to copy.
     * @runAs The user whose domain you want to copy the dashboard to.
     * @example
     * //Copy Incident Management dashboard from global to user's domain
     * var pa = new SNC.PADomainUtils();
     * pa.copyDashboard('a64b7031d7201100b96d45a3ce610335','09ff3d105f231000b12e3572f2b4775d');
     */
    copyDashboard(dashboardId: String, runAs: String);

    /**
     * Copies a Performance Analytics scheduled data collection job record to another domain.
     * 
     * @paJob The sys_id of a Performance Analytics scheduled data collection job [sysauto_pa] record.
     * @runAs The user whose domain you want to copy the job to.
     * @example
     * // No source domain needs to be set
     * var pa = new SNC.PADomainUtils();
     * // copy the OOTB '[PA Incident] Daily Data Collection job'
     * // set the 'run as' of the new record to be the 'acme.itil' user
     * // first argument is the sys_id of the sysauto_pa record
     * // the second is the sys_id of the acme.itil user record
     * pa.copyJob('82ba2023d7101100b96d45a3ce6103cd','797d14341f1310005a3637b8ec8b7010');
     * @returns An error message if an error occurs, or an empty string if there is no error.
     */
    copyJob(paJob: String, runAs: String): String;

    /**
     * Evaluate if you can write to a specific record identified by table and sys_id.
     * 
     * @table The name of the table containing the record to query, such as pa_indicators.
     * @id The sys_id of the record to query.
     * @example
     * var pa = new SNC.PADomainUtils();
     * pa.isWriteable('pa_incidents','cd8125b5140012007665a83e633b028d');
     * @returns Indicates that you can write to the specified record. Returns true if the record exists within the domain of the current user. Returns false if the record does not exist, or is in a different domain.
     */
    isWriteable(table: String, id: String): Boolean;

    /**
     * Moves Performance Analytics configuration records to a different domain.
     * 
     * @runAs The user whose domain you want to copy records to.
     * @example
     * // move all the Performance Analytics records from the global to the customers domain
     * var pa = new SNC.PADomainUtils();
     * pa.move('774190f01f1310005a3637b8ec8b70ef')
     */
    move(runAs: String);

    /**
     * Use this method to move or copy only foundation records in a hybrid domain configuration.You can implement a hybrid configuration by maintaining some types of record in a parent domain and some types in child domains. Records maintained in the parent domain are known as foundation records. The following types of record are considered foundation records. Bucket groups Buckets Scripts Breakdown sources Indicator sources Filters Breakdowns Managed sources Manual breakdowns Breakdown mappings Breakdown relations Other Performance Analytics configuration records such as widgets and indicators are not foundation records. Set this method to false to move or copy these additional records as well.
     * 
     * @foundation Indicates if only foundation records should be copied or moved by this PADomainUtils object.
     * @example
     * var pa = new SNC.PADomainUtils().setFoundation(true);
     * pa.copy('bb6b58b01f1310005a3637b8ec8b70dd');
     * @returns The object calling this function.
     */
    setFoundation(foundation: Boolean): PADomainUtils;

    /**
     * Use this method before copying records to set the sys_override value of the new record to the original parent record.Using this method enables you to automatically override records in a parent domain. By overriding the parent records, the parent records do not impact the child domain. If the source domain is not the parent of the target domain when copying records, setting the sys_override value will not have any impact on behavior. You can specify an override only when copying records, not when moving records.
     * 
     * @overrides Indicates that copied records in a child domain should override the source record in the parent domain. This value is true by default.
     * @example
     * var pa = new SNC.PADomainUtils('c90d4b084a362312013398f051272c0d');
     * pa.setOverrides(false);
     * pa.copy('bb6b58b01f1310005a3637b8ec8b70dd');
     * @returns The object calling this function.
     */
    setOverrides(overrides: Boolean): PADomainUtils;

}

/**
 * Configures a CIM probe. Use in any server-side script where you need to configure a CIM probe.
 * 
 * 
 */
declare class ProbeHandlerCim {



    /**
     * Returns a string containing the CIM fields to fetch
     * 
     * @returns The CIM fields to fetch
     */
    getCimQueries(): String;

    /**
     * Returns the CIM name space.
     * 
     * @returns The name space
     */
    getNamespace(): String;

    /**
     * Returns a hash map of the parameters added by this probe handler.
     * 
     * @returns A hash map of the parameters
     */
    getParameters(): String;

    /**
     * Runs the probe.
     * 
     */
    run();

    /**
     * Sets the probe parameters.
     * 
     * @params The parameters to add
     */
    setProbeParameters(params: Object);

}

/**
 * Probe handler for MultiProbes. This script include does not work with probe parameters that have value_scripts and does not work with JavaScript probes. * * Use in any server-side script where you need to configure a MultiProbe.
 * 
 * 
 */
declare class ProbeHandlerMulti {



    /**
     * Adds the probe parameters to the given XML parent element, taken from the given probe's parameter table.
     * 
     * @parent The XML parent element to add parameters to.
     * @sysID The sys_id of the probe to get parameters from.
     * @probe Optional GlideRecord of the probe. If present, and there is a probe handler, it is called.
     */
    addParameters(parent: String, sysID: String, probe: GlideRecord);

    /**
     * Adds the probes for this multiprobe to the document.
     * 
     * @parent The XML parent element to add the probes to.
     * @sysID The sys_id of the multi-probe
     */
    addProbes(parent: String, sysID: String);

    /**
     * Runs the probe.
     * 
     */
    run();

    /**
     * If the given probe's GlideRecord is present and contains a probe handler, runs the probe handler and adds any parameters it creates to the given parameter element.
     * 
     * @params The XML parameter element to add parameters to.
     * @sysID The sys_id of the probe to get parameters from.
     * @probe Optional GlideRecord of the probe. If present, and there is a probe handler, it is called.
     */
    runProbeHandler(params: String, sysID: String, probe: GlideRecord);

    /**
     * Sets the value of a given XML parameter element.
     * 
     * @parent The XML parent element to add the parameter to.
     * @name The name of the parameter to set
     * @value The value to set the parameter to.
     */
    setParameter(parent: String, name: String, value: String);

}

/**
 * Discovery probe handler for SNMP probes, invoked when an SNMP probe is about to be created. Use in any server-side script where you need to configure an SNMP probe.
 * 
 * 
 */
declare class ProbeHandlerSNMP {



    /**
     * Adds a boolean value to the parameter map.
     * 
     * @dbName The database name
     * @paramName The parameter name
     * @paramMap The parameter map
     */
    addBoolean(dbName: String, paramName: String, paramMap: String);

    /**
     * Adds debugging to the probe handler.
     * 
     * @paramMap The parameter map
     */
    addDebug(paramMap: String);

    /**
     * Adds a JavaScript handler.
     * 
     * @paramMap The parameter map
     */
    addJavascriptHandlers(paramMap: String);

    /**
     * Adds OID automatic resolution.
     * 
     * @paramMap The parameter map
     */
    addOIDAutoResolve(paramMap: String);

    /**
     * Adds OID specifications to the parameter map.
     * 
     * @paramMap The parameter map
     */
    addOIDSpec(paramMap: String);

    /**
     * Adds a sensor handler.
     * 
     * @paramMap The parameter map
     */
    addSensorHandler(paramMap: String);

    /**
     * Adds the stage to the parameter map.
     * 
     * @paramMap The parameter map
     */
    addStage(paramMap: String);

    /**
     * Adds timing specifications to the parameter map.
     * 
     * @paramMap The parameter map
     */
    addTimingSpecs(paramMap: String);

    /**
     * Returns the parameters added by this probe handler.
     * 
     * @returns A hash map of the parameters added by this probe handler.
     */
    getParameters(): String;

    /**
     * Runs the probe.
     * 
     */
    run();

    /**
     * Sets the value of a given XML parameter element.
     * 
     * @params The probe's parameters
     */
    setProbeParameters(params: String);

}

/**
 * Discovery probe handler for WMI probes. Use in any server-side script where you need to configure an WMI probe.
 * 
 * 
 */
declare class ProbeHandlerWMI {



    /**
     * Returns the parameters added by this probe handler.
     * 
     * @returns A hash map of the parameters added by this probe
     */
    getParameters(): String;

    /**
     * Generates a string containing the WMI fields to fetch.
     * 
     * @returns The WMI fields to fetch.
     */
    getWMIFields(): String;

    /**
     * Runs the probe.
     * 
     */
    run();

    /**
     * Sets the probe parameters.
     * 
     * @params The probe parameters
     */
    setProbeParameters(params: Object);

}

/**
 * Use the Queue API (Advanced Work Assignment) to route a document to a queue. The Queue API is provided within the sn_awa namespace. * * Requires the following: Advanced Work Assignment plugin (com.glide.awa) Role: awa_integration_user or admin 
 * 
 * 
 */
declare class Queue {



    /**
     * Gets a queue record by sys_id.
     * 
     * @queue_id Represents sys_id of queue record from awa_queue table
     * @example
     * var queue = sn_awa.Queue.get("&lt;queue_id&gt;");
     * var workItem = queue.route({ 
     *     document_sys_id: "&lt;sys_id&gt;",
     *     document_table: "&lt;table&gt;"
     * });
     * @returns True if queue record exists, false otherwise.
     */
    get(queue_id: String): Boolean;

    /**
     * Routes an active work item to the queue object.If an active work item does not exist for the specified document, this method creates a work item and set its fields accordingly.
     * 
     * @options Contains document sys_id and table associated with work item: document_sys_id: "&lt;sys_id&gt;" document_table: "&lt;table&gt;", e.g., interaction 
     * @example
     * var queue = sn_awa.Queue.get("&lt;queue_id&gt;");
     *         var workItem = queue.route({ 
     *         document_sys_id: "&lt;sys_id&gt;",
     *         document_table: "&lt;table&gt;"
     * });
     * @returns True if successful, error message otherwise.
     */
    route(options: Object): Boolean;

}

/**
 * Generates IP network, range, and address entries from a convenient comma-separated input field using conventional CIDR network notation, hyphenated range entries, or individual IP addresses. Use with any server-side discovery script.
 * 
 * 
 */
declare class QuickRanges {



    /**
     * Creates a new discovery range item.
     * 
     * @table The table where the item will be created.
     * @id The identifier to use for the new item.
     * @type The type of entries to generate: IP address, IP network, or IP range.
     * @returns The created entry
     */
    createItem(table: String, id: String, type: String): GlideRecord;

    /**
     * Returns the IP network, range, and address information to use when generating the entries.
     * 
     */
    onMakeRanges();

}

/**
 * A utility class to turn a record into HTML. The RecordToHTML class is available to server-side scripts.
 * 
 * 
 */
declare class RecordToHTML {



    /**
     * Creates an instance of RecordToHTML class.
     * 
     * @table The record's table name
     * @sys_id The sys_id of the record
     * @pattern The pattern of the string to generate. The pattern may include ${} escapes for fields whose values should be included. For example, the pattern "sys_id: ${sys_id}" would substitute the actual sys_id for the escape.
     * @link  
     * @example
     * var r2html = new RecordToHTML("incident","e8e875b0c0a80164009dc852b4d677d5", 
     *         "incident: ${number}-${short_description}", true);
     * gs.print(r2html.toString());
     */
    constructor(table: String, sys_id: String, pattern: String, link: Boolean);

    /**
     * Sets the specified field to the specified value.
     * 
     * @fieldName Name of the field to change.
     * @value Value to set the field to.
     * @example
     * var r2html = new RecordToHTML("incident","e8e875b0c0a80164009dc852b4d677d5", "incident: ${number}-${short_description} (${user})", true);
     * r2html.setValue("user",gs.getUserName());
     * gs.print(r2html.toString())
     */
    setValue(fieldName: String, value: String);

    /**
     * Converts the record to a string.
     * 
     * @example
     * var r2html = new RecordToHTML("incident","e8e875b0c0a80164009dc852b4d677d5", 
     *                           "incident: ${number}-${short_description}", true);
     * gs.print(r2html.toString());
     * @returns HTML output of the record.
     */
    toString(): String;

}

/**
 * The RenderProperties API provides methods about the current page and is available in Jelly scripts and in UI-action conditions and scripts. Access RenderProperties methods using the static variable RP.
 * 
 * 
 */
declare class RenderProperties {



    /**
     * Returns the encoded query from the URL sent to the page.
     * 
     * @returns Returns the encoded query from the URL sent to the form.
     */
    getEncodedQuery(): String;

    /**
     * Returns the list control object for the page.
     * 
     * @returns The list control object for the page.
     */
    getListControl(): SysListControlobject;

    /**
     * Returns the value of the specified URL parameter.
     * 
     * @parameterName Name of the parameter passed on the URL.
     * @returns The parameter's value.
     */
    getParameterValue(parameterName: String): String;

    /**
     * Returns the URL where the request originated.
     * 
     * @returns The URL of the page where the request originated.
     */
    getReferringURL(): String;

    /**
     * Returns the view the page is using.This method is not available in scoped applications.
     * 
     * @returns The sys_id of the view being used.
     */
    getViewID(): String;

    /**
     * Returns the name of the view in use.
     * 
     * @returns The name of the view being used.
     */
    getViewName(): String;

    /**
     * Returns the window's properties.
     * 
     * @returns The window's properties
     */
    getWindowProperties(): Object;

    /**
     * Returns true if the page is part of Studio.
     * 
     * @returns Returns true if the page is part of Studio.
     */
    isInDevStudio(): Boolean;

    /**
     * Returns true if this is an interactive session. An interactive session is when a user has logged in as opposed to a REST request.
     * 
     * @returns True if this is an interactive session.
     */
    isInteractive(): Boolean;

    /**
     * Returns true when the sysparm_collection_related_file URL parameter is set.
     * 
     * @returns Returns true when the sysparm_collection_related_file URL parameter is set.
     */
    isManyToMany(): Boolean;

    /**
     * Returns true when the sys_is_related_list URL-parameter is true. Returns false if the parameter is not present.
     * 
     * @returns True if the URL parameter sys_is_related_list is true.
     */
    isRelatedList(): Boolean;

}

/**
 * Handles all the details of rounding intervals for CPU speed and RAM size. Use in any server-side Discovery script.
 * 
 * 
 */
declare class RoundingInterval {



    /**
     * Creates an instance of the RoundingInterval class.
     * 
     * @type Can be either CPU or RAM.
     */
    constructor(type: String);

    /**
     * Returns the value after applying the rounding interval.
     * 
     * @value The value to round off
     * @returns The value after rounding
     */
    getRoundedValue(value: Number): Number;

}

/**
 * Manages the serial numbers for discovery devices. Use with a discovery script where you need to manage serial numbers.
 * 
 * 
 */
declare class SerialNumberManager {



    /**
     * Adds the specified serial number.
     * 
     * @sType The serial number type
     * @value The serial number
     */
    add(sType: Number, value: Number);

    /**
     * Returns the serial number.
     * 
     * @returns The serial number
     */
    get(): Number;

    /**
     * Returns serial number information for CI Data, including the type, serial number, and validity.
     * 
     * @returns An array with the serial number information in the following order: serial number type, serial number, and validity flag.
     */
    getSerialsForCIData(): Array<any>;

    /**
     * Checks if the number is a valid serial number.
     * 
     * @value The number to check
     * @returns True if the number is valid; otherwise, false.
     */
    isValid(value: Number): Boolean;

}

/**
 * Maps Shazzam service registry query results against a port probe. Child classes provide specifics on mapping. Use this API during the discovery scanning phase.
 * 
 * 
 */
declare class ServiceRegistryQuery {



    /**
     * Creates an instance of the ServiceRegistryQuery class.
     * 
     * @source A GlideRecord or sys_id of the registry service.
     */
    constructor(source: Object);

    /**
     * Parses an array of IDs for the given port probe.
     * 
     * @portProbe The port probe
     */
    findForPortProbe(portProbe: PortProbe);

    /**
     * Retrieves a registry service by id, regardless of child class.
     * 
     * @source The registry service GlideRecord or sys_id.
     * @returns The registry service
     */
    get(source: Object): String;

    /**
     * Returns the Shazzam! querier class name.
     * 
     * @returns The class name
     */
    getShazzamQuerierClassname(): String;

    /**
     * Retrieves the port probe XML and creates a map.
     * 
     * @returns The port probe map
     */
    toPortProbeMap(): String;

    /**
     * Creates XML output for Shazzam! port probes.
     * 
     * @returns The XML output for the probe.
     */
    toPortProbeXml(): String;

}

/**
 * Handles the details of launching a Shazzam probe for a given discovery. Use this API to launch a Shazzam probe during the discovery scanning phase.
 * 
 * 
 */
declare class ShazzamLaunch {



    /**
     * Creates an instance of the Shazzamlaunch class.
     * 
     * @status The DiscoveryStatus instance for this discovery.
     * @schedule The DiscoverySchedule instance for this discovery.
     */
    constructor(status: DiscoveryStatus, schedule: DiscoverySchedule);

    /**
     * Adds a single port probe to our MID services collection.
     * 
     * @midPPs A hashmap with two properties. midServer: a MIDServer instance portProbes: a hashmap (by port probe name) of DiscoveryPortProbe instances. 
     * @portProbes A hashmap (byMIDServer name) that contains these properties. range: An IPMetaCollection containing the ranges to be probed. midserver: A MIDServer instance for the MID server to be probed. portProbes: a hashmap (by port probe name) of DiscoveryPortProbe instances to be probed. 
     * @ipiec The range to be probed.
     */
    addPortProbe(midPPs: String, portProbes: String, ipiec: IPIncludeExcludeCollection);

    /**
     * Adds the specified range and this discovery's port probes to scan (as defined by behavior) to the collection of MID servers and port probes that need to be probed.
     * 
     * @ipc The range to be discovered
     * @portProbes A hashmap (by MID server name) of hashmaps containing these properties. range: an IPMetaCollection containing the ranges to be probed. midServer: a Mid server instance for the MID server to be probed. portProbes: a hashmap (by port probe name) of DiscoveryPortProbe instances to be probed. 
     * @samePhase True if this should use the same phase as is currently running.
     */
    addRange(ipc: IPCollection, portProbes: String, samePhase: Boolean);

    /**
     * Fires a Shazzam probe for the MID server and services in the given hash map.
     * 
     * @portProbe A hashmap containing these properties. range: an IPMetaCollection containing the ranges to be probed. midServer: a MIDServer instance for the MID server to be probed. 
     * @ip A comma-separated list of IPs to fire probes for.
     * @sensor The sys_id of the sensor that launched this probe (network discovery only).
     */
    fireShazzamProbe(portProbe: String, ip: String, sensor: String);

    /**
     * Launches Shazzam probes as necessary, depending on the current phase of each behavior used.
     * 
     * @ip A comma-separated list of IPs to fire probes for.
     * @samePhase True if this launch should use the same phase as is currently running.
     * @sensor The sys_id of the sensor that launched this (only in network discovery).
     * @returns True if any probes are launched.
     */
    launch(ip: String, samePhase: Boolean, sensor: String): Boolean;

    /**
     * Makes an XML port probe spec for the given port probe hashmap.
     * 
     * @portProbe A hashmap containing these properties. range: an IPMetaCollection containing the ranges to be probed. midServer: a MIDServer instance for the MID server to be probed. portProbes: a hashmap (by port probe name) of DiscoveryPortProbe instances to be probed. 
     * @returns An XML port probe specification
     */
    makeProbeSpec(portProbe: String): String;

}

/**
 * Encapsulates a Shazzam result. Use this API during the discovery scanning phase.
 * 
 * 
 */
declare class ShazzamResult {

    /** Property that shows if the IP address is active */
    active: Boolean
    /** Property is true if this IP address is alive, which means no ports are open, but at
    least one responded. */
    alive: Boolean
    /** The Windows domain name for the IP. */
    domainName: String
    /** Host name for the IP. */
    hostName: String
    /** IP address of the results. */
    ip: String
    /** A JavaScript array of ShazzamScanner instances. */
    scanners: Array<any>


}

/**
 * Encapsulates a Shazzam scanner. Use this API during the discovery scanning phase.
 * 
 * 
 */
declare class ShazzamScanner {

    /** A hash map of any nodes contained within the scanner, by name. */
    contents: Hashmap
    /** The Windows domain name, if one was resolved by the scanner. */
    domainName: String
    /** The IP hostname, if one was resolved by the scanner. */
    hostName: String
    /** The scanner name. */
    name: String
    /** The port being scanned. */
    port: String
    /** The port probe name. */
    portProbe: String
    /** The scanner protocol. */
    protocol: String
    /** The scanner result. */
    result: String
    /** The scanner service name. */
    service: String


}

/**
 * The SLARepair API first deletes the existing SLAs and then recreates them from each task's history. 
 * 
 * 
 */
declare class SLARepair {



    /**
     * Repair the task SLAs associated with the passed-in filter and source table.
     * 
     * @filter Specify an encoded query that is used to retrieve a set of records from the source table.
     * @sourceTable Specify the name of a table that is (or extends) contract_sla, task_sla, or task.
     * @example
     * var gr = new GlideRecord("problem");
     * gr.addQuery("sys_created_on", "ON", "Last Month@javascript:gs.beginningOfLastMonth()@javascript:gs.endOfLastMonth()");
     * gr.addQuery("priority", "2");
     * gr.query();
     * 
     * var repair = new SLARepair();
     * while (gr.next()) 
     *     repair.repairByFilter(gr.getEncodedQuery(), gr.getRecordClassName());
     */
    repairByFilter(filter: string, sourceTable: string);

    /**
     * Repair the task SLAs associated with the passed in GlideRecord.
     * 
     * @gr Specify a GlideRecord for a table that is (or extends) contract_sla, task_sla, or task.
     * @example
     * var gr = new GlideRecord("problem");
     * gr.addQuery("sys_created_on", "ON", "Last Month@javascript:gs.beginningOfLastMonth()@javascript:gs.endOfLastMonth()");
     * gr.addQuery("priority", "2");
     * gr.query();
     * 
     * var repair = new SLARepair(); 
     * while (gr.next()) 
     *     repair.repairByGlideRecord(gr);
     */
    repairByGlideRecord(gr: GlideRecord);

    /**
     * Repair the task SLAs associated with the passed in sys_id and source table.
     * 
     * @sysId Specify the ID of a table that is (or extends) contract_sla, task_sla, or task.
     * @sourceTable Specify the name of a table that is (or extends) contract_sla, task_sla, or task.
     * @example
     * var gr = new GlideRecord("problem");
     * gr.addQuery("sys_created_on", "ON", "Last Month@javascript:gs.beginningOfLastMonth()@javascript:gs.endOfLastMonth()");
     * gr.addQuery("priority", "2");
     * gr.query();
     * 
     * var repair = new SLARepair();
     * while (gr.next())
     *     repair.repairBySysId(gr.sys_id + "",  gr.getRecordClassName());
     * 
     */
    repairBySysId(sysId: string, sourceTable: string);

    /**
     * Enables or disables auditing when running a repair.By default, auditing is set to the value in the property com.snc.sla.repair.audit. You can override this with passing in true to enable or false to disable auditing.
     * 
     * @onOrOff Determines whether to enable or disable auditing.
     * @example
     * var builder = new SLARepair();
     *   builder.setAuditEnabled(true);
     * 
     * @returns A self-reference to allow for method chaining.
     */
    setAuditEnabled(onOrOff: Boolean): this;

    /**
     * Enables or disables running a workflow for each of the Task SLA records being repaired.By default, when a Task SLA is repaired the workflow will be run during the repair process. To override this, you can pass in false to disable running of the workflow or true to enable it.
     * 
     * @onOrOff Determines whether to enable or disable workflow.
     * @example
     * var repair = new SLARepair();
     * repair.setRunWorkflow(false);
     * @returns A self-reference to allow for method chaining.
     */
    setRunWorkflow(onOrOff: Boolean): this;

    /**
     * Validates the repair request.If false is passed in, the task SLAs will be repaired. If true is passed in, calls to repair will not alter any task SLAs but only validate the supplied parameters and generate a count of records to be repaired.
     * 
     * @onOrOff Determines whether to enable or disable validation.
     * @example
     * var repair = new SLARepair();
     *   repair.setValidateOnly(true);
     * @returns A self-reference to allow for method chaining.
     */
    setValidateOnly(onOrOff: Boolean): this;

}

/**
 * Maps Shazzam! SLP query results to port probes. Use this API during the discovery scanning phase.
 * 
 * 
 */
declare class SLPServiceRegistryQuery {



    /**
     * Returns the Shazzam querier class name.
     * 
     * @returns The class name
     */
    getShazzamQuerierClassname(): String;

    /**
     * Creates a scalar map for port probes to use in XML output to Shazzam!.
     * 
     * @returns The scalar map
     */
    toPortProbeMap(): Object;

}

/**
 * Handles gathering the parts of an SNMP response document for JavaScript SNMP sensors. Use with a discovery script when you need to gather the parts of an SNMP response document.
 * 
 * 
 */
declare class SNMPGatherDocParts {



    /**
     * Returns the given XML document with any data gathered by prior SNMP probes.
     * 
     * @doc The XML document for this sensor
     * @probe The probe instance
     * @returns The XML document with the gathered data.
     */
    gather(doc: String, probe: Object): String;

}

/**
 * Creates network interfaces for JavaScript SNMP sensors. Use with a discovery script when you need to create network interfaces for JavaScript SNMP sensors.
 * 
 * 
 */
declare class SNMPNetworkInterfaces {



    /**
     * Analyzes the SNMP data and reconciles the discovered NICs to the CMDB's NICs.
     * 
     * @cmdb_ci The sys_id of the CI
     * @doc The SNMP data in XML form
     * @isComputer If true, this is a computer; otherwise, false.
     * @agentName Name of the MID server
     * @ecc_sys_id The sys_id of the ECC queue record with the input.
     */
    process(cmdb_ci: String, doc: String, isComputer: Boolean, agentName: String, ecc_sys_id: String);

}

/**
 * Wraps an SNMP payload response instance with methods to safely and easily retrieve SNMP singleton fields or tables. Use to retrieve SNMP singleton fields or tables.
 * 
 * 
 */
declare class SNMPResponse {



    /**
     * Builds an index to all SNMP entities in the current object.
     * 
     * @cur The current object
     * @name The index name
     * @extName The index extension
     */
    buildIndex(cur: Object, name: String, extName: String);

    /**
     * Builds references to actual instances for all identified indexes (in the discovery_snmp_ref table) that can be resolved.
     * 
     */
    buildReferences();

    /**
     * Returns an array of OIDs that match the given ref_base and which have a defined, non-null ref_leaf.The last character of ref_base may be a question mark; in that case, if the parent node is a table then all table entries are returned.
     * 
     * @refBase The reference base
     * @refLeaf The reference leaf
     * @returns An array of OIDs that match the given ref_base and which have a defined, non-null ref_leaf.
     */
    getAmbiguousOIDs(refBase: String, refLeaf: String): Array<any>;

    /**
     * Returns the integer contained in the OID object with the given MIB name.
     * 
     * @name The MIB name
     * @returns The integer contained in the OID object, or zero if the object could not be found or is empty.
     */
    getOIDInt(name: String): Number;

    /**
     * Retrieves the OID object with the given MIB name from the response.This method does not work with numeric OID strings, only MIB names.
     * 
     * @name The MIB name
     * @returns The OID object with the given MIB name, or null if the object could not be found or if any table entries are encountered while walking down the named elements.
     */
    getOIDObj(name: String): OIDobject;

    /**
     * Returns a hashmap of table entries under the given parent MIB name, with the given entry MIB names.
     * 
     * @parentName The parent MIB name
     * @entryName The entry MIB name
     * @returns A hashmap of table entries under the given parent MIB name, with the given entry MIB names, or null if the parent does not exist.
     */
    getOIDTable(parentName: String, entryName: String): Hashmap;

    /**
     * Returns the text contained in the OID object with the given MIB name.
     * 
     * @name The MIB name
     * @returns The text contained in the OID object. Returns null if the object could not be found, or if it has no text.
     */
    getOIDText(name: String): String;

    /**
     * Resolves SNMP tables into hashmaps and OID values into primitives.All SNMP numeric types convert to a JavaScript number. An SNMP null type converts to a JavaScript null. An SNMP IP Address value converts to a Java IPAddressV4 instance. All other values convert to a JavaScript string.
     * 
     * @cur The SNMP table or OID value.
     */
    normalize(cur: Object);

}

/**
 * Starts discovery jobs. Use this API during the discovery scanning phase.
 * 
 * 
 */
declare class StartDiscovery {



    /**
     * Adds an IP (or comma-separated list of IPs) to an existing discovery (used by networks discovery).
     * 
     * @status The discovery status
     * @ip An IP address, or a comma-separated list of IP addresses.
     * @sensor The discovery sensor
     */
    addAdditionalIP(status: String, ip: String, sensor: String);

    /**
     * Handles discovery of devices (whether basic or advanced) from a schedule.
     * 
     * @ip An IP address, or a comma-separated list of IP addresses.
     * @samePhase  
     * @sensor The discovery sensor
     */
    discoverFromSchedule(ip: String, samePhase: Boolean, sensor: String);

    /**
     * Returns the cancel script.
     * 
     * @returns The cancel script
     */
    getCancelScript(): String;

    /**
     * If the schedule specifies a cancel time, schedules a job to cancel if necessary.
     * 
     */
    scheduleCancelJob();

    /**
     * Starts a discovery for a single IP using the specified schedule to get information such as MID servers and behaviors.
     * 
     * @schedule A DiscoverySchedule instance for the schedule to use.
     * @ip The IP address to discover in a dot-formatted string.
     * @returns The sys_id of the status record created.
     */
    startFromIP(schedule: DiscoverySchedule, ip: String): String;

    /**
     * Invoked by the discovery script include to kick off a scheduled (or discover now) discovery.
     * 
     * @schedule The instance of discovery_schedule that this discovery is based on.
     * @job The instance of sys_trigger that triggered this discovery.
     */
    startFromSchedule(schedule: GlideRecord, job: GlideRecord);

}

/**
 * Provides a set of methods for manipulating CI operational states and applying CI actions. The StateManagementScriptableApi methods adhere to restrictions and allowances specified by not allowed CI actions, compatible CI actions, and not allowed operational transitions. If a method attempts to perform a restricted operation, the operation is blocked, an error is logged, and a task is created if appropriate. * * The StateManagementScriptableApi methods are static methods. You access the methods using the SNC.StateManagementScriptableApi global object.
 * 
 * 
 */
declare class StateManagementScriptableApi {



    /**
     * Add a CI action to a list of CIs.
     * 
     * @requestorId A sys_id of a workflow context, or the GUID returned from the registerOperator() method.
     * @sysIdList A list comma separated list of CI sys_ids.
     * @ciActionName The CI action name.
     * @ciActionListOld (Optional) A comma separated list of old CI actions that all CIs should be in.
     * @leaseTime (Optional) Time duration for which the lease is valid for specified CI Action. In the format HH:MM:SS.
     * @returns A JSON formatted string with name-value pairs for result - true if the action is set for all CIs in the list; otherwise, false. errors - list of errors. 
     */
    addBulkCIAction(requestorId: String, sysIdList: String, ciActionName: String, ciActionListOld: String, leaseTime: String): String;

    /**
     * Extend the CI-action-lease time for the registered user. If the previous lease has expired, the new lease time starts now.
     * 
     * @requestorId A sys_id of a workflow context, or the GUID returned from the registerOperator() method.
     * @ciSysId The CI's sys_id.
     * @ciActionName The CI action name.
     * @leaseTime Time duration for which the lease is valid for specified CI Action. In the format HH:MM:SS.
     * @returns A JSON formatted string with name-value pairs for result - true if the lease time has been set. errors - list of errors. 
     */
    extendCIActionLease(requestorId: String, ciSysId: String, ciActionName: String, leaseTime: String): String;

    /**
     * Returns a list of active CI actions for the specified CI.
     * 
     * @ciSysId The sys_id of the CI
     * @returns A JSON formatted string with name-value pairs for ciActions - a comma separated list of active CI actions for the CI, or NO_ACTIVE_ACTION. errors - list of errors. 
     */
    getCIActions(ciSysId: String): String;

    /**
     * Returns the CI's operational state.
     * 
     * @ciSysId Sys_id of the CI
     * @returns A JSON formatted string with name-value pairs for operationalStates - one of the string choice values of the operational_status field, or UNKNOWN. errors - list of errors. 
     */
    getOperationalState(ciSysId: String): String;

    /**
     * Determines if the two specified actions are compatible.
     * 
     * @actionName A CI action name
     * @otherActionName A CI action name
     * @returns Returns true if the two specified CI actions are compatible.
     */
    isCompatibleCIAction(actionName: String, otherActionName: String): Boolean;

    /**
     * Determines if the lease has expired for the requestor of a specified CI Action.
     * 
     * @requestorId A sys_id of a workflow context, or the GUID returned from the registerOperator() method.
     * @ciSysId The CI's sys_id.
     * @ciActionName Name of the CI action.
     * @returns A JSON formatted string with name-value pairs for result - true if the user's lease has expired. errors - list of errors. 
     */
    isLeaseExpired(requestorId: String, ciSysId: String, ciActionName: String): String;

    /**
     * For a type of CI, determine if a CI action is not allowed for an operational state.
     * 
     * @ciType The CI type
     * @opsLabel The operational state
     * @actionName The CI action name
     * @returns Returns true if the action is not allowed on the specified CI type in the specified operational state.
     */
    isNotAllowedAction(ciType: String, opsLabel: String, actionName: String): Boolean;

    /**
     * For a type of CI, determine if an operational state transition is not allowed.
     * 
     * @ciType The CI type
     * @opsLabel The label of the beginning operational state.
     * @transitionOpsLabel The label of the ending operational state.
     * @returns Returns true if specified operational state transition is not allowed on the specified CI type.
     */
    isNotAllowedOpsTransition(ciType: String, opsLabel: String, transitionOpsLabel: String): Boolean;

    /**
     * Determine if the specified requestor is a valid active workflow user or a registered user.
     * 
     * @requestorId A sys_id of a workflow context, or the GUID returned from the registerOperator() method.
     * @returns A JSON formatted string with name-value pairs for result - true if the requestorId is valid. errors - list of errors. 
     */
    isValidRequestor(requestorId: String): String;

    /**
     * Register an operator for a non-workflow user.
     * 
     * @example
     * 
     * var output = SNC.StateManagementScriptableApi.registerOperator();
     * var jsonUntil = new JSON();
     * var result = jsonUntil.decode(output);
     * var requestorId = result.requestorId;
     * 
     * @returns A JSON formatted string with name-value pairs for requestorid - Registered user GUID that is used to set CI Action/operational states. result - true if successfully registered. errors - list of errors. 
     */
    registerOperator(): String;

    /**
     * Removes a CI action for a list of CIs.
     * 
     * @requestorId A sys_id of a workflow context, or the GUID returned from the registerOperator() method.
     * @sysIdList A comma separated list of CI sys_ids
     * @ciActionName The CI action name
     * @returns A JSON formatted string with name-value pairs for result - true if the action is removed for all CIs in the list; otherwise, false. errors - list of errors. 
     */
    removeBulkCIAction(requestorId: String, sysIdList: String, ciActionName: String): String;

    /**
     * Set the operational state for list of CIs.
     * 
     * @requestorId A sys_id of a workflow context, or the GUID returned from the registerOperator() method.
     * @sysIdList A comma separated list of CI sys_ids.
     * @opsLabel This is the string label of an operational_status choice.
     * @opsStateListOld (Optional) A comma separated list of old CI states that all CIs should be in.
     * @example
     * var output = SNC.StateManagementScriptableApi.registerOperator();
     * var jsonUntil = new JSON();
     * var result = jsonUtil.decode(output);
     * var requestorId = result.requestorId;
     * 
     * // list of sys_ids to update
     * var sys_ids;
     * 
     * // Set list of sys_ids's Operational State to 'Repair in Progress'
     * output = SNC.StateManagementScriptableApi.setBulkCIOperationalState(requestorId, sys_ids,'Repair in Progress');
     * gs.print(output);
     * 
     * @returns A JSON formatted string with name-value pairs for result - true if the state is set for all CIs in the list; otherwise, false. errors - list of errors. 
     */
    setBulkCIOperationalState(requestorId: String, sysIdList: String, opsLabel: String, opsStateListOld: String): String;

    /**
     * Unregister an operator for non-workflow users.
     * 
     * @requestorId A sys_id of a workflow context, or the GUID returned from the registerOperator() method.
     * @returns A JSON formatted string with name-value pairs for result - true if successfully unregistered. errors - list of errors. 
     */
    unregisterOperator(requestorId: String): String;

}

/**
 * The SummaryTableWriter script include enables the creation of summary sets for reports that can be generated with standard queries and trending. This script provides methods that enable you to customize the output of the summary sets for reports, such as adding a title, defining a query on which to base the report data, and specifying the stack column and X axis.
 * 
 * 
 */
declare class SummaryTableWriter {



    /**
     * Produces a summary set for the COUNT of all incidents grouped by category.The custom chart definition table contains a field named Table that is hidden by default. If the field is set, which it is in some of the base custom charts, then, no matter what is defined within the custom chart scripts, clicking on the chart points you to this table.For example, if you create a custom chart against the [task] table through a script, but you copied the custom chart from a custom chart that contains Table = incident, then clicking on any bar in the custom script will go to incident.do rather than to task.do.To check the value of the Table field, click the additional actions icon and select Configure &gt; Form Layout and move the Table field from Available to Selected. Open the custom chart definition and set the Table field to none.
     * 
     * @tableName Table used in the query to generate the data.
     * @columnName Field that is used to determine the X axis values.
     * @example
     * var summarySet = new SummaryTableWriter('incident', 'category');
     * summarySet.generate();
     */
    constructor(tableName: String, columnName: String);

    /**
     * Creates the summary set of records for reports.
     * 
     * @example
     * var opened = new SummaryTableWriter('incident', '');
     * opened.generate();
     */
    generate();

    /**
     * Defines the query to use to load the data for the summary record set.
     * 
     * @query Query to use to load the summary data.
     * @example
     * var summarySet = new SummaryTableWriter('incident', 'category');
     * summarySet.setQuery("active=true");
     * summarySet.generate();
     */
    setQuery(query: String);

    /**
     * Defines the column on which to stack the incident records.
     * 
     * @column Column that is used to stack the incident records.
     * @example
     * var summarySet = new SummaryTableWriter('incident', 'category');
     * summarySet.setQuery("active=true");
     * summarySet.setStackOn('priority');
     * summarySet.generate();
     */
    setStackOn(column: String);

    /**
     * Sets the title of the summary set, which is also the chart title.
     * 
     * @title Title given to the summary set that is used as the chart title. Also used as the key field for chart generators to determine whether the data was generated.
     * @example
     * var opened = new SummaryTableWriter('incident', '');
     * opened.setTitle("Trend of Open Incidents");
     * opened.setTrend('opened_at', 'month');
     * opened.generate();
     */
    setTitle(title: String);

    /**
     * Sets the time field used for the X axis or stacking field; can also set the time interval used to calculate the trend.
     * 
     * @field Time field that is used for X axis values if grouping is not used. If grouping is used, then this is the stacking field.
     * @interval Time interval that is used to calculate the trend.
     * @example
     * var opened = new SummaryTableWriter('incident', '');
     * opened.setTitle("Trend of Open Incidents");
     * opened.setTrend('opened_at', 'month');
     * opened.generate();
     */
    setTrend(field: String, interval: String);

}

/**
 * TableUtils is a class of shortcuts for accessing table related information. The TableUtils class is available to server-side scripts.
 * 
 * 
 */
declare class TableUtils {



    /**
     * Creates an instance of a TableUtils class.
     * 
     * @tableName The table name
     * @example
     * var tu = new TableUtils("incident");
     */
    constructor(tableName: String);

    /**
     * Drops a database table.
     * 
     * @tableName Name of the table to drop
     * @example
     * var tu = new TableUtils();
     * tu.drop("table_that_will_be_lost_forever");
     */
    drop(tableName: String);

    /**
     * Drops a database table and cleans up references to the table.
     * 
     * @tableName Name of the table to drop
     * @example
     * var tu = new TableUtils();
     * tu.dropAndClean("table_that_will_be_lost_forever");
     */
    dropAndClean(tableName: String);

    /**
     * Drops a database table, all of it's extended tables, and cleans up references to the tables.
     * 
     * @tableName The table to drop
     * @example
     * var tu = new TableUtils();
     * tu.dropAndClean("table_that_will_be_lost_forever");
     */
    dropTableAndExtensions(tableName: String);

    /**
     * Returns the base table name from which the table was extended.
     * 
     * @example
     * var table = new TableUtils("cmdb_ci_server");
     * gs.print(table.getAbsoluteBase());
     * @returns Base table name
     */
    getAbsoluteBase(): String;

    /**
     * Returns the list of tables that extend a table, includes the base table.
     * 
     * @example
     * var table = new TableUtils("task");
     * gs.print(table.getAllExtensions());
     * @returns A list of tables that extend the table, includes the base table.
     */
    getAllExtensions(): ArrayList;

    /**
     * Returns a list of all classes participating in the hierarchy of the specified table.
     * 
     * @example
     * var table = new TableUtils("cmdb_ci_server");
     * gs.print(table.getHierarchy());
     * @returns A list of all classes in the specified table's hierarchy.
     */
    getHierarchy(): ArrayList;

    /**
     * Returnss a list of tables that extend a table.
     * 
     * @example
     * var table = new TableUtils("task");
     * gs.print(table.getTableExtensions());
     * @returns A list of table names that extend the table.
     */
    getTableExtensions(): ArrayList;

    /**
     * Returns the table hierarchy.
     * 
     * @example
     * var table = new TableUtils("incident");
     * gs.print(table.getTables());
     * @returns A list of table names in the parent hierarchy.
     */
    getTables(): ArrayList;

    /**
     * Determines if a table has been extended.
     * 
     * @example
     * var table = new TableUtils("cmdb_ci_server");
     * gs.print(table.hasExtensions());
     * @returns True if the table has extensions.
     */
    hasExtensions(): Boolean;

    /**
     * Determines if a table has no parents and has extensions.Task is a base class since it is not extended from another table and has tables extended from it, but sys_user is not a base class - it has no parents, but does not have extensions.
     * 
     * @example
     * var table = new TableUtils("task");
     * gs.print("Task is base class: " + table.isBaseClass());
     *  
     * var table = new TableUtils("sys_user");
     * gs.print("User is base class: " + table.isBaseClass());
     */
    isBaseClass();

    /**
     * Determines if the table has no parents and no extensions.
     * 
     * @example
     * var table = new TableUtils("task");
     * gs.print("task is solo class: " + table.isSoloClass());
     *  
     * var table = new TableUtils("cmdb_ci_win_server");
     * gs.print("cmdb_ci_win_server is solo class: " + table.isSoloClass());
     *  
     * var table = new TableUtils("sys_user");
     * gs.print("sys_user is solo class: " + table.isSoloClass());
     * @returns True if the table has no parent and no table is extended from it.
     */
    isSoloClass(): Boolean;

    /**
     * Checks to see if a table exists.
     * 
     * @example
     * var table = new TableUtils("my_table");
     * gs.print("Does 'my_table' exist? " + table.tableExists());
     * @returns True if the table exists.
     */
    tableExists(): Boolean;

}

/**
 * The TaskStateUtil API is in the task state management utility script include and is used for working with task-type table state attributes. The TaskStateUtil API is primarily used by the Task Active State Management business rule to set the active field based on state changes. Configurations are defined in the task.state dictionary element, usually using dictionary overrides since state values vary by table. * * The TaskStateUtil API can be called by any server script to determine inactive states, default work, or default close states for a table. * * The required attributes are defined on the planned_task table so all planned task types are supported. We will eventually add the attributes to other task types and eventually the base task table. You are free to do this if you want to leverage this feature now. * * These attributes can be defined on the task.state dictionary element or a dictionary override for extended task tables.
 * Table 1. Related Attributes Attribute Definition close_states Semicolon delimited list of state values that are inactive, used to identify whether the task should be set to active or inactive. This is a required attribute to use the TaskStateUtil functionality. default_close_state Optional attribute to define the state value of the default close state if you want to define business rules that automatically close a task. Defaults to 3, typically Closed Complete if attribute is not defined. default_work_state Optional attribute to define the state value of the default working state if you want to define business rules that automatically set a task for working. Defaults to 2, typically Work in Progress if the attribute is not defined. 
 * 
 * 
 */
declare class TaskStateUtil {

    /** The name of the attribute that identifies the default close state. */
    ATTR_DEFAULT_CLOSE: String
    /** The name of the attribute that identifies default work state. */
    ATTR_DEFAULT_WORK: String
    /** The name of the attribute that identifies inactive states. */
    ATTR_INACTIVE_STATES: String
    /** The value of the default close state is Closed Complete on the Task table. */
    SYSTEM_DEFAULT_CLOSE: Integer
    /** The value of the default work state is Work in progress on the Task table. */
    SYSTEM_DEFAULT_WORK: Integer
    /** The values of the default inactive states: Closed Complete, Closed Incomplete, Closed
    Skipped on the Task table. */
    SYSTEM_INACTIVE_STATES: Integerarray


    /**
     * Creates a TaskStateUtil object.
     * 
     * @task This must be a GlideRecord from a task table.
     * @example
     * var stateUtil = new TaskStateUtil(current);
     */
    constructor(task: GlideRecord);

    /**
     * Returns the value for the default closed state.The default closed state value is 3 if the default_close_state attribute has not been specified.
     * 
     * @example
     * var stateUtil = new TaskStateUtil(current);
     * //get the close state
     * var defaultCloseState =  stateUtil.getDefaultCloseState();
     * current.state = defaultCloseState;
     * @returns State value representing the closed state.
     */
    getDefaultCloseState(): Number;

    /**
     * Returns the value for the default work state.The default work state value is 2 if the default_work_state attribute has not been specified.
     * 
     * @example
     * var stateUtil = new TaskStateUtil(current);
     * //get the work state
     * var defaultWorkState =  stateUtil.getDefaultWorkState();
     * current.state = defaultWorkState;
     * @returns The state value representing the working state.
     */
    getDefaultWorkState(): Number;

    /**
     * Returns a list of the inactive state values.
     * 
     * @example
     * var stateUtil = new TaskStateUtil(current);
     * //get the inactive state values
     * var inactiveStates = stateUtil.getInactiveStates();
     * @returns Array of state values that are inactive.
     */
    getInactiveStates(): Array<any>;

    /**
     * Returns the active status of the specified state.
     * 
     * @state The state value to check.
     * @example
     * var stateUtil = new TaskStateUtil(current);
     * var previousStateInactive = stateUtil.isStateInactive(previous.state);
     * var currentStateInactive = stateUtil.isStateInactive(current.state);
     * @returns True if the state is inactive.
     */
    isStateInactive(state: String): Boolean;

    /**
     * Decides whether the mark closed business rule should be run or not.
     * 
     * @returns Whether the business rule should be allowed to run or not.
     */
    runMarkClosed(): Boolean;

    /**
     * Decides whether the task closer business rule should be run or not.
     * 
     * @returns Determines whether the business rule should be allowed to run or not.
     */
    runTaskCloser(): Boolean;

    /**
     * Decides whether the task reopener business rule should be run or not.
     * 
     * @returns Whether the business rule should be allowed to run or not.
     */
    runTaskReopener(): Boolean;

    /**
     * Enables the user to specify their own default work state.
     * 
     * @defaultWorkState The value to use for the default work state.
     * @returns A self-reference to allow for method chaining.
     */
    setDefaultWorkState(defaultWorkState: String): TaskStateUtil;

}

/**
 * This class defines a set of properties that describe the characteristics and interactive behavior of an element rendered within a TimelineItem. Since it is extremely important for all of a TimelineItem's collection of spans to be unique, the creation of a new instance should be performed via the createTimelineItem method of an existing TimelineIteminstance.
 * 
 * 
 */
declare class TimelineSpan {



    /**
     * Adds multiple relationships between the current instance and other TimelineSpan objects by enumerating through the array of JavaScript objects.Each object should have an internal property relationship_sys_id and predecessor_sys_id specified.
     * 
     * @objArray JavaScript object array that contains two internal properties: relationship_sys_id and predecessor_sys_id.
     */
    addPredecessor(objArray: ObjectArray);

    /**
     * Adds the specified relationship between the current instance and another TimelineSpan with sys ID strPredecessorSysId.The drawn line will not have any double click handlers associated with it.
     * 
     * @strPredecessorSysId The sys ID of the planned task that is the predecessor of the relationship.
     * @strRelationshipSysId The sys ID of the relationship of the relationship.
     */
    addPredecessor(strPredecessorSysId: String, strRelationshipSysId: String);

    /**
     * Adds the specified relationship between the current instance and another TimelineSpan and allows the relationship to open a GlideWindow to display information about the relationship.
     * 
     * @strPredecessorSysId The sys ID of the planned task that is the predecessor of the relationship.
     * @strRelationshipSysId The sys ID of the relationship of the relationship.
     * @strTableName The name of the table for the relationship.
     */
    addPredecessor(strPredecessorSysId: String, strRelationshipSysId: String, strTableName: String);

    /**
     * Returns the boolean value of the AllowXDragLeft property.
     * 
     * @returns True if the object's start time can be adjusted; False otherwise.
     */
    getAllowXDragLeft(): Boolean;

    /**
     * Returns the boolean value of the AllowXDragRight property.
     * 
     * @returns True if the object's end time can be adjusted; false otherwise.
     */
    getAllowXDragRight(): Boolean;

    /**
     * Returns the boolean value of the AllowXMove property.
     * 
     * @returns True if the object can be moved; false otherwise.
     */
    getAllowXMove(): Boolean;

    /**
     * Returns the boolean value of the AllowYMove property.
     * 
     * @returns True if the object can be moved vertically; false otherwise.
     */
    getAllowYMove(): Boolean;

    /**
     * Returns the boolean value of the AllowYMovePredecessor property.
     * 
     * @returns True if the a dashed relationship line can be drawn from the current object to a new successor; false otherwise.
     */
    getAllowYMovePredecessor(): Boolean;

    /**
     * Returns the name of the current inner segment class for the TimelineSpan.
     * 
     * @returns The name of the class for the current inner segment style.
     */
    getInnerSegmentClass(): String;

    /**
     * Returns the time in milliseconds of the end time of the inner segment portion of the TimelineSpan .
     * 
     * @returns The end time of the TimelineSpan inner segment portion in milliseconds.
     */
    getInnerSegmentEndTimeMs(): Number;

    /**
     * Returns the time in milliseconds of the start time of the inner segment portion of the TimelineSpan.
     * 
     * @returns The start time of the TimelineSpan inner segment portion in milliseconds.
     */
    getInnerSegmentStartTimeMs(): Number;

    /**
     * Returns a boolean that specifies whether or not the current timeline item has been modified after initialization.
     * 
     * @returns True if the current span has been marked as changed; otherwise false.
     */
    getIsChanged(): Boolean;

    /**
     * Returns a string that specifies the name of the icon class to use for displaying the element on the timeline if the current instance has zero duration.
     * 
     * @returns The name of the icon class to use for displaying the current TimelineSpan if the duration is zero.
     */
    getPointIconClass(): String;

    /**
     * Returns an array of all the predecessor objects associated with the current instance. Each array object is a HashMap that contains a predecessor_sys_id and relationship_sys_id property.
     * 
     * @returns List of HashMaps that contain two internal properties: predecessor_sys_id and relationship_sys_id.
     */
    getPredecessors(): ObjectArray;

    /**
     * Returns the string name of the color specified for displaying this span.
     * 
     * @returns The HTML color name to use as the background color for the element.
     */
    getSpanColor(): String;

    /**
     * Returns the string that specifies the text to display adjacent to the time element.
     * 
     * @returns The text displayed adjacent to the element.
     */
    getSpanText(): String;

    /**
     * Returns the start time in milliseconds of the current TimelineSpan object.
     * 
     * @returns The start time of the element in milliseconds.
     */
    getStartTimeMs(): Number;

    /**
     * Returns the sys ID of the current object.This method is useful for returning the sys Id when the current object instance was created without a specific sys Id to obtain the dynamically generated GUID.
     * 
     * @returns The unique system ID of the current element.
     */
    getSysId(): String;

    /**
     * Returns the name of the table where the sys ID is referenced.
     * 
     * @returns The table name.
     */
    getTable(): String;

    /**
     * Returns the text/html to display in the tooltip when the TimelineSpan element is being hovered over.
     * 
     * @returns The tooltip text.
     */
    getTooltip(): String;

    /**
     * Sets a flag that determines whether the element's start date can be dragged left or right therefore adjusting the duration of the task.The effect of this behavior is controlled by the script include that handles the appropriate event. The default value for this property is false.
     * 
     * @bFlag True to enable the element's start date to be adjusted; false otherwise.
     */
    setAllowXDragLeft(bFlag: Boolean);

    /**
     * Sets a flag that determines whether the element's end date can be dragged left or right therefore adjusting the duration of the task.The effect of this behavior is controlled by the script include that handles the appropriate event. The default value for this property is false.
     * 
     * @bFlag True to enable the element's end date to be adjusted; false otherwise.
     */
    setAllowXDragRight(bFlag: Boolean);

    /**
     * Sets a flag that determines whether the element can be moved to start at a different time.The effect of this behavior is controlled by the script include that handles the appropriate event. The default value for this property is false.
     * 
     * @bFlag True to enable the element to be moved horizontally; false otherwise.
     */
    setAllowXMove(bFlag: Boolean);

    /**
     * Sets a flag that determines whether the element can be dragged vertically on the timeline.The effect of this behavior is controlled by the script include that handles the appropriate event. The default value for this property is false.
     * 
     * @bFlag True to enable the element to be moved vertically; false otherwise.
     */
    setAllowYMove(bFlag: Boolean);

    /**
     * Sets a flag that determines whether a dashed relationship line can be drawn from this element interactively on the timeline.The effect of this behavior is controlled by the script include that handles the appropriate event. The default value for this property is false.
     * 
     * @bFlag True to enable a relationship line to be drawn from this element; false otherwise.
     */
    setAllowYMovePredecessor(bFlag: Boolean);

    /**
     * Specifies the name of the class to use for stylizing the inner segment if it exists.The default value is green.
     * 
     * @styleClass One of the following values: green, blue, or silver.
     */
    setInnerSegmentClass(styleClass: String);

    /**
     * Creates an inner segment to show within the current timespan defined by the range specified.
     * 
     * @startTimeMs The start time in milliseconds.
     * @endTimeMs The end time in milliseconds.
     */
    setInnerSegmentTimeSpan(startTimeMs: Number, endTimeMs: Number);

    /**
     * Sets the icon class to use for displaying the current element on the timeline if the current instance has zero duration.
     * 
     * @iconClassName String that specifies one of the following values: milestone blue_square sepia_square green_square red_square black_square blue_circle sepia_circle green_circle red_circle black_circle 
     */
    setPointIconClass(iconClassName: String);

    /**
     * Sets the color for displaying this span.
     * 
     * @strColor The HTML color name for the color of this span.
     */
    setSpanColor(strColor: String);

    /**
     * Sets the text to display adjacent to the time element.
     * 
     * @strSpanText The text to display next to the time element.
     */
    setSpanText(strSpanText: String);

    /**
     * Sets the start and end dates for the current span.
     * 
     * @nStartTime The start time in milliseconds.
     * @nEndTimeMs The end time in milliseconds.
     */
    setTimeSpan(nStartTime: Number, nEndTimeMs: Number);

    /**
     * Sets the start and end times for the current span.
     * 
     * @strStartTime The start time in milliseconds.
     * @strEndTimeMs The end time in milliseconds.
     */
    setTimeSpan(strStartTime: String, strEndTimeMs: String);

    /**
     * Sets the text to display in the tooltip when the TimelinSpan element is being hovered over.
     * 
     * @strTooltipText The text to display in the tooltip.
     */
    setTooltip(strTooltipText: String);

}

/**
 * Handles SNMP classification and identification for UPSs. Use this API for SNMP-related discovery.
 * 
 * 
 */
declare class UPSHandler {



    /**
     * Classifies and identifies the UPSs.
     * 
     */
    classifyAndIdentify();

}

/**
 * Provides utility functions for discovery and provisioning of virtual machines. The VMUtils class is available in server-side scripts to convert between UUID and Correlation ID formats.
 * 
 * 
 */
declare class VMUtils {



    /**
     * Converts a correlation ID into a UUID for a virtual machine in the ServiceNow system.
     * 
     * @correlationId The correlation ID to convert
     * @example
     * var vmu = new VMUtils();
     * gs.print(vmu.turnCorrelationIdToUuid('42 10 82 82 62 35 ca 68-b5 1c 1e f8 5c 0a 0d 5b'));
     * @returns The UUID, or an empty string if invalid.
     */
    turnCorrelationIdToUuid(correlationId: String): String;

    /**
     * Converts a WMware universal unique identifier (UUID) to a format that matches the original format in the ServiceNow system.vCenter works with UUIDs where the ESXi Linux console worked with this format.
     * 
     * @uuid The UUID to convert.
     * @example
     * var vmu = new VMUtils();
     * vmu.turnUuidToCorrelationId('13eb78d0-d504-11e1-9b23-0800200c9a66');
     * @returns The identifier converted to the ServiceNow format.
     */
    turnUuidToCorrelationId(uuid: String): String;

}

/**
 * Walks the workflow and gets the list of successors for each activity along with a shortest path order that indicates the activity depth in the workflow. 
 * 
 * 
 */
declare class WalkWorkflow {



    /**
     * Constructor for Walkworkflow class.
     * 
     * @workflowVersion GlideRecord on table wf_workflow_version of the workflow version to analyze.
     * @returns Workflow object just created.
     */
    constructor(workflowVersion: GlideRecord): Workflow;

    /**
     * Computes the full sequence for every path.Does not combine paths at Join activities. After calling this method, call getSequences() to yield the computed sequences.
     * 
     */
    computeFullSequences();

    /**
     * Computes the sequences of activities.All sequences leading up to a join end at the join and then a single sequence from the join is computed. This ensures that all sequences can be walked up to a join, and then the sequence can be walked from the join. After calling this method a call to getSequences() will yield the computed sequences.
     * 
     */
    computeSequences();

    /**
     * Outputs the internal state of this class to gs.print().
     * 
     */
    dump();

    /**
     * Outputs the sequences internal to this class to gs.print().
     * 
     */
    dumpSequences();

    /**
     * Outputs the shortest path orders internal to this object to gs.print().
     * 
     */
    dumpShortestPathOrders();

    /**
     * Returns all the activities at the specified shortest path order.
     * 
     * @order The order number the client is interested in.
     * @returns An array of activity sys_ids at the specified order. If an empty array is returned, there are no more activities.
     */
    getActivitiesAtOrder(order: Number): StringArray;

    /**
     * Returns the activity sequences.The walk() method must have been called prior to calling this method.
     * 
     * @returns A string of |-delimited sequences. Each sequence is a comma-delimited list of activity ids (table wf_workflow_activity).
     */
    getSequences(): String;

    /**
     * Walks the workflow and sets up the activity shortest path ordering.After calling this method the client would call the various accessor methods to obtain relevant data about the workflow.
     * 
     * @fullSequences (Optional) If true, computes the full sequences. Default is false.
     */
    walk(fullSequences: Boolean);

}

/**
 * The base class for all workflow activities. As the base class for all workflow activities, this code always executes as part of an activity. * * When developing your own workflow activities, create your script object by deriving from this class and overriding methods as necessary to get the functionality you want. Client code must override method onExecute() to perform meaningful activity processing.
 * 
 * 
 */
declare class WFActivityHandler {



    /**
     * Logs a debug message.
     * 
     * @msg Message to send to the log.
     * @args Array of values to send to the log
     */
    debug(msg: String, args: Array<any>);

    /**
     * Logs a debug message.
     * 
     * @msg Message to send to the log.
     * @args String to send to the log
     */
    debug(msg: String, args: String);

    /**
     * Handles pre-generation of tasks and approvals (and other objects as needed).Allows objects to be generated at the start of a workflow in a pending state and not requested until the workflow gets to the activity, thereby providing a preview of the work to be done in the future. To pre-generate objects, an activity's _generate() method is called. This method typically returns a pre-generation object that is saved in the workflow scratchpad. (For example, the object might be an array of approval ids that were generated.) When the activity runs onExecute it may request the pre-generation object and determine if the approvals have already been created in a pending state or if it needs to create the approvals in the onExecute method. Internal method _generate needs to be overridden and needs to return an object with information that it can retrieve later on when the activity's onExecute() method is called. The object must contain a duration property that contains the duration of the task(s) or approval(s) that were generated by the activity. See activity Generate for example usage.
     * 
     * @activityId sys_id of this running activity (table wf_activity).
     * @order The order number associated with the task or approval.
     * @startAtDspValue The starting time for the task or approval
     * @noCreateFlag 
     * @returns The duration property of the _generate return value is returned by this method..
     */
    generate(activityId: String, order: String, startAtDspValue: GlideDateTime, noCreateFlag: Boolean): Number;

    /**
     * Logs an information message.
     * 
     * @msg Message to send to the log.
     * @args Array of values to send to the log
     */
    info(msg: String, args: Array<any>);

    /**
     * Logs an information message.
     * 
     * @msg Message to send to the log.
     * @args String to send to the log.
     */
    info(msg: String, args: String);

    /**
     * Evaluates activity variables in the script.Used to evaluate strings that contain el such as ${some script} or strings starting with javascript:. See almost any existing activity for example usage.
     * 
     * @str String that possibly contains embeded el.
     * @returns The evaluated string.
     */
    js(str: String): String;

    /**
     * Event handler for cancel event.The base class for the activity script sets this activity to be cancelled. Derived classes (activities) can override this method if additional processing is required to cancel this activity. Activity Manual Approvals is an example of overriding this method to perform additional processing to cancel this activity.
     * 
     */
    onCancel();

    /**
     * Virtual method. Activity subclasses must override this method to perform work appropriate to the activity.
     * 
     */
    onExecute();

    /**
     * Enables activities to run a script contained in an activity variable of type script.Example activities that use this method include If, Wait for condition, and Approval - User.
     * 
     * @script String containing valid Javascript.
     * @returns If the script set the workflow variable answer then this value is returned. If not, then the result of the script execution is returned.
     */
    runScript(script: String): variable;

    /**
     * Sets the activity output property.See activity SOAP Message.
     * 
     */
    setActivityOutput();

    /**
     * Sets the activity result as failed with an optional reason string.See Activity SOAP Message.
     * 
     * @reason (Optional) Description of the reason this activity failed.
     */
    setResultFailed(reason: String);

    /**
     * Sets the result of this activity as successful.
     * 
     */
    setResultSucceeded();

    /**
     * Logs a warning message.
     * 
     * @msg Message to send to the log.
     * @args Array of values to send to the log
     */
    warn(msg: String, args: Array<any>);

    /**
     * Logs a warning message.
     * 
     * @msg Message to send to the log.
     * @args String to send to the log
     */
    warn(msg: String, args: String);

}

/**
 * Handles the formatting of Windows OS names. Use in any server-side discovery scripts where you need to format OS names.
 * 
 * 
 */
declare class WindowsOSNameHelper {



    /**
     * Formats the given Windows OS name.
     * 
     * @name The name to format
     * @returns The formatted name
     */
    formatWindowsOSName(name: String): String;

    /**
     * Ensures that the OS choice is valid.
     * 
     * @value The value to validate
     */
    makeOSChoiceValid(value: String);

    /**
     * Cleans up the specified Windows OS name by stripping out incorrect characters, incorrect capitalization, extra spaces, or trailing spaces.
     * 
     * @name The name to clean up.
     * @returns The cleaned up name
     */
    osCleanupName(name: String): String;

}

/**
 * Workflow scripts provide an interface with the workflow engine. Use these methods to manipulate workflows.
 * 
 * 
 */
declare class Workflow {



    /**
     * Constructor for Workflow class.
     * 
     * @example
     * var w = new Workflow();
     */
    constructor();

    /**
     * Sends the specified event (message) into the workflow context to pass along to the executing activities.Typical use of this method is to enable activities that wait for some action to occur before proceeding. For additional information on using broadcastEvent, refer to Workflow event-specific functions.For a list of the available OOB events, refer to Workflow events in the base system.
     * 
     * @contextId The context ID.
     * @eventName The name of the event.
     * @example
     * //where current is a task record with a workflow context
     *       var wf = new Workflow().getRunningFlows(current);
     *       while(wf.next()) {     
     *           new Workflow().broadcastEvent(wf.sys_id, 'resume');
     *       }
     */
    broadcastEvent(contextId: String, eventName: String);

    /**
     * Cancels all running workflows on this record by broadcasting the cancel event to activities in all running workflows on this record.
     * 
     * @record GlideRecord on any table. All workflows running on this record will be cancelled.
     * @example
     * //get workflow helper
     *       var workflow = new Workflow();
     *       //cancel all the workflows, where current is a task record with a workflow context
     *       workflow.cancel(current);
     *       gs.addInfoMessage(gs.getMessage("Workflows for {0} have been cancelled", current.getDisplayValue()));
     */
    cancel(record: GlideRecord);

    /**
     * Cancels this running context by broadcasting a cancel event to activities in this workflow context.
     * 
     * @context GlideRecord of the running context to cancel.
     * @example
     * // If a workflow has started for this item, cancel it, where current is a task record with a workflow context
     *       if ((current.stage == 'Request Cancelled') &amp;&amp; current.context 
     *           &amp;&amp; !current.context.nil()) {
     *       var w = new Workflow();
     *       var gr = new GlideRecord('wf_context');
     *       
     *       if (gr.get(current.context)) 
     *           w.cancelContext(gr);
     *       }
     */
    cancelContext(context: GlideRecord);

    /**
     * Deletes all the workflows on the record.
     * 
     * @current GlideRecord for which the caller wants to delete all workflows. This can be any record on any table.
     * @example
     * //where current is a task record with a workflow context
     *       var wkfw = new Workflow();
     *       wkfw.deleteWorkflow(current);
     *     
     */
    deleteWorkflow(current: GlideRecord);

    /**
     * Fires the named event on the input record.Used in Activities Approval Coordinator, Timer, Lock, and some others.
     * 
     * @eventRecord The event record.
     * @eventName The name of the event to send to the executing workflow.
     * @example
     * ////where current is a task record with a workflow context
     *       var w = new Workflow(); 
     *       w.fireEvent(current, 'execute');
     */
    fireEvent(eventRecord: GlideRecord, eventName: String);

    /**
     * Fires the named event on the record specified by record ID.Used in Activities Approval Coordinator, Timer, Lock, and some others.
     * 
     * @eventRecordId The sys_id of the glide record.
     * @eventName The name of the event to send to the executing workflow.
     * @example
     * var wkfw = new Workflow();
     *       wkfw.fireEventById('f2400ec10b0a3c1c00ca5bb5c6fae427','Timer');
     */
    fireEventById(eventRecordId: String, eventName: String);

    /**
     * Gets all workflow contexts for the input record.The input record is any record on any table for which the caller wants the running workflow contexts.
     * 
     * @record GlideRecord for which the caller wants a list of all workflow contexts .
     * @example
     * //where current is a task record with a workflow context
     *       var wkfw = new Workflow();
     *       gs.print(wkfw.getContexts(current).started);
     * @returns GlideRecord on table wf_context filtered for all workflow contexts for the input record (in any state, e.g. running, cancelled, finished).
     */
    getContexts(record: GlideRecord): GlideRecord;

    /**
     * Gets the estimated time for a workflow to complete.
     * 
     * @workflowId Sys_id of the workflow (table wf_workflow) to get the estimated run time.
     * @example
     * var wkfw = new Workflow();
     *       gs.print(wkfw.getEstimatedDeliveryTime('b99a866a4a3623120074c033e005418f'));
     * @returns Display value from a GlideDuration (e.g., 3 days), or blank if unknown.
     */
    getEstimatedDeliveryTime(workflowId: String): String;

    /**
     * Get the estimated elapsed execution time for the workflow version.
     * 
     * @wfVersion GlideRecord on table wf_workflow_version of a specific workflow version for which the caller wants the estimated during of executing.
     * @example
     * //where current is a task record with a workflow context
     *       var wkfw = new Workflow();
     *       var context = wkfw.getContexts(current);
     *       gs.print(wkfw.getEstimatedDeliveryTimeFromWFVersion(context.wf_version));
     * @returns Display value from a GlideDuration (e.g., 3 days), or blank if unknown.
     */
    getEstimatedDeliveryTimeFromWFVersion(wfVersion: GlideRecord): String;

    /**
     * Gets the appropriate workflow return value for the input workflow ID. This is either the workflow checked out by the current user or the published workflow with the most recent date.This is either the workflow checked out by the current user or the published workflow with the most recent date. This method is available starting with the Fuji release.
     * 
     * @workflowID The sys_id of the workflow (table wf_workflow)
     * @amount amount
     * @result True, if true
     * @example
     * var wkfw = new Workflow();
     *       wkfw.getReturnValue('context');
     * @returns The return value of the workflow as specified by the Return Value activity. Workflows without a Return Value activity return a null value.
     */
    getReturnValue(workflowID: String, amount: Number, result: Boolean): ???;

    /**
     * Gets all the currently running workflow contexts for the input record.The input record is any record on any table for which the caller wants the running workflow contexts.
     * 
     * @record GlideRecord of the record for which the caller wants a list of all running workflows.
     * @example
     * //where current is a task record with a workflow context
     *       var wf = new Workflow().getRunningFlows(current);
     *       while(wf.next()) {     
     *           new Workflow().broadcastEvent(wf.sys_id, 'pause');
     *       }
     * @returns GlideRecord on table wf_context and filtered for all executing workflow contexts.
     */
    getRunningFlows(record: GlideRecord): GlideRecord;

    /**
     * Gets the appropriate workflow version for the input workflow ID. This is either the workflow checked out by the current user or the published workflow with the most recent date.This is either the workflow checked out by the current user or the published workflow with the most recent date.
     * 
     * @workflowID The sys_id of the workflow (table wf_workflow)
     * @example
     * var wkfw = new Workflow();
     *       wkfw.getVersion('b99a866a4a3623120074c033e005418f');
     * @returns  
     */
    getVersion(workflowID: String): none;

    /**
     * Returns the appropriate workflow version for the input workflow name.See getVersion() for more information.
     * 
     * @workflowName Name of the workflow (table wf_workflow)
     * @example
     * var wkfw = new Workflow();
     *       wkfw.getVersionFromName('Emergency Change');
     */
    getVersionFromName(workflowName: String);

    /**
     * Gets the appropriate workflow for the input workflow name.
     * 
     * @workflowName The name of the workflow.
     * @example
     * var wflw = new Workflow();
     *       gs.print(wflw.getWorkflowFromName('Emergency Change'));
     */
    getWorkflowFromName(workflowName: String);

    /**
     * Determines if a specified record has any workflow contexts associated to it.This includes running and completed workflow contexts.
     * 
     * @record GlideRecord under scrutiny. This GlideRecord can be from any table.
     * @example
     * var wkfw = new Workflow();
     *       gs.print(wkfw.hasWorkflow('f2400ec10b0a3c1c00ca5bb5c6fae427'));
     * @returns True, if record has associated workflow; otherwise, returns False.
     */
    hasWorkflow(record: GlideRecord): Boolean;

    /**
     * Recalculates the approvals and tasks for a workflow by adding new approvals and tasks while not resetting current approvals and tasks.Use this script to add an additional company to a change request, without reseting current approvals for companies already in the workflow.
     * 
     * @current GlideRecord of the record this workflow is executing. This can by any record on any table.
     * @maintainStateFlag If True, maintains all approvals and tasks in their current state.
     * @example
     * //mark all existing approvals for the change as 'cancelled' and restart the workflow to create new approvals
     *       //where current is a task record with a workflow context
     *       new WorkflowApprovalUtils().cancelAll(current, comment);
     *       new Workflow().restartWorkflow(current);
     *     
     */
    restartWorkflow(current: GlideRecord, maintainStateFlag: Boolean);

    /**
     * Runs all workflows for a given record in a given table and its descendant tables. Sample usage can be seen in the Script Includes "SNC - Run parent workflows", and "SNC - Run parent workflows (Approval)".
     * 
     * @record The record to run workflows against.
     * @operation Database operation. One of insert, update, delete.
     * @example
     * var wkfw = new Workflow();
     *       wkfw.runFlows('f2400ec10b0a3c1c00ca5bb5c6fae427','update');
     */
    runFlows(record: GlideRecord, operation: String);

    /**
     * Starts a specified workflow. See script include WorkflowScheduler and Business Rule "Start Workflow" on table sc_req_item for examples of use.
     * 
     * @workflowId The sys_id of the workflow to start. This sys_id refers to table wf_workflow.
     * @current The record to use as current in this workflow. This is normally from the Table field of the workflow properties for this workflow.
     * @operation The operation to perform on current. Possible values: insert, update, delete.
     * @vars Collection of variables to add to the workflow
     * @example
     * ////where current is a task record with a workflow context
     *       var w = new Workflow();
     *       var context = w.startFlow(id, current, current.operation(), getVars());
     */
    startFlow(workflowId: String, current: GlideRecord, operation: String, vars: Array<any>);

    /**
     * Helper method for business rule Auto start on context.
     * 
     * @context GlideRecord on table wf_context of a new record (the "current" record in the business rule).
     * @operation Database operation being performed. One of insert, update, delete.
     * @example
     * //where current is a task record with a workflow context
     *       current.name = current.workflow_version.name;
     *       current.started_by.setValue(gs.userID());
     *       
     *       if (gs.nil(current.id)) {
     *         var gr = new GlideRecord('wf_workflow_execution');
     *         gr.name = current.name;
     *         gr.insert();
     *       
     *         current.table = 'wf_workflow_execution';
     *         current.id = gr.sys_id;
     *       }
     *       
     *       var wf = new Workflow();
     *       wf.startFlowFromContextInsert(current, current.operation())
     */
    startFlowFromContextInsert(context: GlideRecord, operation: String);

    /**
     * Used by business rule Start Workflow on table task_sla. This starts a workflow and the extra arguments to this method are used by activity "Timer" to pause the execution of the workflow for some duration.
     * 
     * @workflowID The sys_id of the workflow to start. This sys_id refers to table wf_workflow.
     * @retroactiveMSecs Delay in milliseconds used by Activity Timer.
     * @current GlideRecord of the record to use as current in this workflow. This is normally from the Table field of the workflow properties for this workflow
     * @operation Database operation being performed.One of insert, update, delete.
     * @vars Collection of variables to add to the workflow.
     * @withSchedule Schedule used by Activity Timer
     * @example
     * // is this a retroactive start?
     *       ////where current is a task record with a workflow context
     *       var msecs = new GlideDateTime().getNumericValue() - current.start_time.getGlideObject().getNumericValue();
     *       
     *       // treat this as a retroactive workflow start if the SLA started more than 5 seconds ago
     *       var w = new Workflow();
     *       if (msecs &lt;= 5000)
     *         w.startFlow(id, current, current.operation());
     *       else
     *         w.startFlowRetroactive(id, msecs, current, current.operation());
     *       
     *       // update the record in case the workflow changed some values
     *       current.update();
     *       
     *     
     * @returns A GlideRecord on table wf_context on the inserted record for this newly created workflow context.
     */
    startFlowRetroactive(workflowID: String, retroactiveMSecs: Number, current: GlideRecord, operation: String, vars: Array<any>, withSchedule: ???): GlideRecord;

}

/**
 * This class calculates the duration (in seconds) based on the variables of a workflow activity. It is an interface between Workflow Timer() and DurationCalculator(). 
 * 
 * 
 */
declare class WorkflowDuration {



    /**
     * Adds the number of seconds to the specified start date/time.
     * 
     * @record description
     * @amount amount
     * @returns True, if object was successfully created.
     */
    addSeconds(record: GlideRecord, amount: Number): Boolean;

    /**
     * Calculates the number of seconds and the due date.
     * 
     * @record The record that contains the fields with the schedule, timezone, and date/time information. This is almost always activity.vars.__var_record__.
     */
    calculate(record: GlideRecord);

    /**
     * Calculates the number of seconds remaining to the specified end date/time.
     * 
     * @record The record that contains the fields with the schedule, timezone, and date/time information. This is almost always activity.vars.__var_record__.
     */
    calculateTimeLeft(record: GlideRecord);

    /**
     * Returns the end date/time set by a call to calculate(record).
     * 
     * @returns The end date/time.
     */
    getEndDateTime(): GlideDateTime;

    /**
     * Returns the seconds value that was set by a call to calculate(record).
     * 
     * @returns The number of seconds set by a call to calculate(record).
     */
    getSeconds(): Number;

    /**
     * Returns the totalSeconds value that was set by a call to calculate(record).
     * 
     * @returns The total number of seconds set by a call to calculate(record).
     */
    getTotalSeconds(): Number;

    /**
     * Sets the end date/time to use when calculating the remaining time.To convert the value into the GlideDateTime internal format, use GlideDateTime.getValue().
     * 
     * @dt The end date/time to use.
     */
    setEndDateTime(dt: GlideDateTime);

    /**
     * Sets the end date/time to use when calculating the remaining time.To convert the value into the GlideDateTime internal format, use GlideDateTime.getValue().
     * 
     * @dt The end date/time to use.
     */
    setEndDateTime(dt: String);

    /**
     * Sets the start date/time to use in the calculations.To convert the value into the GlideDateTime internal format, use GlideDateTime.getValue().
     * 
     * @dt The start date/time to use.
     */
    setStartDateTime(dt: GlideDateTime);

    /**
     * Sets the start date/time to use in the calculations.
     * 
     * @dt The start date/time to use, in GMT.
     */
    setStartDateTime(dt: String);

    /**
     * Sets the used seconds compensation, where the number of seconds is the number of seconds inside of any schedule.Can be a -ve number, which extends the duration.
     * 
     * @secs The number of used seconds to set.
     */
    setUsedSecs(secs: Number);

    /**
     * Sets the workflow schedule/timezone. Used for schedule_type workflow_schedule and timezone_type workflow_timezone).
     * 
     * @schedule The schedule to use. Usually from the workflow context.schedule.
     * @timezone The timezone to use. Usually from the workflow context.timezone.
     */
    setWorkflow(schedule: Object, timezone: Object);

}

/**
 * The WorkflowModelManager class provides a way to query the workflow model, to step backwards and forwards between specified wf_history items, and to query the history for activity and transition-specific information. The interaction with the WorkflowModelManager class is through the ActivityHistoryRecord data object. The ActivityHistoryRecord is an inner class and is only used while interacting with WorkflowModelManager. * * To acquire the executed history of the workflow activities: * * To output the playback of the workflow: * * At this time, the playBack is required to load the executed transitions. This will also play a role in walking backwards on a model to rollback to a specific activity. * * To see the details of the cached model: 
 * 
 * 
 */
declare class WorkflowModelManager {



    /**
     * Creates a new WorkflowModelManager object (constructor) within the specified context.
     * 
     * @contextId The ID for the context in which you want the WorkflowModelManager created.
     * @example
     * var model = new WorkflowModelManager('MyContextId');
     * @returns The ActivityHistoryRecord JavaScript object requested.
     */
    constructor(contextId: String): ActivityHistoryRecord;

    /**
     * Retrieves the history activity that is cached by the wf_history.sys_id provided in the argument.
     * 
     * @haRecordSysId The sys_id of the activity history (table wf_history).
     * @returns The ActivityHistoryRecord JavaScript object requested.
     */
    getActivityHistoryRecordById(haRecordSysId: String): ActivityHistoryRecord;

    /**
     * Retrieves the history activities that executed and transitioned into the one represented by the sys_id in the argument.The next status is based on the wf_activity.sys_id associated with the activity represented in the haRecord existing as a TO in a transition associated with any ActivityHistoryRecords that executed in the workflow's history. (This differs from getPreviousByTransition, which only returns TO transitions that come before the haRecord in the execution sequence (by time).) The return value is a collection of ActivityHistoryRecords that identify the argument haRecord.wfaId as their TO activity. The return values are based on all transitions in the executed history collection that transition To get the activity that executed prior to this activity in time use getPreviousByExecutedOrder.
     * 
     * @description ActivityHistoryRecord JavaScript object.
     * @returns Array of ActivityHistoryRecord JavaScript objects.
     */
    getAllTransitionedIntoActivity(description: Object): ObjectArray;

    /**
     * Retrieves the history activities that executed and transitioned into the one represented by the sys_id in the argument. The next status is based on the wf_activity.sys_id associated with the activity represented in the haRecord existing as a TO in a transition associated with any ActivityHistoryRecords that executed in the workflow's history. (This differs from getPreviousByTransition, which returns only TO transitions that come before the haRecord in the execution sequence (by time).) The return value is a collection of ActivityHistoryRecords that identify the argument haRecord.wfaId as their TO activity.The next status is based on the wf_activity.sys_id associated with the activity represented in the haRecord existing as a TO in a transition associated with any ActivityHistoryRecords that executed in the workflow's history. (This differs from getPreviousByTransition, which returns only TO transitions that come before the haRecord in the execution sequence (by time).) The return value is a collection of ActivityHistoryRecords that identify the argument haRecord.wfaId as their TO activity.
     * 
     * @haRecordSysId The sys_id of the activity history (table wf_history).
     * @example
     * var model = new WorkflowModelManager('a143585c3b001000dada82c09ccf3d44');
     *       model.getExecutedHistory();
     *       var activity = model.begin;
     *       gs.print('activity: ' + activity.wfaName + ', transitions: ' + activity.transitions.length);
     *       while( activity != null){    
     *           gs.print('activity: ' + activity.wfaName + ', transitions: ' + activity.transitions.length);    
     *           var parents = model.getAllTransitionedIntoActivity(activity);
     *           for( var i = 0; i &lt; parents.length; i++ ){
     *               gs.print(' ---------------  parent activity: ' + parents[i].wfaName );
     *             }
     *            activity = model.getNextByExecutedOrder( activity );
     *       }
     *     
     * @returns Array of ActivityHistoryRecord JavaScript objects requested.
     */
    getAllTransitionedIntoActivityId(haRecordSysId: String): ObjectArray;

    /**
     * This is the worker method that must be called to initialize the WorkflowModelManager object. In the process of initializing the WorkflowModelManager object, getExecutedHistory() creates and populates the activityHistoryRecord data object array (which is a member of the WorkflowModelManager class). Most WorkflowModelManager methods return a subset of the activityHistoryRecord array. Your script can then call one or more of the activityHistoryRecord methods to accomplish further work.
     * 
     * @example
     * var model = new WorkflowModelManager('myContextId');
     * var activities = model.getExecutedHistory();
     * var current = model.getActivityHistoryRecordById('d6681d573b130000dada82c09ccf3d10');
     * @returns An ordered array of sys_ids from table wf_history. It is unlikely client code would use the return value; it is kept internally to this object for use by subsequent method calls.
     */
    getExecutedHistory(): StringArray;

    /**
     * Gets the list of wf_history.sys_ids of all activities that successfully executed and were not rolled back or skipped up to the moment the function was called.
     * 
     * @example
     * var model = new WorkflowModelManager('ee3e0a053b101000dada82c09ccf3d7c');
     *       model.getExecutedHistory();
     *       var finals = model.getFinalExecutedActivityIdList();
     *       gs.print(' EXECUTION PATH IDs --------------- : '  + finals.length);
     *       
     *       for ( var x = 0; x &lt; finals.length; x++ ) {
     *           gs.print(finals[x] );
     *       }
     * @returns Array of wf_history.sys_id values for executed activities.
     */
    getFinalExecutedActivityIdList(): StringArray;

    /**
     * Queries the wf_history table by context and retrieves all the activities executed in the workflow given by the context set in the construction of this object.This function produces a list of executed activities in the exact order each activity passed through the server side ActivityManager.java using the new activity_index to force the order coming out of the database. On its this call will not give the full picture; it needs to load and map the transitions.
     * 
     * @returns Array of ActivityHistoryRecord javascript objects.
     */
    getFinalExecutedActivityList(): ObjectArray;

    /**
     * Retrieves the history activity that executed just after to the one provided in the argument.The next status is based on the activity index reflecting the nearest prior activity in time and not necessarily the nearest next wf_activity the provided activity transitioned to. To get the nearest next activity that transitioned to this haRecord passed in, use getNextByTransitionOrder( haRecord ). Note: In the process of assembling the execution order array, blanks are left in the array where history objects have been deleted. This is done to ensure the index in the array and the activity_index of the object remain in synch. For that reason, all objects coming out of the execution order array should be tested for nil() and not assumed to be the previous record based on activity_index or array index value alone.
     * 
     * @haRecord ActivityHistoryRecord JavaScript object.
     * @returns The ActivityHistoryRecord JavaScript object requested.
     */
    getNextByExecutedOrder(haRecord: Object): Object;

    /**
     * Retrieves the history activity that is cached by the wf_history.sys_id provided in the argument and then calls into getNextByExecutedOrder() with the retrieved JavaScript object.
     * 
     * @haRecordSysId The sys_id of the activity history (table wf_history).
     * @example
     * var model = new WorkflowModelManager('7b3e01573b130000dada82c09ccf3dcf');
     *       model.getExecutedHistory();
     *       var current = model.getActivityHistoryRecordById('d6681d573b130000dada82c09ccf3d10');
     *       current.debugDump();
     *       
     *       var results = model.getNextByExecutedOrderId(current.sys_id);
     *       results.debugDump();
     * @returns The ActivityHistoryRecord JavaScript object requested.
     */
    getNextByExecutedOrderId(haRecordSysId: String): Object;

    /**
     * Retrieves the history activity that executed just after to the one identified by the sys_id provided in the argument. This function retreives the cached history record associated with the provided wf_history.sys_id and then calls getNextByTransition. The return values are based on which transitions came before the haRecord submitted and not necessarily the activities that executed just prior to the haRecord in time. To get the activity that executed prior to this activity in time, use getNextByExecutedOrder.This function retreives the cached history record associated with the provided wf_history.sys_id and then calls getNextByTransition. The return values are based on which transitions came before the haRecord submitted and not necessarily the activities that executed just prior to the haRecord in time. To get the activity that executed prior to this activity in time, use getNextByExecutedOrder.
     * 
     * @haRecordSysId sys_id of the activity history (table wf_history).
     * @example
     * var model = new WorkflowModelManager('7b3e01573b130000dada82c09ccf3dcf');
     *       model.getExecutedHistory();
     *       model.playBack();
     *       
     *       var current = model.getActivityHistoryRecordById('d6681d573b130000dada82c09ccf3d10');
     *       current.debugDump();
     *       var results = model.getNextByTransitionId(current.sys_id);
     *       gs.print('COMPLETED NEXT' + results.length );
     *       for( var i = 0; i &lt; results.length; i++){
     *           results[i].debugDump();
     *       }
     * @returns Array of ActivityHistoryRecord JavaScript objects.
     */
    getNextByTransitionId(haRecordSysId: String): ObjectArray;

    /**
     * Retrieves the history activity that executed just previous to the one provided in the argument.The previous status is based on the activity index reflecting the nearest prior activity in time and not necessarily the nearest prior activity with a valid transition to this activity. To get the nearest prior activity that transitioned to this haRecord passed in use getPreviousByTransition( haRecord). Note: In the process of assembling the execution order array, blanks are left in the array where history objects have been deleted. This ensures that the index in the array and the activity_index of the object remain in sync. For that reason, all objects coming out of the execution order array should be tested for nil() and not assumed to be the previous record based on activity_index or array index value.
     * 
     * @haRecord ActivityHistoryRecord JavaScript object
     * @returns The ActivityHistoryRecord JavaScript object requested.
     */
    getPreviousByExecutedOrder(haRecord: Object): Object;

    /**
     * Retrieves the history activity cached by the wf_history.sys_id provided in the argument, then calls getPreviousByExecutedOrder() with the retrieved JavaScript object.
     * 
     * @haRecordSysId Workflow history system ID (wf_history.sys_id)
     * @example
     * var model = new WorkflowModelManager('contextId');
     *       model.getExecutedHistory();
     *       var current = model.getActivityHistoryRecordById('wf_history.sys_id');
     *       current.debugDump();
     *       
     *       var results = model.getPreviousByExecutedOrderId(current.sys_id);
     *       results.debugDump();
     * @returns The ActivityHistoryRecord JavaScript object requested.
     */
    getPreviousByExecutedOrderId(haRecordSysId: String): ActivityHistoryRecord;

    /**
     * Retrieves the history activities that executed just prior to the one provided in the argument.The next status is based on the wf_activity.sys_id associated with the activity represented in the haRecord existing as a TO in a transition associated with any ActivityHistoryRecords that come before the haRecord in the execution sequence. (This differs from getAllTransitionedIntoActivity, which returns all TO transitions up to the given haRecord in the execution sequence .) The return value is a collection of ActivityHistoryRecords that identify the argument haRecord.wfaId as their TO activity. The return values are based on which transitions came before the haRecord submitted and not necessarily the activities that executed just prior to the haRecord in time. To get the activity that executed prior to this activity in time, use getPreviousByExecutedOrder.
     * 
     * @haRecord ActivityHistoryRecord JavaScript object.
     * @returns Array of ActivityHistoryRecord JavaScript objects requested.
     */
    getPreviousByTransition(haRecord: Object): ObjectArray;

    /**
     * Retrieves the history activities that executed just prior to the one provided in the argument.The next status is based on the wf_activity.sys_id associated with the activity represented in the haRecord existing as a TO in a transition associated with any ActivityHistoryRecords that come before the haRecord in the execution sequence. The return value is a collection of ActivityHistoryRecords that identify the argument haRecord.wfaId as their TO activity. The return values are based on which transitions came before the haRecord sumbitted and not not necessarily the activities that executed just prior to the haRecord in time. To get the activity that executed prior to this activity in time use getPreviousByExecutedOrder.
     * 
     * @haRecordSysId The sys_id of the activity history (table wf_history).
     * @returns Array of ActivityHistoryRecord JavaScript objects requested.
     */
    getPreviousByTransitionId(haRecordSysId: String): Object;

}

/**
 * Provides an AjaxProcessor wrapper for the WorkflowModelManager. This class derives from AbstractAjaxProcessor. Use this class in the Workflow Debug context menus.
 * 
 * 
 */
declare class WorkflowModelManagerAjax {



    /**
     * Puts the execution history into the return parameter based on the query string.
     * 
     */
    getExecutedHistory();

    /**
     * Puts the final execution activity list into the return parameter based on the query string.
     * 
     */
    getFinalExecutedActivityIdList();

    /**
     * Puts the rollback activity list into the return parameter based on the query string.
     * 
     */
    getRolledBackActivityIdList();

}

/**
 * This code is executed in business rule Set workflow scheduler script on table wf_workflow_schedule. 
 * 
 * 
 */
declare class WorkflowScheduler {



    /**
     * Starts the workflow specified in current, which is a record in table wf_workflow_schedule.This method is called from the Business Rule Set workflow scheduler script on table wf_workflow_schedule.
     * 
     */
    run();

}

/**
 * Generates a view that shows a workflow context on the timeline. 
 * 
 * 
 */
declare class WorkflowTimeline {



    /**
     * Generates the Ajax response for the timeline.This method is called by the Prototype JavaScript Framework. See the AbstractTimelineSchedulePage script include for more details.
     * 
     */
    getitems();

}

/**
 * Provides XML utilities for JavaScript to be used with Discovery scripts. Use this script include in any server-side discovery script where you need XML utilities. * * Access these methods using the static variable XMLUtilJS.
 * 
 * 
 */
declare class XMLUtilJS {



    /**
     * Provides escape text for a given string.
     * 
     * @text The text to format.
     * @returns The formatted text.
     */
    escapeForXMLText(text: String): String;

    /**
     * Converts a string to an XML value.
     * 
     * @str The string to convert
     * @returns The specified string converted to XML.
     */
    stringToValue(str: String): String;

    /**
     * Provides un-escaped text for a given string.
     * 
     * @text The text to clean up.
     * @returns The cleaned up string.
     */
    unescapeForXMLText(text: String): String;

    /**
     * Converts an XML value to a string.
     * 
     * @XMLvalue The XML to convert
     * @returns The XML value converted to a string.
     */
    valueToString(XMLvalue: String): String;

}


/**
 * A JSON String of Data will be returned. Recommend logging value to see content.
 */

declare interface JSONString {}
declare class RESTResponse extends sn_ws.RESTResponseV2{}
declare class gs extends GlideSystem{}
declare class SOAPResponse extends sn_ws.SOAPResponseV2{}
declare class $sp extends GlideSPScriptable{}
declare class GlideRecordSecure extends GlideRecord{}